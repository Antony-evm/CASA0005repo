--- 
title: "CASA0005 Geographic Information Systems and Science"
author: Andy MacLachlan^[The Bartlett Centre for Advanced Spatial Analysis, https://twitter.com/andymaclachlan] and Adam Dennett^[The Bartlett Centre for Advanced Spatial Analysis, https://twitter.com/adam_dennett]
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib, paper.bib]
biblio-style: apalike
link-citations: yes
github-repo: "andrewmaclachlan/CASA0005repo"
description: "The CASA0005 Geographic Information Systems and Science practical book"
url: 'https\://andrewmaclachlan.github.io/CASA0005repo/'
cover-image: general_images/casa_logo.png
apple-touch-icon: "assets/apple-touch-icon.png"
apple-touch-icon-size: 120
favicon: "assets/favicon.ico"
---

```{r include = FALSE}
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```
 
# Welcome {-}

[![status](https://jose.theoj.org/papers/a05734775775d1ef968e582ce9a7cb17/status.svg)](https://jose.theoj.org/papers/a05734775775d1ef968e582ce9a7cb17) [![License: CC BY-SA 4.0](https://img.shields.io/badge/License-CC_BY--SA_4.0-lightgrey.svg)](https://creativecommons.org/licenses/by-sa/4.0/)

Hello <a href="https://www.ucl.ac.uk/bartlett/casa/"><img src="general_images/casa_logo.jpg" width="120" alt="CASA0005 course" align="right" style="margin: 0 1em 0 1em" /></a> and a warm welcome to the CASA0005 Geographic Information Systems and Science online practical handbook. 

The buzzword ‘Big data’ and associated roles of data scientists have become common additions to academia, industry and government organisations seeking to optimise workflows and base decisions on factual evidence [@Donoho2017; @Li2016].In response, the demand for data scientists has significantly grown, with two major recruitment websites LinkedIn and Glassdoor reporting a respective 56% and 44% year on year increase in advertised roles along with classification as the most promising career based on salary, growth, promotion opportunities and satisfaction within the USA in 2019 [@Glassdoor2020; @Pattabiraman2019]. In a similar theme data from the UK’s Universities and Colleges Admissions Service (UCAS) shows that the number of postgraduate level data science courses within the UK has grown from 104 across 51 institutions to 195 across 85 institutions between the academic years commencing in 2019 and 2020 [@TheUniversitiesandCollegesAdmissionsService2020].

Whilst materials such as the R for Data Science book provide a foundational and essential resource for learning the R data science programming language, consideration of spatial data is extremely limited [@Grolemund2017]. The welcome addition of Geocomputation with R specifically addressed this resource gap, but often used basic examples that are unrepresentative of the complex spatial data wrangling, transformation and manipulation skills required by masters level graduates [@Lovelace2019]. Consequently, this content presents an academic teaching resource using applied real world government (e.g. [@Cosh2020]) and academic examples (e.g. [@Guha2018]) manipulating complex and large datasets in creating reproducible and actionable outputs, being made possible through delivery as a taught masters level module. 

## Acknowledgement {-}

Thanks to the following people who have either contributed directly or provided code in repositories that have helped me style this book:

<div class="col2">

* [STAT 545](https://stat545.com/index.html#other-contributors)
* [rstudio4edu](https://rstudio4edu.github.io/rstudio4edu-book/)
* [Hadley Wickham](https://twitter.com/hadleywickham)
* [Alison Presmanes Hill](https://twitter.com/apreshill)
* [Desirée De Leon](https://twitter.com/dcossyle)
* [Yihui Xie](https://twitter.com/xieyihui)
* [Robin Lovelace](https://twitter.com/robinlovelace)
* [Twitter for R programmers](https://www.t4rstats.com/index.html)
* [Matt Ng](https://twitter.com/mattnkm)
* [StatQuest with Josh Starmer](https://www.youtube.com/channel/UCtYLUTtgS3k1Fg4y5tAhLbw)
* [Julia Silge](https://twitter.com/juliasilge)
* [Jenny Bryan](https://twitter.com/JennyBryan)
* [Garrick Aden‑Buie](https://twitter.com/grrrck)
* [Edzer Pebesma](https://twitter.com/edzerpebesma?lang=en)
* [Roger Bivand](https://twitter.com/RogerBivand)
* [David Keys](https://twitter.com/dgkeyes)
</div><br/>

The R package and analysis artwork used within this book has been produced by [allison_horst](https://twitter.com/allison_horst), whilst artwork used in information boxes has been produced by [Desirée De Leon](https://twitter.com/dcossyle). You can find Allison's images on the [stats illustration GitHub repository](https://github.com/allisonhorst/stats-illustrations) and Desirée's on the [rstudio4edu GitHub repository](https://github.com/rstudio4edu/rmd4edu).

I've certainly learnt a lot from their open code repositories!

## Citation {-}

To cite this resource, please use: 

> MacLachlan et al., (2022). An Applied Geographic Information Systems and Science Course in R. Journal of Open Source Education, 5(50), 141, https://doi.org/10.21105/jose.00141 or [copy the Bibtex citation string](https://github.com/andrewmaclachlan/CASA0005repo/blob/master/citation.txt).


<!--chapter:end:index.Rmd-->

# (PART\*) Course information {-}

# Hello GIS {-}

Spatial analysis can yield fascinating insights into geographical relationships. However, at times it can be difficult to work with. You will get lots of error messages and have software crash. The academic staff are here to help you work through these practicals but we do not know everything. It's a good idea to become familiar with online sources of help, such as:

* [Stack Exchange](https://stackexchange.com/)
* [RStudio community](https://community.rstudio.com/)
* [QGIS documemtation](https://docs.qgis.org/3.4/en/docs/index.html)
* [R documentation](https://www.rdocumentation.org/)
* [ArcGIS help pages](https://support.esri.com/en)

Want to see what you can do with spatial analysis...check out this 'What's Next' video produced for the ESRI conference...

```{r echo=FALSE, fig.align='center', cache=TRUE}
knitr::include_url("https://www.youtube.com/embed/K0qZffiKwak")
```
## Intended course learning outcomes {-}

After having taking this module, you should be able to:

* Develop a working knowledge of QGIS and R to support the application of GI Science techniques

* Visualise geographic information through producing appropriate maps to high cartographic standards

* Carry out spatial data management tasks (joining attribute to geometry data, cleaning data, converting between file formats and spatial reference systems)

* Interpret data and apply relevant spatial analyses (e.g. auto correlation/hot spot analysis, areal interpolation, point in polygon/buffer analysis, spatial statistical analysis) to answer a variety of spatial problems

* Explain and evaluate common issues with geographic data such as representation and uncertainty

* Apply and critique (spatial) statistical analysis techniques to infer relationships between spatial phenomena

* Experience the diversity of the global spatial data landscape and evaluate the relative drawbacks and merits of different spatial datasets

::: {.infobox .tip data-latex="{note}"}
There is a lot of information within this practical book and **we do not expect you to read everything we link to**. You should attend each lecture, go through every practical and do some associated reading. 

This is a 15 credit module, equivalent to 150 hours of study (including the taught sessions). Outside of our lectures and practical sessions (3 hours a week) **you should be spending an extra 12 hours a week on this module**. 
:::

## How to use this book {-}

This website is hosted on GitHub and holds all the practical instructions and data. Data used within the practicals is available online, however occasionally websites can undergo maintenance or be inaccessible due to political factors such as government shutdowns.

To get the most out of this book spend a few minutes learning how to control it, in the top right of this webpage you will see this tools bar:

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=TRUE, message=FALSE}
knitr::include_graphics('general_images/Book_controls.png')
```

From left to right these buttons will let you:

* <i class="fa fa-bars fa-lg"></i> control the side bar

* <i class="fa fa-search fa-lg"></i> search the entire book for a specific word

* <i class ="fa fa-font settings fa-lg"></i> change the text size, font, colour

* <i class ="fa fa-edit fa-lg"></i> propose an edit if you see a mistake that I can review

* <i class="fa fa-download fa-lg"></i> view the webpage in the 'raw' RMarkdown format, we cover RMarkdown in the course 

* <i class="fa fa-info" fa-lg></i> information about shortcuts for this book and most others like it

In addition the <i class="fa fa-github fa-lg"></i> icon in the top right of the page takes you to the GitHub repository for this book, we cover GitHub in the course, but it's basically where the online files for the book are stored.

## Getting started {-}

One of the issues with GIS is that many of the files we will be working with are quite large. Fortunately in recent years UCL has seriously beefed up the storage available for students. You now get 100GB of free storage, which should be plenty for the work you will be doing this year! The Bartlett faculty has several gigabytes of storage space available on their central servers, so before we get started, we will connect to our N drive to carry out all of our practical work over the coming weeks. 

::: {.infobox .tip data-latex="{note}"}
The data we use in this practical book is representative of what you will find when conducting independent analysis. Some books and website will give you perfectly 'clean' and 'ready to use' data, we have not done this on purpose as it's very important to master data wrangling (also called data manipulation). In the 'real world' data is messy and it's vital you know how to deal with it. Take this quote from the [New York Times](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html) for example...

*"Data scientists, according to interviews and expert estimates, spend from 50 percent to 80 percent of their time mired in this more mundane labor of collecting and preparing unruly digital data, before it can be explored for useful nuggets."*

:::

## How to download data and files from GitHub {-}

The majority of data required for the workshops is found online and we detail how to download this within the workshops. On occasion you may need to get some data from my GitHub, the workshops will instruct you to do this where needed.

To do so you have a few options. Option 1 will let you download just a spceific folder whilst option 2 will download everything i have used to make the workshops.

### Option 1 {-}

Use [DownGit](https://minhaskamal.github.io/DownGit/#/home)

1. Go to: https://minhaskamal.github.io/DownGit/#/home

1. Head over to the GitHub repository: https://github.com/andrewmaclachlan/CASA0005repo

1. Select a folder you wish to download --- here i'll use practical data as the example, click into the folder (prac7_data) and copy the url: https://github.com/andrewmaclachlan/CASA0005repo/tree/master/prac7_data

1. Paste it into DownGit and click Download, once downloaded then unzip the folder.

### Option 2 {-}

1. Go to the online repository page here: https://github.com/andrewmaclachlan/CASA0005repo

1. Click Clone or download, the download as ZIP. This will download the everything i have used to make this website including all the data for the practicals

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=TRUE}
knitr::include_graphics('index_images/downloadrepo.png') 
```


## Self guided learning {-}

The lectures and practicals of this course only form a part of the learning process. You are expected to undertake wider reading and explore new methods and approaches. We have provided guidance on useful resources throughout the course to use as a starting point but you are encouraged to go beyond our recommedations and fully engage with applied GIS research, methods and visualisation techniques.

If you find a practical particularly easy or straightforward then please move on to the next one. Practicals that look at analytical relationships also have extension activities for you to try.

```{r include=FALSE, eval=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

## Interactive lectures {-}

During the lectures we will be using an interative polling and Q&A application called vevox. It's very simple to use, you can either:

* Download the app on iOS or Android: http://get.vevox.app 
* Use the web app: https://vevox.app/

The meeting ID we will use is: 186-395-009

## More help {-}

If you need specific assistance with this course please:

* Check the Moodle assessment tab for queries relating to assignments / deadlines. 

* Speak to a member of the teaching team in the computer lab sessions

* Ask a question at the end of a lecture (time permitting)

* Ask a question on slack under the GIS channel

Due to the size of the class we will **only reply** to messages **on slack** so all students can see the discussion. If you have a personal matter in relation to completing the course then please speak to or email Andy or Adam.

If you are struggling to use R don't worry...here is some advice from a tweet and  [interview](https://www.r-bloggers.com/advice-to-young-and-old-programmers-a-conversation-with-hadley-wickham/) with Hadley Wickham, chief scientist at RStudio...

<blockquote class="twitter-tweet tw-align-center"><p lang="en" dir="ltr">You&#39;re doing it right if you get frustrated: if you&#39;re not frustrated, you&#39;re (probably) not stretching yourself mentally</p>&mdash; Hadley Wickham (@hadleywickham) <a href="https://twitter.com/hadleywickham/status/565516733516349441?ref_src=twsrc%5Etfw">11. Februar 2015</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br/>

> It’s easy when you start out programming to get really frustrated and think, “Oh it’s me, I’m really stupid,” or, “I’m not made out to program.” But, that is absolutely not the case. Everyone gets frustrated. I still get frustrated occasionally when writing R code. It’s just a natural part of programming. So, it happens to everyone and gets less and less over time. Don’t blame yourself. Just take a break, do something fun, and then come back and try again later.

You can also go through other free resources including: 

* [Free RStudio Education resources](https://education.rstudio.com)

* [Codeacademy](https://www.codecademy.com/learn/learn-r)

* [YaRrr! The Pirate's Guide to R](https://bookdown.org/ndphillips/YaRrr/)

At the end of every practical there is a link anonymous Google feeback form, let us know if something is unclear and we will go over it in a future session.

If after pursuing all these avenues you still need help you can book into our office hours. These meetings are **to discuss a geographical concept in relation to the material/assessment or for any personal matters relevant to the completion of the module**.

These meetings are **not** to be used for specific technical issues. Problems of this nature should be addressed in the practical sessions.

[Andy](https://amaclachlan.youcanbook.me/)

[Adam](https://dr-d-casa.youcanbook.me)

If you give us minimal information in this form (e.g. one word) we will cancel the meeting.

## Reading list {-}

We link to books and resources throughout each practical and in the [Module resources] pages, but a full reading list for the course is provided [on the UCL library reading list page for the course](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), there is also a link to it over on Moodle.

We've tried to mostly recommend open source and free books, any others are available from the library.


<!--chapter:end:00-course_info.Rmd-->

# Software installation {-}

This course primarily uses the R data science programming language. We briefly touch upon QGIS to give you a basic foundation in the range of spatial software available, please follow the instructions below before the first practical session to install the software on your local computer if you are planning to use it throughout the course. 

## QGIS {-}

QGIS is an open-source graphic user interface GIS with many community developed add on packages that (or plugins) that provide additional functionality to the software.  

To get QGIS on your personal machine go to: https://qgis.org/en/site/forusers/download.html

I install the OSGeo4W version. The nature of open-source means that several programs will rely on each other for features. OSGeo4W tracks all the shared requirements and does not install any duplicates. 

When you click through the dialogue boxes you need to **search for QGIS in the OSGeo4W setup and click the refresh button** so it **changes from skip to install**....


```{r echo=FALSE, out.width = "450", fig.align='center', cache=FALSE, fig.cap="Continuous and discrete data. Source: [GIS Stackexchange](https://gis.stackexchange.com/questions/230672/how-to-install-osgeo4w-libraries-in-older-version-of-qgis-2-16)"}
knitr::include_graphics('general_images/QGIS_install2.png')
```

## R {-}

R is both a programming language and software environment, originally designed for statistical computing and graphics. R’s great strength is that it is open-source, can be used on any computer operating system and free for anyone to use and contribute to. Because of this, it is rapidly becoming the statistical language of choice for many academics and has a huge user community with people constantly contributing new packages to carry out all manner of statistical, graphical and importantly for us, geographical tasks.

### R Java {-}

Some R packages require you to download Java - it's just an extra bit of software you can get from the [Java website](https://www.java.com/en/download/manual.jsp). Select the offline version.

### Basics {-}

The advised method for using R is to download it to your personal machine, so you can use it in future without any issues.

To use "R" we need to bits of software:

- R itself: https://cran.rstudio.com/
- Then also RStudio: https://www.rstudio.com/products/rstudio/download/#download

R is the core software and RStudio gives a simpler interface for us to use it. If you used R (which you could) you'd be just typing code, with no other features. RStudio gives us other features to make this much easier, just like how you would never type a report in notepad (Windows) or notes (on Apple), you'd use the word processor to make it easier. Chester Ismay and Albert Y. Kim explain this with a car analogy: 

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="R vs RStudio. Source: [A ModernDive into R and the Tidyverse, Ismay and Kim, 2021](https://moderndive.com/1-getting-started.html)"}
knitr::include_graphics('general_images/r_vs_rstudio_1.png') 
```

R and RStudio are software that require updating over time. It's easy to forget!

### Packages {-}

Base R (controlled or driven through RStudio) is very limited. As a result people develop packages to make data loading, wrangling, analysis and visulisation much easier than having to write all the code. All packages will have lots of functions that just look up code from the package to make what you are doing easier (we will go into this in more detail later).

Packages develop over time and have different versions (like software). This can cause some issues with updates and code not working like it did once before. This book means i have to run all the code anyway, so every year it is checked and most packages are updated. 

There are many errors and issues that can arise with package installation. You should read the following section now so you are aware of it, but you won't need it until you hit an issue.

The most common package errors and issues are:

* The package relies on another package which you might not have --- this is called a dependency. Think about building a house --- moving in and living in the house is dependent on the foundations, the walls, the windows. The solution is to install the package you are missing.

* The package has a new version --- simply update it, in RStudio the package tab (which we will see in the module) has an update option.

* Your version of R might not support the package. This is unlikely as I update this every year. But to solve it either use an older version of the package and/or update your version of R. 

* There is an error with the package. If all else fails i remove the package and the re-install it. Again, in the package tab there is a small cross next to each package, clicking it let's you remove it. 

If the problem persists then assuming the error is `package xxx is not available` consult the [relevant stack overflow question](https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa) 

### Macs {-}

We (Andy and Adam) use windows machines and whilst R runs across all operating systems, Mac users often need to install some extra software and packages, but this will be apparent during the module. As the Mac operating system updates new issues do appear which we will address in the module, Twitter or slack.  

**However** don't do this until you get the error and if you get stuck then contact us via Twitter or Slack.  

You will likely need the package `rgdal` as the package `sf`, which we use extensively, is dependent on it. `rgdal` needs the `gdal` library to be installed on the computer (not as an R package), and it usually isn't installed on Macs.

To install it, follow [the stack overflow guide](https://stackoverflow.com/questions/34333624/trouble-installing-rgdal)

Mac users may need to install Java (which might involve removing the existing version) this is covered in the [Mac R issues] section. 

## ArcGIS {-}

As ArcGIS is not open source and from my experience analysis within it is largely not reproducible and therefore it is not included within this practical book. If you are interested in it please [consult previous iterations of this course](https://andrewmaclachlan.github.io/CASA0005repo_20192020/). You will find tutorials on: [Joining data](https://andrewmaclachlan.github.io/CASA0005repo_20192020/geographic-information.html#data-loading), [Map Making](https://andrewmaclachlan.github.io/CASA0005repo_20192020/map-making.html#mapping-in-arcmap) and [Spatial Patterns](https://andrewmaclachlan.github.io/CASA0005repo_20192020/analysing-spatial-patterns.html#arcmap-part-2). 

<!--chapter:end:00-software.Rmd-->


```{r include = FALSE}
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```
# External usage {-}

## How to adopt this course {-}

Not all data used within the practicals is distributed on GitHub due to size limitations. Each practical describe how to access the datasets used within.

There are two main options to adopt this course:

1. Adopt the course in its entirety:
  + Install R and RStudio
  + Clone the project from GitHub to RStudio (in RStudio, File > New Project > Version Control > Git)
  + Install the  `renv` package and install all packages within the project using `renv::restore()`. On the project's GitHub the `renv.lock` file contains all of the packages (and versions) used within it.  
  + If you wish to build the book at any point, practicals (RMarkdown files) without data can be removed by commenting out the file (with a #) in the `_bookdown.yml` file.
  
For more details on how to use Git, GitHub and `renv` see the practical [Git, GitHub and RMarkdown]

2. Adopt a single practical by downloading the `.rmd` file, packages loaded within the `.rmd` file and associated data from the links listed within it.  

## How to contribute {-}

We welcome contributions to the material either directly, for any small issues or errors (e.g. typos) or through a GitHub issue for larger issues (e.g. further explanation requests, bugs in the code)

**For smaller issues** click the <i class ="fa fa-edit fa-lg"></i> button in the top tool bar: 

* Create a fork of the repository and clone it to your local computer
* Create a local branch 
* Make changes to that branch (commit them)
* Push the changes to your GitHub fork
* Once you have made then [open a pull request](https://github.com/andrewmaclachlan/CASA0005repo/pulls) for it to be considered. 

**For larger issues** [open a issue on the project's GitHub issue page](https://github.com/andrewmaclachlan/CASA0005repo/issues). 

If raising an issue please provide sufficient detail that it can be reproduced with a minimal worked example (where possible). Be sure to include the following:

* A short explanation of the bug and it's environment (e.g. operating system).
* A step by step guide to reproduce it.

**For clarification on concepts** please either [open an issue on the project's GitHub issue page](https://github.com/andrewmaclachlan/CASA0005repo/issues) or submit the anonymous feedback form at the end of each practical. 

Alternatively, reach out to us on Twitter:

* [Andy MacLachlan](https://twitter.com/andymaclachlan)
* [Adam Dennett](https://twitter.com/adam_dennett)

## Supporting the module {-}

If you found the content useful, please support us by:

* Telling your friends about it
* [Citing the book](https://jose.theoj.org/papers/a05734775775d1ef968e582ce9a7cb17)
* [linking to the book home page](https://andrewmaclachlan.github.io/CASA0005repo/)
* [Starring](https://docs.github.com/en/get-started/exploring-projects-on-github/saving-repositories-with-stars) the [GitHub repository](https://github.com/andrewmaclachlan/CASA0005repo)
* Tweeting us: 
- [Andy MacLachlan](https://twitter.com/andymaclachlan)
- [Adam Dennett](https://twitter.com/adam_dennett)
- [CASA](https://twitter.com/CASAUCL)

## License {-}

If you use this material for teaching, research or anything else please let me (Andy) know via [Twitter](https://twitter.com/andymaclachlan) or email --- a [dot] maclachlan [at] ucl [dot] ac [dot] uk).

This practical book is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) License](https://creativecommons.org/licenses/by-sa/4.0/).
<center>
<i class="fab fa-creative-commons fa-2x"></i><i class="fab fa-creative-commons-by fa-2x"></i><i class="fab fa-creative-commons-sa fa-2x"></i>
</center>

You are free to: 

* **Share** — copy and redistribute the material in any medium or format

* **Adapt** — remix, transform, and build upon the material
for any purpose, even commercially.

However, you  give appropriate credit, provide a link to the license, and indicate if changes were made. If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

But, you do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.

## Updates {-}

This is the third iteration of the practical book, representing the third year it has been hosted in this format.

Previous versions can be found at the following links.

* 2020-2021 academic year (on which the JOSE paper is based): https://andrewmaclachlan.github.io/CASA0005repo_20202021/

* 2019-2020 academic year: https://andrewmaclachlan.github.io/CASA0005repo_20192020/

A summary of changes is provided on the current README.md file: https://github.com/andrewmaclachlan/CASA0005repo

## Packages {-}

This bookdown document was built with:

```{r message = FALSE, warning = FALSE, echo = FALSE}
library(tidyverse)
library(devtools)
library(DT)

# needed because new_session is set to true in _bookdown.yml
all_pkgs <- renv::dependencies(path = "DESCRIPTION") %>% 
  pull(Package) 

session <- devtools::session_info(pkgs = all_pkgs)

session$platform
```

And makes use of the following packages throughout. Thanks to [STAT 545](https://stat545.com/index.html#other-contributors) for this code.

```{r message = FALSE, warning = FALSE, echo = FALSE}
library(dplyr)
session$packages %>% 
  dplyr::select(package, loadedversion, date, source) %>% 
  DT::datatable(rownames = FALSE,
                class = 'cell-border stripe',
                filter = list(position = 'top'),
                options = list(pageLength = nrow(session$packages), 
                           autoWidth = TRUE,
                           bInfo = FALSE,
                           paging = FALSE))
```

<!--chapter:end:00-usage.Rmd-->

# (PART) GIS tools {-}

# Geographic Information

## Learning outcomes

By the end of this practical you should be able to:

1.  Describe and explain GIS data formats and databases
1.  Source and pre-process spatial data
1.  Load and undertaken some basic manipulation of spatial data in QGIS and R
1.  Evaluate the (dis)advantages of each GIS you have used

## Homework

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

The task is to join some non spatial data to some spatial data.

* Go to the [New Zealand spatial data portal](https://datafinder.stats.govt.nz/) and download the file Territorial Authority 2018 (generalised), [these are city or district councils](https://www.localcouncils.govt.nz/lgip.nsf/wpg_url/About-Local-Government-Local-Government-In-New-Zealand-Councils-roles-and-functions#TerritorialAuthorities(District%20and%20City%20Councils)). Make sure it's the Territorial Authority 2018 data **not** SA1. 

* Go to the [Stats NZ website](https://www.stats.govt.nz/information-releases/statistical-area-1-dataset-for-2018-census-updated-march-2020) and download the Statistical area 1 dataset for 2018 for the whole of New Zealand. Download the excel file this week, **not** the `.csv`.

* Unzip the downloaded census file and open  2018-SA1-dataset-individual-part-3a-total-NZ_updated_16-7-20, you will see a tab for Territorial authority. Join the 2018 paid employee field to the spatial data and make a basic map. Hint, you may need to make a new `.csv` file from the data.

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

Each week i'll provide a core chapter to support the skills taught here. However, **you are free to read whatever interests you** and Adam and I strongly encourage this, so please don't be constrained to this recommendation. Consult the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture each week for more ideas.

This week:

-   [GIS and Cartography](https://www.sciencedirect.com/science/article/pii/B9780080449104000341) by Goodchild (2009)

-   [Chapter 2 "Geographic data in R"](https://geocompr.robinlovelace.net/spatial-class.html) from Geocomputation with R by Lovelace, Nowosad and Muenchow (2020).

-   [Opening practice: supporting reproducibility and critical spatial data science](https://link.springer.com/article/10.1007/s10109-020-00334-2#Sec3) by Brunsdon and Comber (2020)

**Watching**

-   [What is Spatial Data Science](https://www.youtube.com/watch?v=osAbJeTho5w) from some of our friends at CARTO
:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/1A3nVEWRJ8yvlPzawHI1pQ). Week 1. No other choice than Vampire Weekend. The band formed during college (University in the USA) and produced their first album of their own whilst working full time jobs! Incredible. The lead vocalist and guitarist Ezra Koenig was a school teacher in Brooklyn, New York. I've seen them a few times at Glastonbuty and in London during which they gave the people what they wanted and took requests from their entire catalogue, really amazing musicians. Note some of the guest appearances in this album as they also might make an apperance later in the term!

[Adam](https://open.spotify.com/album/3LVWk5ZlGgFPvTUVSo8EKh?si=0tvDERBmRAOQgyRztZK-iw) OK, it's week 1, so I'm going in HARD. This week it's the raver's raver, the DJ's DJ. This man is a style icon and so drum & bass it hurts - it's Voltage! Here he is with his new album, Balance Over Symmetry. This will surprise a lot of people as it's an eclectic mix of DnB bangers through to some Burial-inspired minimal dubstep. Follow him on [Instagram](https://www.instagram.com/voltage_uk_/) and get your ears around his brilliant.

## The Basics of Geographic Information

Geographic data, geospatial data or geographic information is data that identifies the location of features on Earth. There are two main types of data which are used in GIS applications to represent the real world. **Vectors** that are composed of points, lines and polygons and **rasters** that are grids of cells with individual values...

```{r echo=FALSE, out.width = "300pt", fig.align='center', cache=FALSE, fig.cap="Types of spatial data. Source: [Spatial data models](https://planet.uwc.ac.za/nisl/gis/web_page/page_15.htm)"}
knitr::include_graphics('prac1_images/rasvec.jpg') 
```

In the above example the features in the real world (e.g. lake, forest, marsh and grassland) have been represented by points, lines and polygons (vector) or discrete grid cells (raster) of a certain size (e.g. 1 x 1m) specifying land cover type.

### Data types in statistics

Before we go any further let's just quick go over the different types of data you might encounter

Continuous data can be measured on some sort of scale and can have any value on it such as height and weight.

Discrete data have finite values (meaning you can finish counting something). It is numeric and countable such as number of shoes or the number of computers within the classroom.

Foot length would be continuous data but shoe size would be discrete data.

```{r echo=FALSE, out.width = "450", fig.align='center', cache=FALSE, fig.cap="Continuous and discrete data. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/continuous_discrete.png')
```

Nominal (also called categorical) data has labels without any quantitative value such as hair colour or type of animal. Think names or categories - there are no numbers here. 

Ordinal, similar to categorical but the data has an order or scale, for example if you have ever seen the chilli rating system on food labels or filled a happiness survey with a range between 1 and 10 --- that's ordinal. Here the order matters, but not the difference between them.

Binary data is that that can have only two possible outcomes, yes and no or shark and not shark.

```{r echo=FALSE, out.width = "550pt", fig.align='center', cache=FALSE, fig.cap="Nominal, ordinal and binary data. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/nominal_ordinal_binary.png')
```

### Important GIS data formats

There are a number of commonly used geographic data formats that store vector and raster data that you will come across during this course and it's important to understand what they are, how they represent data and how you can use them.

#### Shapefiles

Perhaps the most commonly used GIS data format is the shapefile. Shapefiles were developed by [ESRI](http://www.esri.com/), one of the first and now certainly the largest commercial GIS company in the world. Despite being developed by a commercial company, they are mostly an open format and can be used (read and written) by a host of GIS Software applications.

A shapefile is actually a collection of files ---- at least three of which are needed for the shapefile to be displayed by GIS software. They are:

1.  `.shp` - the file which contains the feature geometry
2.  `.shx` - an index file which stores the position of the feature IDs in the `.shp` file
3.  `.dbf` - the file that stores all of the attribute information associated with the coordinates -- this might be the name of the shape or some other information associated with the feature
4.  `.prj` - the file which contains all of the coordinate system information (the location of the shape on Earth's surface). Data can be displayed without a projection, but the `.prj` file allows software to display the data correctly where data with different projections might be being used

On Twitter and want to see the love for shapefiles....have a look at [the shapefile account](https://twitter.com/shapefiIe)

#### GeoJSON

GeoJSON [Geospatial Data Interchange format for JavaScript Object Notation](http://geojson.org/) is becoming an increasingly popular spatial data format, particularly for web-based mapping as it is based on JavaScript Object Notation. Unlike a shapefile in a GeoJSON, the attributes, boundaries and projection information are all contained in the same file.

#### Shapefile and GeoJSON

We're now going to explore a shapefile (`.shp` ) and GeoJSON (`.geojson`) in action.

Go to: <http://geojson.io/#map=16/51.5247/-0.1339>

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/JSONwebsite.png') 
```

1.  Using the drawing tools to the right of the map window, create 3 objects: a point, line and a polygon as I have done above. Click on your polygon and colour it red and colour your point green
2.  Using the 'Save' option at the top of the map, save two copies of your new data -- one in `.geojson` format and one in `.shp` format
3.  Open your two newly saved files in a text editor such as notepad or notepad++. For the shapefile you might have to unzip the folder then open each file individually. What do you notice about the similarities or differences between the two ways that the data are encoded?

#### Raster data

Most raster data is now provided in GeoTIFF (`.tiff`) format, which stands for Geostarionary Earth Orbit Tagged Image File. The GeoTIFF data format was created by NASA and is a standard public domain format. All necesary information to establish the location of the data on Earth's surface is embedded into the image. This includes: map projection, coordinate system, ellipsoid and datum type.

#### Other data formats

Aforementioned data types and formats are likely to be the ones you predominately encounter. However there are several more used within spatial analysis. These include:

**Vector**

-   GML (Geography Markup Language ---- gave birth to Keyhold Markup Language (KML))

**Raster**

-   Band SeQuential (BSQ) - technically a method for encoding data but commonly referred to as BSQ.
-   Hierarchical Data Format (HDF)
-   Arc Grid

There are normally valid reasons for storing data in one of these other formats. For example, BSQ are raster data with a separate text header file (`.hdr`) providing geographic spatial reference information. Earth observation data often monitors the electromagnetic spectrum in bands. Humans see in the visible range of the spectrum and our vision is composed of red, green and blue wavelengths. If we wanted to analyse just the red wavelength the BSQ format would let us *read in* only that data. In comparison a GeoTIFF might come with all the data 'packaged' in one file and when doing analysis over thousands of images would significantly slow things down. That said you can now often find GeoTIFFs separated in a similar format to BSQ and it's fairly straightforward to convert between raster formats.

#### Geodatabase

A geodatabase is a collection of geographic data held within a database. Geodatabases were developed by ESRI to overcome some of the limitations of shapefiles. They come in two main types: Personal (up to 1 TB) and File (limited to 250 - 500 MB), with Personal Geodatabases storing everything in a Microsoft Access database (`.mdb`) file and File Geodatabases offering more flexibility, storing everything as a series of folders in a file system. In the example below we can see that the FCC_Geodatabase (left hand pane) holds multiple points, lines, polygons, tables and raster layers in the contents tab.

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/geodatabase.png') 
```

#### GeoPackage

```{r echo=FALSE, out.width = "100pt", fig.align='center', cache=FALSE, fig.cap="GeoPacakge logo"}
knitr::include_graphics('prac1_images/geopkg.png')
```

A GeoPackage is an open, standards-based, platform-independent, portable, self-describing, compact format for transferring geospatial data. It stores spatial data layers (vector and raster) as a single file, and is based upon an SQLite database, a widely used relational database management system, permitting code based, reproducible and transparent workflows. As it stores data in a single file it is very easy to share, copy or move.

#### SpatiaLite

```{r echo=FALSE, out.width = "100pt", fig.align='center', cache=FALSE, fig.cap="SpatialLite logo"}
knitr::include_graphics('prac1_images/spatialite.png')
```

SpatialLite is an open-source library that extends SQLite core. Support is fairly limited and most software that supports SpatiaLite also supports GeoPackage, as they both build upon SQLite. It doesn't have any clear advantage over GeoPackage, however it is unable to support raster data.

#### PostGIS

```{r echo=FALSE, out.width = "100pt", fig.align='center', cache=FALSE, fig.cap="PostGIS logo"}
knitr::include_graphics('prac1_images/postGIS.jpg') 
```

PostGIS is an opensource database extender for PostrgeSQL. Essentially PostgreSQL is a database and PostGIS is an add on which permits spatial functions. The advantages of using PostGIS over a GeoPackage are that it allows users to access the data at the same time, can handle large data more efficiently and reduces processing time. In [this example](https://medium.com/@GispoLearning/learn-spatial-sql-and-master-geopackage-with-qgis-3-16b1e17f0291) calculating the number of bars per neighbourhood in Leon, Mexico the processing time reduced from 1.443 seconds (SQLite) to 0.08 seconds in PostGIS. However, data stored in PostGIS is much harder to share, move or copy.

#### What will I use

The variety of data formats can see a bit overwhelming. I still have to check how to load some of these data formats that I don't use frequently. But don't worry, most of the time you'll be using shapefiles, GeoPackages or raster data.

## General data flow

As Grolemund and Wickham state in [R for Data Science](https://r4ds.had.co.nz/)...

> "Data science is a huge field, and there's no way you can master it by reading a single book."

However, a nice place to start is looking at the typical workflow of a data science (or GIS) project which you will see throughout these practicals, which is summarised nicely in this diagram produced by [Dr. Julia Lowndes](https://twitter.com/juliesquid) adapted from Grolemund and Wickham.

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE, fig.cap="Updated from Grolemund & Wickham's classis R4DS schematic, envisioned by Dr. Julia Lowndes for her 2019 useR! keynote talk and illustrated by Allison Horst. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/environmental_data_science_r4ds_general.png')
```

To begin you have to **import** your data (not necessarily environmental) into R or some other kind of GIS to actually be able to do any kind of analysis on it.

Once imported you might need to **tidy** the data. This really depends on what kind of data it is and we cover this later on in the course. However, putting all of your data into a consistent structure will be very beneficial when you have to do analysis on it --- as you can treat it all in the same way. Grolemund and Wickham state that data is tidy when "each column is a variable, and each row is an observation", we cover this more in next week in the [Tidying data] section.

When you have (or haven't) tidied data you then will most likely want to **transform** it. Grolemund and Wickham define this as "narrowing in on observations of interest (like all people in one city, or all data from the last year), creating new variables that are functions of existing variables (like computing speed from distance and time), and calculating a set of summary statistics (like counts or means)". However, from a GIS point of view I would also include putting all of your data into a similar projection, covered next week in [Changing projections] and any other basic process you might do before the core analysis. Arguably these processes could include things such as: clipping (cookie cutting your study area), buffering (making areas within a distance of a point) and intersecting (where two datasets overlap).

Tidying and transfrom = data wrangling. Remember from the introduction this could be 50-80% of a data science job!

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="dplyr introduction graphic. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_wrangling.png')
```

After you have transformed the data the next best thing to do is **visualise** it --- even with some basic summary statistics. This simple step will often let you look at your data in a different way and select more appropraite analysis.

Next up is **modelling**. Personally within GIS i'd say a better term is processing as the very data itself is usually a computer model of reality. The modelling or processing section is where you conduct the core analysis (more than the basic analysis already mentioned) and try to provide an answer to your research question.

Fianlly you have to **communicate** your study and outputs, it doesn't matter how good your data wrangling, modelling or processing is, if your intended audience can't interpret it, well, it's pretty much useless.

::: {.infobox .tip data-latex="{note}"}
In a few weeks come back and revisit this data flow section to see how what you have learnt fits the framework presented.
:::

## Data

The volume of geographic information which is freely available for use in the UK is increasing exponentially and spatially referenced data can often be found in many different places. In this practical we're going to use data from the London data store --- a free and open data-sharing portal provided by the Greater London Authority (GLA), also known as City Hall that is the devolved regional governance body of London.

We are going to get spatial data of the London boroughs and join flytipping (the illegal deposit of waste, commonly on road verges) data that is provided as a `.csv` file. `.csv` stands for comma-separated values (CSV) --- it uses a comma to separate each value.

At the end of this document I'll also run through some common sources of data that will stand you in good stead (be advantageous) for the rest of the course.

### File paths

In your N drive: create a new folder called GIS and within this a sub folder called wk1. It is up to you how you organise your files. Make sure you change the file paths where appropriate to your own.

### Data download

Firstly we need to get a spatial outline of the London boroughs. The geographic boundaries that are used in the UK are a complex, often inter-related, but ever changing mass of areas. For anyone new to the UK (or indeed not a trained quantitative geographer), it can be quite a daunting task to attempt to understand all of the boundaries that are in use. Fortunately the Office for National Statistics (ONS) has an online beginners guide to UK geography. If you need more information on the vast array of different UK geographies, go and explore these resources:

-   <https://geoportal.statistics.gov.uk/datasets/9c04ff58854040d09a5a7ce146ab59b4>

Another [easy to read guide on census / administrative geography](https://www.towerhamlets.gov.uk/Documents/Borough_statistics/Research-tools-and-guidance/RB-Census2011-Census-Geography-Guide-2013-05.pdf) was produced by the London Borough of Tower Hamlets - skip to page 2 for a visual summary

Let's download some data..

-   Spatial Data

1.  To get the data go to the [London data store](https://data.london.gov.uk/)

2.  Search for Statistical GIS Boundary Files for London

3.  Download the statistical-gis-boundaries-london.zip

4.  Unzip the data and save it to your wk1 folder.

-   CSV data

1.  On the same website search for fly-tipping incidents

2.  Download the `.csv` file

### Data pre-processing

**Question** Open the `.csv` in Excel, what do you notice about how the data is stored?

**Answer** The year is a column and for each area the values are repeated for different years. In our analysis it is easier to have the different years as a column and populated for each area. So, we want to go from this...

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/csv_original.png')
```

To this...

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/csv_pivot.png')
```

::: {.infobox .tip data-latex="{note}"}
In previous years there have errors in this `.csv`, for example there used to be year value of 2017-2018 that was incorrect. Whilst these have been resolved, it's always important to check your data. 
:::

As we are going to use this dataset in QGIS and R I've done it in Excel using a pivot table. In future we'll use R to automate tasks like this.

1.  Go to Insert \> PivotTable

2.  Select the original table and create a PivotTable in a new worksheet

3.  The PivotTable Field box will appear, experiment with the different fields in each of the areas

I've used the following:

```{r echo=FALSE, out.width = "400pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/pivot_example.png')
```

Note how I've altered the total_action_taken to the sum of... as the original was displaying incorrectly, to do so:

1.  Click on drop down button for total_action_taken \> Value Field Settings \> select Sum

It's important to think about what data we actually need in the next step and it's good practice to avoid data redundancy where possible.

**Spoiler** The spatial data we have downloaded already contains borough name, so we don't need it twice. However, we do need a field to link the two datasets on. You could use borough name, but when using text fields sometimes input variations can affect joins. For example, if you had the University of Manchester in one dataset and Manchester University in another the join would fail. Consequently it's usually best to join datasets on a code field.

Now save the Excel sheet that contains the pivot table as a new `.csv`. Make sure that the first row of data holds the column titles. Remove all empty rows.

When saving the file also avoid any special characters (e.g. -) and spaces, use an underscore instead of spaces.

::: {.infobox .warning data-latex="{note}"}
**Warning** Spatial software does not like file names with spaces or special characters.
:::

Now it's time to load, inspect and do some basic manipulation of this data. As mentioned in the lecture there are several GIS software 'types', here we will repeat the same process across QGIS and R.

### QGIS

#### Load data

1.  Search for and open QGIS
2.  Click on the open data source manager. Just above the word **browser** in the top left of the screen

```{r echo=FALSE, out.width = "700pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/qgis_datamanager.png') 
```

1.  Navigate to the `London_Borough_Excluding_MHW.shp` and add it, you then have to close the data source manager.

You can right click on the layer to view the attribute table, however the `.csv` file must be loaded nto QGIS in order to join it to a shapefile.

1.  Open the data source manager and select Delimited Text
2.  Navigate to our `.csv` file and provide a suitable layer name
3.  Under Record and Fields Options make sure the number of header lines to discard is 0 and the First record has field names box is selected (this is assuming you left a title for each column in your `.csv`)
4.  Under Geometry Definition select No geometry (attribute table only)

```{r echo=FALSE, out.width = "700pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/csv_datamanager.png') 
```

Does the sample data seem right?

1.  If so, click add then close

::: {.infobox .warning data-latex="{note}"}
**Note** Your `.csv` might have a extra header present (a row before Row Labels). You can either: (a) close this and go and delete this in the `.csv` now and reload it or (b) change the number of header lines to discard to 1 in the Record and Fields Options in the screenshot above.
:::

#### Join data

1.  Right click on the London boroughs layer \> Properties \> Joins
2.  Click the plus button at the bottom of the box
3.  Complete the dialogue box

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/qgis_join.png') 
```

#### Export data

Now let's export to a GeoPackage.

1.  Right click on the London boroughs layer \> Export \> Save Feature As
2.  Select the GeoPackage format and complete the File name (the saved file name for the GeoPackage) and the Layer name (the name for this layer within the GeoPackage). Recall that a GeoPackage can store many data layers as a single file
3.  The new layer will be added to the map, so you can remove the old one (Right click on the layer \> Remove Layer). Make sure you remove the right one!

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/make_geopkg.png') 
```

We've now made a GeoPackage that we can connect our map project to.

1.  Under **Browser**, Right click on GeoPackage \> New Connection \> Navigate to your GeoPackage
2.  Click the down arrow left to GeoPackage and you should see the one you just navigated to. Click the down arrow on the database and you can see your layer.
3.  Now we are going to import our `.csv` into our GeoPackage. To do so go: Database \> DB Manager
4.  Select your GeoPackage in the left hand pane
5.  Import layer/file then select the `.csv`. Click Ok.

Again, remember that the `.csv` in the Layers tab (bottom left) is the original. Remove it, then from the GeoPackage just click, hold and drag the `.csv` into the layer pane.

Now let's make a quick thematic map...

1.  Right click on your London boroughs layer \> Properties \> Symbology
2.  Select categorised and choose a data column and color ramp \> click Classify

You could also select graduated, to do so, simply change the number of classes. 

1.  Save your QGIS project

You should have produced something like this:

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/QGIS_final.png') 
```

::: {.infobox .tip data-latex="{note}"}
This a very basic map and we've just used raw counts to show how to join and map data. You should (almost) never do this, as counts can be misleading. This is because the counts are collected over areas of unequal size. It's best to divide the values by some sort of denominator (e.g. area of borough, population) to normalise the data giving something like occurrence of flytipping per km2 enabling comparison between the boroughs. We cover this in more detail before reading week.
:::

**We haven't talked about the Coordiante Reference System (CRS) (or Spatial Reference System (SRS)) of our map document**

A coordinate reference system is a series of parameters that define the coordinate system. Within GIS we use geographic or projected coordinate systems. The former uses a three-dimensional spherical surface to define locations of Earth, whereas the latter is defined on a flat, two-dimensional surface giving it constant lengths, angles and areas. We cover this in much more detail later on in subsequent weeks.

QGIS defaults to the Coordinate Reference System (CRS) WGS 84, or known by its European Petroleum Survey Group (EPSG) code 4326. However, when you add your first layer it will default the CRS of the layer. We'll go into the background of EPSG next time.

You can change the CRS by going Project \> Properties and selecting CRS in the left hand pane.

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/QGIS_CRS.png') 
```

::: {.infobox .tip data-latex="{note}"}
You can also access the project CRS by just clicking on the EPSG code in the bottom right of your QGIS window, in the screenshot above click EPSG:27700.
:::

::: {.infobox .warning data-latex="{note}"}
**Note** As we are going to open the same files in difference GIS systems it is important to close the software before moving on. If you don't then files can be *locked* and unreadable as they are still considered to be in use.
:::

### R

#### Introduction

R is both a programming language and software environment, originally designed for statistical computing and graphics. R's great strength is that it is open-source, can be used on any computer operating system and free for anyone to use and contribute to. Because of this, it is rapidly becoming the statistical language of choice for many academics and has a huge user community with people constantly contributing new packages to carry out all manner of statistical, graphical and importantly for us, geographical tasks.

The purpose of this practical is just to demonstrate data loading and manipulation in different software. The next practical will provide much more detail on R, so don't worry about that.

In RStudio go:

1.  File \> New File \> R Script

You should be able to see these quadrants (without the code):

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/RStudio.png') 
```

Below are bits of code, to start we will work using the **console**. So just copy the bits of code into the console window, changing the file names to where your data is stored. Then at the end of this section I'll show you how to make a script.

R works on packages that are collections of functions and data. Packages are bits of code that extend R beyond the basic statistical functionality it was originally designed for. For spatial data, they enable R to process spatial data formats, carry out analysis tasks and create some of the maps that follow. Most packages are easily recognisable through a hexagon (hex) logo, or sticker. 

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="R pacakge hex sticker wall. Source: [Mitchell O'Hara-Wild arranging Hex stickers in R](https://www.mitchelloharawild.com/blog/hexwall/)"}
knitr::include_graphics('prac1_images/hex_stickers.png') 
```

Bascially, without packages, R would be very limited. With packages, you can do virtually anything! One of the issues you will come across is that packages are being continually developed and updated and unless you keep your version of R updated and your packages updated, there may be some functions and options not available to you. This can be a problem, particularly with University installations which (at best) may only get updated once a year. Therefore, apologies in advance if things don't work as intended, but there is often a work around.

For this practical we will need the ones listed in the code chunk below. Whilst we've installed them (with the code below), we haven't yet loaded them. It's best practice to do all this at the start of your code, however, for demonstration purposes I'll load each one as we need it.

```{r, message=FALSE, warning=FALSE, eval=FALSE, cache=FALSE}
install.packages(c("sf", "tmap", "tmaptools", "RSQLite", "tidyverse"), 
                 repos = "https://www.stats.bris.ac.uk/R/")
```

1.  We can also install and load packages through RStudio. If you can see the package listed in the package tab it is installed and a tick means it is loaded.

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/r_packages.png') 
```

Packages we've installed with our code:

-   `sf`: simple features, standard way to encode spatial vector data
-   `tmap`: layer-based and easy approach to make thematic maps
-   `tmaptools`: set of tools for reading and processing spatial data
-   `RSQLite`: embeds the SQLite database engine in R

Here, `repos` stands for repository where we will download the packages from. Once you have set it, you shouldn't need to specify it again. Whilst we've installed the packages we haven't loaded them...this is done through using `library()` function.

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE, fig.cap="Installing vs loading (with library) packages. Source: [Dianne Cook](https://twitter.com/visnut)"}
knitr::include_graphics('prac1_images/install_library.jfif') 
```

If you are **using a Mac** you might also need `rgdal`... this is because a lot of packages are dependent on it and it might not properly install...

```{r, message=FALSE, warning=FALSE, eval=FALSE, cache=FALSE}
install.packages("rgdal")
```

Then load `rgdal`...

```{r, message=FALSE, warning=FALSE, eval=FALSE, cache=FALSE}
library(rgdal)
```

If you still have issues the check out the [Mac R issues] section

#### Load data

Load the `sf` package so we can read our shapefile in --- remember to change to filepath to your shapefile.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="sf introduction graphic. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/sf.png', )
```

For this first practical we'll just leave the data where it is, next week we'll show you how to use projects to make calling data much easier.

> **Note** by default in R, the file path should be defined with `/` but on a windows file system it is defined with `\` (e.g. when looking at files on your computer they will be folder\file). Using `\\` instead allows R to read the path correctly -- alternatively, just use `/`

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(sf)
# change this to your file path!!!
shape <- st_read("C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp")
```

> **Note** If you are working on the UCL RStudio Server and have a shapefile (along with all the other relevant files required) you will just need to use...

```{r, message=FALSE, warning=FALSE, cache=FALSE, eval=FALSE}
shape <- st_read("London_Borough_Excluding_MHW.shp")
```

As RStudio cloud knows you have setup a project and to look for files within it...we cover this very soon for RStudio desktop.

To get a summary of the data held within the shapefile data (attribute table) enter the following:

```{r, cache=FALSE}
summary(shape)
```

To have a quick look what the shapefile looks like enter the following:

```{r, cache=FALSE}
plot(shape)
```

That plots everything in the shapefile (all the attributes) if you just wanted the geometry (outline of the shape) you could use...

```{r, message=FALSE}
library(sf)
shape %>% 
  st_geometry() %>%
  plot()
```

From what we did in QGIS this should look familiar.

We now need to load our `.csv` file:

```{r message=TRUE, warning=FALSE, cache=FALSE}
library(tidyverse)
#this needs to be your file path again
mycsv <-  read_csv("C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/fly_tipping_borough_edit.csv")  
```

When you load `tidyverse` you might get a list of conflicts, this basically means that several packages have functions named the same thing. For example there is a function named `filter()` in the packages `dplyr` and `stats`. If you wanted to use the `dplyr` version you would use `dplyr::filter()` or for the `stats` version it would be `stats::filter()`...

::: {.infobox .warning data-latex="{note}"}
**Note** Your `.csv` might have a extra header present (a row before Row Labels). You can either: (a) stop and go and delete this in the `.csv` now and reload it or (b) change the code to... `mycsv <- read_csv("prac1_data/fly_tipping_borough_edit.csv",      skip = 1)`
:::

To view the data just input:

```{r cache=FALSE, warnings=FALSE, messages=FALSE}
mycsv 
```

#### Join data

In R we've given our London boroughs shapefile the name `shape` and our flytipping `.csv` the name `mycsv`. If you look in the Environment quadrant you should see them both listed.

Join the `.csv` to the shapefile. Here, replace Row Labels with whatever your GSS_CODE is called in the `.csv`:

```{r, cache=FALSE}
shape <- shape%>%
  merge(.,
        mycsv,
        by.x="GSS_CODE", 
        by.y="Row Labels")

```

Let's break this down a bit. We just created a tibble of `mycsv` (this is a new form of a dataframe) where each column has a variable and each row contains a set of values --- so basically a normal table. We did this simply by using `read_csv()` to read the data in. We then matched our `csv` to our `shape` based on the `GSS_CODE` values in both.

Check the merge was successful, this is just going to show the top 10 rows:

```{r cache=FALSE}
shape%>%
  head(., n=10)
```

Now, let's make a quick thematic map (or a qtm) using the package `tmap`. I've made mine for flytipping between 2011 and 2012 (column 2011_12). But check what your column name is from the above code `head(shape, n=10)` it might be slightly different like 2011-2012 or x2011_2012....

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac1_images/colname.png') 
```

```{r cache=FALSE, message=FALSE}
library(tmap)
tmap_mode("plot")
# change the fill to your column name if different
shape %>%
  qtm(.,fill = "2011_12")
```

### Export data

Finally write shape to a new GeoPackage (`.gpkg`) giving it the layer name of your choice:

```{r cache=FALSE, message=FALSE}
shape %>%
  st_write(.,"C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/Rwk1.gpkg",
           "london_boroughs_fly_tipping",
           delete_layer=TRUE)
```

So here, we are saying the shape is the object we want to save, then to the GeoPackage file path, with the layer name of `london_boroughs_fly_tipping`. I've set `delete_layer` to true so I could overwrite mine when I developed this practical. Changing it to false would generate an error message if you ever tried to re-run the code.

Let's also add the `.csv` as we did in QGIS. This is a bit more complicated as we have to use the SQLite database package. Firstly, connect to the `.gpkg` we just made:

```{r cahce=TRUE}
library(readr)
library(RSQLite)

con <- dbConnect(RSQLite::SQLite(),dbname="C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/Rwk1.gpkg")
```

Now examine what is in the `.gpkg`...you can see that i've already got my `original_csv` stored within the `.gpkg` as when i developed this practical i made sure it was working!

```{r cache=FALSE}
con %>%
  dbListTables()
```

Add your `.csv` and disconnect from the `.gpkg`:

```{r cache=FALSE}
con %>%
  dbWriteTable(.,
               "original_csv",
               mycsv,
               overwrite=TRUE)

con %>% 
  dbDisconnect()
```

Here `overwrite` let's you well..overwrite the exisiting file...if this wasn't specified as true you would get an error saying the file already existed if you tried to run this code again.

#### Making a script

To convert this bit of analysis into a script that we could save and run again in future, I would write the following in the script quadrant:

```{r, eval=FALSE, cache=FALSE}
library(sf)
library(tmap) 
library(tmaptools)
library(RSQLite)
library(tidyverse)
#read in the shapefile

shape <- st_read(
  "C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp")
# read in the csv
mycsv <- read_csv("C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/fly_tipping_borough_edit.csv")  
# merge csv and shapefile
shape <- shape%>%
  merge(.,
        mycsv,
        by.x="GSS_CODE", 
        by.y="Row Labels")
# set tmap to plot
tmap_mode("plot")
# have a look at the map
qtm(shape, fill = "2011_12")
# write to a .gpkg
shape %>%
  st_write(.,"C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/Rwk1.gpkg",
           "london_boroughs_fly_tipping",
           delete_layer=TRUE)
# connect to the .gpkg
con <- dbConnect(SQLite(),dbname="C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/prac1_data/Rwk1.gpkg")
# list what is in it
con %>%
  dbListTables()
# add the original .csv
con %>%
  dbWriteTable(.,
               "original_csv",
               mycsv,
               overwrite=TRUE)
# disconnect from it
con %>% 
  dbDisconnect()
```

You can then save your script through File \> Save As.

If you are on a Mac you might also need to load `rgdal`...just add the following at the top of the script.

```{r, message=FALSE, warning=FALSE, eval=FALSE, cache=FALSE}
library(rgdal)
```

### What will I use

Well... it depends. If you wanted to quickly open a dataset to explore its contents then I'd use QGIS. However, if you had 100 raster images that you wanted to clip to your study area, I'd automate it in R. There are also specific packages developed for each type of software that might dictate what you use, for example I recently made use of the Urban Multi-scale Environmental Predictor (UMEP) plugin in QGIS. That said, as I needed to match different hourly meteorological variables over a three year period I automated the first part of the analysis in R and loaded a `.csv` into QGIS. Recent advancments have also closed the gap somewhat between Graphic User Interface (GUI) GIS software (such as QGIS) and programming languages (such as R) with 'bridges' that allow you to control GUI software through code. To learn more about these bridges read [Lovelace et al. (2019) chapter 9](https://geocompr.robinlovelace.net/gis.html#introduction-6).

## Data sources and task

Below I've listed a few good data sources. Explore these and any others you can find and get an interesting dataset (e.g. in this practical our flytipping `.csv`) that you could join to some spatial data (e.g. in this practical the London boroughs `.shp`). This could be for any location in the world.

### UK Data Service

The UK Data Service geography service (<https://census.edina.ac.uk/>) has a library of hundreds of current and former boundary datasets for which attribute data are produced in the UK.

### ONS

The Office for National Statistics (ONS) are the national statistical agency for England and Wales and have recently started to provide access to boundary data for the statistics they produce for various geographic areas.

Many of the boundaries on the [ONS Geoportal](http://geoportal.statistics.gov.uk/) are also available from the Edina Census Geography website in a more flexible fashion, however the ONS website provides very quick access to bulk-downloads --- something which can be very useful when reading data directly from the web using computer software. From the ONS website you can also extract the URL at which the data is stored to use directly within your future code...

### nomis

Nomis is provided by the ONS giving free access to UK labour market statistics. You can also [bulk download census data](https://www.nomisweb.co.uk/census/2011/bulk/r2_2) from the site too!

### OS

The Ordnance Survey (OS) are the national mapping agency for the UK. A few years ago, they opened up a number of their data products for public use including greenspace, OS Open Map and OS Terrain.

For the full range see: [https://www.ordnancesurvey.co.uk/business-and-government/products/finder.html?Licensed%20for=OpenData%20(Free)&withdrawn=on](https://www.ordnancesurvey.co.uk/business-and-government/products/finder.html?Licensed%20for=OpenData%20(Free)&withdrawn=on){.uri}

### Edina Digimap

Before the Ordnance Survey opened up much of its data for public use, academics and students in the UK could access OS data using the Edina Digimap Service ---- this service is still available today and provides access to a number of products in addition to those available from OS Open Data.

Perhaps the most exciting of the additional OS data products available from Digimap is OS MasterMap. MasterMap is a framework for all OS data and contains layers of data that include details of real world objects such as buildings, roads, paths, rivers, physical structures and land parcels, as well as the complete UK transport network. Whilst we still are required to go through Edina OS have recently announced plans to make this dataset free in the near future under the new Geospatial Commission.

```{r echo=FALSE, out.width = "500pt", fig.align='center'}
knitr::include_graphics('prac1_images/mastermap.png') 
```

### OSM

Open Street Map (OSM) is a fantastic resource ---- as the name suggests, all data contained in Open Street Map are open and free for anyone to use. Much like Wikipedia, anyone can contribute content to OSM and this brings with it its own benefits (frequent updates, very large user-base) and problems (data quality and patch coverage). OSM is a very good example of Volunteered Geographic Information (VGI).

It's possible to download OSM data straight from the website, although the interface can be a little unreliable (it works better for small areas). There are, however, a number of websites that allow OSM data to be downloaded more easily and are directly linked to from the 'Export' option in OSM. Geofabrik (<https://www.geofabrik.de/data/download.html>) allows you to download frequently updated Shapefiles for various global subdivisions.

### DEFRA

The Department for Environment and Rural Affairs (DEFRA) have recently created the Data Services Platform to openly distribute environmental data. See: <https://environment.data.gov.uk/>

### Data lists

Another good place to start searching for data are data lists. They simply provide a comprehensive overview of all available data conveniently categorised by discipline and country.

I normally use this one: <https://freegisdata.rtwilson.com/>

## Summary

Within this practical we have explored the different types, formats and software used to store, analyse and manipulate spatial data. In reflecting upon this practical you should consider the (dis)advantages of each, where and when they might be appropriate and the overall practicality. Next week we will delve further into R and RStudio.

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material.

## Mac R issues

If you have a Mac and run into issues using R, try this...

It seems that a lot of the packages are dependent on rgdal, which might not properly install...

**Order of operations**

1.  Install java JDK (to respond to error Unable to find any JVMs matching version "(null)", which occurred when we tried to load `OpenStreetMap` package in RStudio)

2.  Download and install the appropriate `.dmg` from [Java SE Development Kit 11.0.1](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)

3.  Run sudo R CMD javareconf in Terminal as described [in this tutorial](http://conjugateprior.org/2014/12/r-java8-osx/)(though don't follow this tutorial exactly, just up to that terminal command).

4.  (Maybe) restart your computer (not really sure when this is necessary).

**Install GDAL**

GDAL, the Geospatial Data Abstraction Library, appears to be a massively important package / library / whatever that a lot of the spatial tools we use depends on. This is where things might be sticky --- we already installed GDAL for QGIS, but obviously RStudio can't find that install ... dunno how to update the pointers, but we found that installing GDAL (again?) solved it. We HOPE that this didn't ruin or break any other software we've installed, only time will tell :grimacing:

1.  To install GDAL on a mac, first (if you haven't) install [homebrew](https://brew.sh/), the mac package manager

This can be done by executing `/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"` in Terminal, inputting password etc.

1.  Now we're ready to brew install gdal (also in Terminal), which will run through and install a massive list of dependencies etc.

**Set up RStudio**

1.  Restart RStudio (if the following doesn't work on first go...)

2.  Run through all the `install.packages()` commands one by one in RStudio and check to make sure that they install.

3.  Check if `rgdal` package is working.

4.  Check the other packages `OpenStreetMap`, `tmap`, etc.

<!--chapter:end:01-prac1.Rmd-->

# Introduction to R

## Learning outcomes

By the end of this practical you should be able to:

1. Execute basic processing in R
1. Examine, clean and manipulate comma seperate value (```.csv```) data
1. Examine, clean and manipulate and plot spatial (```.shp```) data 
1. Produce interactive maps
1. Evaluate the benefits of different data manipulation and mapping techniques

## Homework

Outside of our schedulded sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

The task is to join some non spatial data to some spatial data and wrangle it.

You need calcuate the average percent of science students (in all) grades per county meeting the required standards and produce a map to show where the Country averages are above or below the State of Washington average.

* [Download Washing Counties](https://hub.arcgis.com/datasets/kingcounty::washington-counties-with-natural-shoreline-washsh-area/explore?location=47.272700%2C-120.740400%2C7.67)

* [Download school report card data](https://data.wa.gov/Education/Report-Card-Assessment-Data-2018-19-School-Year/5y3z-mgxd)

**Tip** do not try and pull out the number from the % symbol, you have the count of students who expected to test and the count who met standard, so you can calculate the percentage. 

:::

::: {.infobox .note data-latex="{note}"}

**Reading**

This week: 

* [Chapter 2 "Geographic data in R"](https://geocompr.robinlovelace.net/spatial-class.html) from Geocomputation with R by Lovelace, Nowosad and Muenchow (2020).

* [How to Write a Paper for Publication](https://onlinelibrary.wiley.com/doi/epdf/10.1046/j.1444-2892.2000.00031.x) by Rosenfeldt et al. (2000).

**Watching**

* [The series of short (2min) videos produced by RStudio on programming basics](https://rstudio.cloud/learn/primers/1.2)

* [Hadley Wickham's Keynote from the European Molecular Biology Laboratory (EMBL)](https://www.youtube.com/watch?v=9YTNYT1maa4). This will be the same for a few weeks.

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/7jGNAMzrW5HMXdxl9XyBMG). Dermot Kennedy, might give you the chills with his pure voice. I saw him live last year at All Points East in London. Orginally was well known from the Spotify Discover Weekly where he used to self publish songs. 

[Adam](https://open.spotify.com/album/5yAXUpsKaby5IcXgzrNFAw). Change of genre this week, but this will still melt your brains! I first saw this band in Cambridge in about 2004 when we were both still young! 16 years later, they're now a massive platinum-selling Rock juggernaut with their latest singles bothering the playlists of the world's most popular radio stations and their live-shows conquering the biggest festivals. Mon the Biff. It is of course Biffy Clyro! Here's their latest album - A Celebration of Endings -

## Introduction 

This practical is **LONG** but it will take you from not knowing much about R to making freaking cool interactive maps in one practical. As you can imagine, this will be a steep learning curve.

I will give you all the code you need, it’s your job to read through the text very carefully and try to understand what bits of code are doing as you go.

There will be bits of code you don’t fully understand. Don’t worry, the key is to revisit later and try to work out what is going on then. Learning R is a long and iterative process and this is just the start…

If you want to learn more about R and indeed download the latest version for your own use, then visit the [R project pages](http://www.r-project.org/)

The Wikipedia page for those who want to know a little of the history of R can be found [here](http://en.wikipedia.org/wiki/R_(programming_language))

There is an almost endless supply of good R tutorials on the web. If you get stuck or want to learn even more R (and why would you not want to?!), I’d recommend trying some of the following R Tutorial websites:

* http://www.statmethods.net/index.html

* http://www.r-tutor.com/

* http://www.cyclismo.org/tutorial/R/index.html

* http://www.cookbook-r.com/

If you want to really be up to date with the state of the art in R, then [bookdown](https://bookdown.org/) is a fantastic resource. It features **free** books by some of the pre-eminent names in the R scene --- I would urge you to go and take a look.

### Online forums are your friend!!

With almost every problem you encounter with R, someone else will have had the same problem before you and posted it on a forum --– someone will then post a solution below.

My usual route is to Google the problem and I’ll then be directed to a post, usually on Stack Overflow, Stack Exchange or Cross Validated. When doing so try to think about the minimal working (or not working) example (MWE), by this i mean remove anything very specific to your problem. I’ve rarely not found a solution to a problem this way. 

### Health warning

Beware of posting questions on these forums yourself – contributors to these forums (especially the R ones!), whilst almost always extremely knowledgeable about R, have a bit of a reputation for being insert familiar pejorative term for less-than-polite-human-being here! As you might expect, people who have enough time to become total experts in R, have little time to work on their social skills!! Fortunately though, some other poor chump has usually taken that hit for you and you can still find a useful answer to your problem.

If you are specifically more interested in the spatial side of R, then Alex Singleton and Chris Brunsdon at the Universities of Liverpool and Maynooth also have a number of very useful R Spatial Tutorials – http://rpubs.com/alexsingleton/ & http://rpubs.com/chrisbrunsdon/

Robin Lovelace in Leeds is also frequently at the bleeding edge of developments in R spatial stuff, so keep an eye on his [website](http://robinlovelace.net/). Robin has also made a book on GeoComputation in R, which you should definitely read! --- https://geocompr.robinlovelace.net/

These websites are also very very good: https://pakillo.github.io/R-GIS-tutorial/ and http://www.maths.lancs.ac.uk/~rowlings/Teaching/UseR2012/cheatsheet.html

### R and RStudio

When you download and install R, you get the R Graphical User Interface (GUI) as standard (below). This is fine and some purists prefer using the clean, unfussy command-line original, but it has some limitations such as no graphical way to view data tables or keep track of what is in your working directory (there are a number of others too).

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/R.png') 
```

Fortunately there are a number of software environments that have been developed for R to make it a little more user-friendly; the best of these by a long way is RStudio. RStudio can be downloaded for free from https://www.rstudio.com/. We covered the RStudio layout last week.

### Getting started

If you are some kind of masochist, you are welcome to use the bundled R GUI for all of your work. If pain is not your thing, then for this practical (and future practicals) I will assume that you are using RStudio.

1. From the start menu on your computer, find and run RStudio

Once RStudio has opened, the first thing we will do is create a new project – projects enable you to organise your work effectively and store all of the files you create and work with for a particular task. 

1. To create a new project (and this will vary a little depending on the version of RStudio you are using) select File > New Project

1. Select Start a project in a brand new working directory and create a new project in a directory of a new ‘wk2’ directory on your N: drive:

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/r_newproject.png') 
```

My file directory (the second box here) will be different to yours as this is my teaching resources folder. Keep yours simple ```N:/GIS/wk2```.

Setting up a project is extremely useful as it lets you easily access your data and files...for example....the flytipping ```.csv``` we used last week is stored at the file path

```{r eval=FALSE, cache=FALSE}
mycsv <- read_csv("C:/Users/Andy/OneDrive - University College London/Teaching/CASA0005/2020_2021/CASA0005repo/Prac1_data/fly_tipping_borough_edit.csv"")  
```

However as i've set my R project up in the CASA0005repo folder with different data folders for each week i can just use:

```{r eval=FALSE, cache=FALSE}
mycsv <- read_csv("Prac1_data/fly_tipping_borough_edit.csv")  
```

If i had the ```.csv``` file in the same folder as my project i could just use

```{r eval=FALSE, cache=FALSE}
mycsv <- read_csv("fly_tipping_borough_edit.csv")  
```

You can run this in the Console area now or within a script which we will now go over...

I'd strongly recommend you think about how you will store data within your project. Is it sensible to just dump all your data into the project folder or perahps create a new folder (either in R) or how you would normally do so in Windows / OS X and keep your raw data in that folder...like i have done...Here you can see that i'm in my project folder (red box on the right) and i've made new folders for all my data (each practical here) and images that are shown throuhgout....nice and organised!

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/file_storage.png') 
```

### Basics 

1. R has a very steep learning curve, but hopefully it won’t take long to get your head around the basics. For example, at its most simple R can be used as a calculator. In the console window (bottom left), just type the following and press enter:

```{r cache=FALSE}
1+5
```

or 

```{r cache=FALSE}
4*5^2
```

As you can see R performs these calculations instantly and prints the results in the console. This is useful for quick calculations but less useful for writing scripts requiring multiple operations or saving these for future use.

1. To save your scripts, you should create a new R Script file. Do this now: Select File > New File > R Script.

1. The R Script should open up on the top-left of your GUI. **From now on type everything in this R script file and save it**

### Scripts and some basic commands

1. Usually one of the first things to do when starting a new R Script is to check that you are in the correct working directory. This is important especially if you are working on multiple projects in different locations. To do this type the following into your new empty R Script:

```{r cache=FALSE, echo=FALSE, results=FALSE}
getwd()
```

1. To run this line, hold Ctrl (Cmd on a Mac) and press the Return(↲) key (if you are in the standard R installation, you would run your script with Ctrl R). You should now see your current working directory appear in the console.

1. Because of the new project we have already set up, this working directory should be correct, but if for any reason we wanted to change the working directory, we would use the ```setwd()``` function. For example, we wanted to change our directory to the documents folder on the C drive, we could run (don’t do this now):

```{r eval=FALSE, cache=FALSE}
setwd("C:/Documents")
```

1. When we are sure we are working in the correct working directory, we can save our script by clicking on the save icon on the script tab. Save your script as something like “wk2_part1” and you will see it appear in your files window on the right hand side. As you build up a document of R code, you should get into the habit of saving your script periodically in case of an unexpected software crash.

8. We can now begin to write a script without the need to run each line every time we press enter. In the script editor type:

```{r cache=FALSE}
A <- 1
B <- 2
C <- A+B
C
```

1. Select (highlight) the three lines and run all three lines with Ctrl Return(↲). You will notice the lines appear in the console (the other window). If you type C and press enter in the console (C and then ctrl return in the script window) you should have the number 3 appear. From now on I recommend you type all the commands below in the script first and then run them. Copying and pasting from this document won’t necessarily work.

1. You will also notice that in RStudio, values A, B and C will appear in your workspace window (top right). These variables are stored in memory for future use. Try giving A and B different values and see what happens. What about if you use lower case letters?

1. You have just demonstrated one of the powerful aspects of R, which is that it is an **object oriented** programming language. A, B and C are all objects that have been assigned a value with the <- symbol (you can also use the = sign, but it operates slightly differently to <- in R, plus the arrow assignment has become standard over the years. Use **alt -** to type it automatically). This principle underlies the whole language and enables users to create ever more complex objects as they progress through their analysis. If you type:

```{r}
ls()
```
R will produce a list of objects that are currently active.

```{r cache=FALSE}
rm(A)
```

will remove the object A from the workspace (do ```ls()``` again to check this or look in your workspace window).

### Functions

1. Both ```rm()``` and ```ls()``` are known as functions. Functions are the other fundamental aspect to the R language. Functions can be thought of as single or multiple calculations that you apply to objects. They generally take the form of...(don't run these)

```{r, eval=FALSE, cache=FALSE}
function(object, argument1, argument2, argument3)
```

Where the object is some form of data and the arguments parameterise what the function will do.

You could save the ouput to a new object using something like...

```{r, eval=FALSE, cache=FALSE}
X<-function(data, argument1, argument2, argument3)
```

1. You can write your own functions to carry out tasks (and we’ll come onto that in subsequent practical sessions), but normally you will just used one of the virtually infinite number of functions that other people have already written for us.

### Basic plotting

One common function is the ```plot()``` function for displaying data as a graphical output. Add these lines to your script and run them as before and you can see some ```plot()``` outputs:

```{r, cache=FALSE}
#create some datasets, first a vector of 1-100 and 101-200
Data1 <- c(1:100)
Data2 <- c(101:200)
#Plot the data
plot(Data1, Data2, col="red")
```

```{r, cache=FALSE}
#just for fun, create some more, this time some normally distributed
#vectors of 100 numbers
Data3 <- rnorm(100, mean = 53, sd=34)
Data4 <- rnorm(100, mean = 64, sd=14)
#plot
plot(Data3, Data4, col="blue")
```

1. In the code above, you will have noticed the ```#``` symbol. This signifies that whatever comes after it on that line is a comment. Comments are ignored by the R console and they allow you to annotate your code so that you know what it is doing. It is good programming practice to comment your code extensively so that you can keep track of what your scripts are for. 

**Warning** Heed our advice now and comment your code it will save you time in the future!

### Help

1. The previous lines of code also demonstrated a number of functions: ```c()``` concatenates a string of numbers together into a vector. 1:100 means produce the integers between and including 1:100, the ```plot()``` function plots the two data objects and includes a parameter to change the colour of the points. To understand what a function does, you can consult the R Help system. Simply type a question mark and then the function name; for example:

```{r eval=FALSE, cache=FALSE}
?plot
```

```{r echo=FALSE, out.width = "300px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/rhelp.png') 
```

1. In RStudio you will see the help file appear in the Help window in the bottom right of the GUI. Here you can also search for the help files for other functions in the search bar.

### Data structures

1. Objects in R can exist as a number of different data structures. These include a **matrix**, an **array**, a **vector**, a **data frame** and a **list**. 

The main criteria for division of these structures is data type homogeneity.

A vector, matrix and array must only contain data of the **same type** (e.g. numeric or text)

A list or data frame can contain a mixture of data types (e.g. numeric and text). 

Further divisions are then made based on the number of dimensions (1D, 2D, 3D or more) each can have...

An applied example....

```{r echo=FALSE, out.width = "450px", fig.align='center', cache=FALSE, fig.cap="R's most common data structures are vectors, matrices, arrays, lists and data frames. Source: [ Figure 3.6, NUS BACT](https://nusbasdata.wordpress.com/2018/01/06/r-tutorial-4-data-structures/)"}
knitr::include_graphics('prac2_images/data_structures.png') 
```

An applied example....

```{r echo=FALSE, out.width = "450px", fig.align='center', cache=FALSE, fig.cap="Data Object Type and Structure. Source: [ Exploratory Data Analysis in R, Gimond 2022](https://mgimond.github.io/ES218/Week02a.html#Data_structures)"}
knitr::include_graphics('prac2_images/data_structures2.png') 
```

To determine what structure you have ask the following questions

1. Is it a single type of data (e.g. character, numeric, date)
1. Is it a single row (e.g. vector)
1. Is there an extra dimension (e.g. matrix or array)
1. Are there many different types combined (e.g list)

For the purposes of this practical we will focus on data frames. These are the most flexible data format in R (although tibbles are now becoming popular as well --- they are just more flexible versions of data frames, see below). Data frames can be conceptualised in a similar way to a spreadsheet with data held in rows and columns. They are the most commonly used object type in R and the most straightforward to create from the two vector objects we just created.

```{r, cache=FALSE}
df <- data.frame(Data1, Data2)
plot(df, col="green")
```

Tibble vs data frame....

```{r echo=FALSE, out.width = "450px", fig.align='center', cache=FALSE, fig.cap="Tibble vs dataframe. Source: [  Business Science in R bloggers, 2021](https://www.r-bloggers.com/2021/02/4-ways-to-make-data-frames-in-r/)"}
knitr::include_graphics('prac2_images/tibble.png') 
```

1. If you have a very large data frame (thousands or millions of rows) it is useful to see only a selection of these. There are several ways of doing this:

```{r, cache=FALSE, message=FALSE, results=FALSE}
library(tidyverse)
#show the first 10 and then last 10 rows of data in df...
df %>%
  head()
```

```{r, cache=FALSE, message=FALSE, results=FALSE}
df %>%
  tail()
```

::: {.infobox .warning data-latex="{note}"}
You might have noticed the syntax (code) `%>%`, this is called a **pipe** and is an operator is part from the `magrittr` package. `magrittr` is an entirely new way of thinking about R syntax that cleraly expresses a sequence of multiple operations. It is useful to think of the pipe operator as simply meaning “then”. Do this **THEN** do this **THEN** do that.

In R version 4.1 there is a new pipe `|>`. It is exactly at the same as `%>%` but means there is no reliance on the `magrittr` package. The good news is they can *mostly* be used interchangeably.

:::

```{r echo=FALSE, out.width = "450px", fig.align='center', cache=FALSE, fig.cap="How to use pipes to clean up your R code. Source: [  R for Ecology, 2022](https://www.rforecology.com/post/how-to-use-pipes/)"}
knitr::include_graphics('prac2_images/pipes.png') 
```

You can also view elements of your data frame in RStudio by simply clicking on it in the top-right Environment window:

```{r echo=FALSE, out.width = "800px", fig.align='center', cache=FALSE}
knitr::include_graphics('prac2_images/dataview.png') 
```

### Elements of a data frame

1. When programming you will frequently want to refer to different elements in a data frame or a vector/list. To select elements of a data frame, or subset it, you can refer specifically to ranges or elements of rows and columns. These are accessed using the single square bracket operator [], with the form:

```{r eval=FALSE, cache=FALSE, message=FALSE, results=FALSE}
data.frame[row,column]
```

Rows are always referenced first, before the comma, columns second, after the comma.

1. Try the subsetting your df data frame with the following commands to see what is returned:

```{r cache=FALSE, message=FALSE, results=FALSE}
df[1:10, 1]
df[5:15,]
df[c(2,3,6),2]
df[,1]
```

1. You will note that the column headings are the names of the original objects creating the data frame. We can change these using the ```rename()``` function from  `dplyr`  that is loaded as part of the `tidyverse` package, we will come to this next:

```{r}
library(dplyr)
df <- df %>%
  dplyr::rename(column1 = Data1, column2=Data2)
```

`dplyr` is a grammar of data manipulation, it has multiple **verbs** that allow you to change your data into a suitable format. These include `select()`, `filter()`, `summarise()`, which can also be applied to groups in datasets using `group_by()`. `dplyr` will be used throughout this course.

In the majority of cases you provide some kind of data to `dplyr` followed by a `%>%` then a verb (or other function), then another `%>%` and more verbs of functions if needed. As in the code above you can also assign the output to an object with `<-`.


```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="dplyr introduction graphic. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_wrangling.png')
```

To select or refer to  columns directly by name, we can either use `dplyr` again! 

```{r, cache=FALSE, message=FALSE, results=FALSE}
df %>% 
  dplyr::select(column1)
```

However, you should be aware of other methods for doing this, as not all spatial data is compatible with `dplyr` yet, such as raster data, which will be important for next week. So we can also use the ```$``` operator, which takes the form  ```data.frame$columnName```, e.g.

```{r, cache=FALSE, message=FALSE, results=FALSE}
df$column1
```

or we can use the double square bracket operator [[]], and refer to our column by name using quotes e.g.

```{r, cache=FALSE, message=FALSE, results=FALSE}
df[["column1"]]
```

This again is useful if you have a lot of columns and you wish to efficiently extract one of them.

## Reading data into R

One of the most tedious things a spatial analyst / data scientist has to do is clean their data so it doesn’t cause problems for the software later. In the past, we would have needed to do this by hand --- these days, we can use software to do much of this for us.

I will now give you two options to arrive at a nice cleaned dataset. For this example we are going to use the London Datastore Catalogue.

Go to the London Data store and [get the Ward Profiles and Atlas ](https://data.london.gov.uk/dataset/f33fb38c-cb37-48e3-8298-84c0d3cc5a6c) and download the excel document for ward profiles.

### Old skool cleaning

1. Open the ```ward-profiles-excel-version.xls``` file in Excel, and save as ```LondonData.csv``` into your RProject folder, week 2.

1. Open your new ```.csv``` file in Excel. There might be some non-numeric values inside numeric columns which will cause problems in your analysis. These need to be removed before proceeding any further. To remove these, you can use the replace function in Excel. In the home tab under ‘Editing’ open up the find and replace dialogue box and enter the following into the find box:

```#VALUE!``` ```n/a```

Leave the replace box empty each time and click Replace All to remove these from your file, before saving the file again.

1. Once you have cleaned out all of the trixy characters from the file, to read it into R, we will use the ```read.csv()``` function:

```{r, cache=FALSE}
LondonDataOSK<- read.csv("prac2_data/ward-profiles-excel-version.csv", 
                         header = TRUE, 
                         sep = ",",  
                         encoding = "latin1")
```

> **Note**, I've made an R project for all these practicals, which is why my file path starts with ```prac2_data/```. If you save the ```.csv``` in the same folder as the ```.Rproj``` then you can just use:

```{r eval=FALSE, cache=FALSE}
LondonDataOSK<- read.csv("ward-profiles-excel-version.csv", 
                         sep=",")
```

If you look at the ```read.csv()``` help file - ```?read.csv``` - you will see that we can actually include many more parameters when reading in a `.csv` file. For example, we could read in the same file as follows:

```{r, cache=FALSE}
# by default in R, the file path should be defined with / 
#but on a windows file system it is defined with \. 
#Using \\ instead allows R 
#to read the path correctly – alternatively, just use /
LondonDataOSK<- read.csv("prac2_data/ward-profiles-excel-version.csv", 
                         header = TRUE, sep = ",", encoding = "latin1")
```

This would specify that the first row of the file contains header information; and the values in the file are separated with commas (not ; or : as can be the case sometimes).

### Here

However, this is also another more straightforward way to read in files that was devloped in 2017 to make it more intuitive to find and load files using the `here` package. You need to install and load it:

```{r, cache=FALSE, eval=FALSE}
install.packages("here")
```

```{r, cache=FALSE, results=FALSE, message=FALSE}
library(here)
```

Think of `here()` as a command that is just pointing to a file path, to find out where is pointing use...

```{r, cache=FALSE, results=FALSE}
here::here()
```

This is my working directory for this book project! Now i can use this to load my data that is in my practical 2 folder just like this....

```{r, cache=FALSE}
LondonDataOSK<- read.csv(here::here("prac2_data","ward-profiles-excel-version.csv"), 
                         header = TRUE, sep = ",",  
                         encoding = "latin1")
```

This just removes any need for ever using a `/` or `\\` in your file path. As with everything in code, there is no right way, use what suits you.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="here::here() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/here.png')
```

### New skool cleaning 

To clean our data as we read it in, we are going to use a package called ```readr``` which also comes bundled as part of the ```tidyverse``` package.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="tidyverse introduction graphic. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/tidyverse_celestial.png')
```

The [`tidyverse`](https://www.tidyverse.org/) is simply a collection of pacakges relevant for data science, containing almost everything you need to become a kick-ass data scientist.

Now let's  use the ```readr``` package... that allows loads of data manipulation ...for example...

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="readr::parse_number() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/parse_number.png')
```

Here we will use it to just read in a `.csv` file (directly from the web this time --- ```read.csv``` can do this too) and clean text characters out from the numeric columns before they cause problems:

```{r, message=FALSE, cache=FALSE}
#wang the data in straight from the web using read_csv, 
#skipping over the 'n/a' entries as you go...
LondonData <- read_csv("https://data.london.gov.uk/download/ward-profiles-and-atlas/772d2d64-e8c6-46cb-86f9-e52b4c7851bc/ward-profiles-excel-version.csv",
                       locale = locale(encoding = "latin1"),
                       na = "n/a")
```


> **Note** the use of read_csv here as opposed to read.csv. They are very similar, but read_csv is just a bit better. Read [this blog post](http://yetanothermathprogrammingconsultant.blogspot.com/2016/12/reading-csv-files-in-r-readcsv-vs.html) for more information. Also, for those python fans out there ---IT’S NOT THE SAME FUNCTION AS READ_CSV IN PYTHON

What is `locale = locale(encoding = "latin1")`?...good question...it is basically the encoding of the data (how it is stored). There are a few different formats such as UTF-8 and latin1. In latin1 each character is 1 byte long, in UTF-8 a character can consist of more than 1 byte. To my knowledge the default in R is encoded as latin1, but `readr` (the package we are using to read in the `.csv` is UTF-8 so we have to specify it.

### Examining your new data

1. Your new data has been read in as a data frame / tibble (remember a tibble is just a data frame with a few extra bells and whistles). If you ever need to check what data type your new data set is, we can use the ```class()``` function:

```{r cache=FALSE}
class(LondonData)
```

```{r, eval=FALSE, cache=FALSE}
# or, if you have your old skool data
class(LondonDataOSK)
```

We can also use the `class()` function (from base R) within another two functions `summarise_all()` (from `dplyr`) and `pivot_longer()` (from `tidyr`) to check that our data has been read in correctly and that, for example, numeric data haven’t been read in as text or other variables. Run the following line of code:

```{r, cache=FALSE}
Datatypelist <- LondonData %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist
```

We cover `pivot_longer()` later in this practical, but for now we've simply grouped all our variables into one **LONG** column adding another column that contains the class.  

You should see that all columns that should be numbers are read in as numeric. Try reading in LondonData again, but this time without excluding the ‘n/a’ values in the file, e.g.

```{r, message=FALSE, cache=FALSE}
LondonData <- read_csv("https://data.london.gov.uk/download/ward-profiles-and-atlas/772d2d64-e8c6-46cb-86f9-e52b4c7851bc/ward-profiles-excel-version.csv", 
                       locale = locale(encoding = "latin1"))
```

Now run the Datatypelist code again --- you should see that some of the columns (those the n/a values in) have been read in as something other than numeric. This is why we need to exclude them. Isn’t ```readr``` great for helping us avoid reading in our numeric data as text!

If you ever wish to quickly edit data, then use `edit()`

```{r, eval=FALSE, cache=FALSE}
LondonData <- edit(LondonData)
```

1. It is also possible to quickly and easily summarise the data or look at the column headers using

```{r cache=FALSE}
summary(df)
```

```{r, message=FALSE, cache=FALSE}
LondonData%>%
  colnames()%>%
  # just look at the head, top5
  head()
```

### Data manipulation in R

Now we have some data read into R, we need to select a small subset to work on. The first thing we will do is select just the London Boroughs to work with. If you recall, the Borough data is at the bottom of the file.

#### Selecting rows

1. Your borough data will probably be found between rows 626 and 658. Therefore we will first create a subset by selecting these rows into a new data frame and then reducing that data frame to just four columns. There are a few ways of doing this:

We could select just the rows we need by explicitly specifying the range of rows we need:

```{r cache=FALSE}
LondonBoroughs<-LondonData[626:658,]
```

We can also do this with `dplyr`... with the `slice()` function, taking a "slice" out of the dataset...

```{r cache=FALSE}
LondonBoroughs<-LondonData%>%
  slice(626:658)
```

However, we can instead try a cool ‘data sciency’ way of pulling out the rows we want with the knowledge that the codes for London Boroughs start with E09 (the wards in the rest of the file start with E05).

`dplyr` has a cool function called `filter()`that let's you subset rows based on conditions...

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="dplyr::filter() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_filter.jpg')
```
Here, we could filter based on a variable, for example extracting all the wards where female life expectancy is greater than 90. 

```{r, message=FALSE, warning = FALSE, cache=FALSE}
Femalelifeexp<- LondonData %>% 
  filter(`Female life expectancy -2009-13`>90)
```

However, our `New code` column that holds Borough codes can't be filtered like this as it's in a character format...in cases like this we can use the function `str_detect()` from the `stringr` package in combination with `filter()` from `dplyr`. Both these packages are part of the `tidyverse` again!

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="dplyr::filter() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/str_detect.png')
```


```{r, message=FALSE, warning = FALSE, cache=FALSE}
LondonBoroughs<- LondonData %>% 
  filter(str_detect(`New code`, "^E09"))
```

Check it worked:

```{r,eval=FALSE, cache=FALSE}
LondonBoroughs$`Ward name`
```

That's also the same as:

```{r,eval=FALSE, cache=FALSE}
LondonBoroughs %>% 
  dplyr::select(`Ward name`) %>%
  print()
```

`r emo::ji("sunglasses")`**AWWMAHGAWD!!!** `r emo::ji("sunglasses")`Pretty cool hey?

What that code is saying is `stringr` look for (detect!) the rows that have the ward code like E09, then filter these and store in the object `LondonBoroughs`

The `stringr` package is really great and if you ever need to manipulate text type data then it's the place to start.

You will notice that you will have two rows at the top for the City of London. This is because it features twice in the data set. That’s fine, extract only unique rows with `distinct()`, again from `dplyr`:

```{r, cache=FALSE}
LondonBoroughs<-LondonBoroughs %>%
  distinct()
```

#### Selecting columns

We can select columns if we know which index we want, starting from the first column that's 1..

```{r, cache=FALSE}
#select columns 1,19,20 and 21
LondonBoroughs_manualcols<-LondonBoroughs[,c(1,19,20,21)]
```

We can also replicate this with `dplyr` with `select()`

```{r, cache=FALSE, eval=FALSE}
#select columns 1,19,20 and 21
LondonBoroughs_dplyrcols<-LondonBoroughs %>%
  dplyr::select(c(1,19,20,21))
```

1. You will have noticed the use of square brackets above –-- these are very useful in R. The ```c()``` function is also used here --- this is the ‘combine’ function --- another very useful function in R which allows arguments (in this case, column reference numbers) into a single value.

1. However, we could also again use a more 'data sciency way'...selecting the columns that contain certain words ...

```{r, message=FALSE, warning = FALSE, cache=FALSE}
LondonBoroughs_contains<-LondonBoroughs %>% 
  dplyr::select(contains("expectancy"), 
         contains("obese - 2011/12 to 2013/14"),
         contains("Ward name")) 
```

#### Renaming columns

1. You will notice that the column names are slightly misleading as we are now working with boroughs rather than wards. You probably will also be annoyed (like me!) that the column names are full of `...` (they used to be) or - and spaces, that just make everything hard to read. So, let's rename the wards column to boroughs (using `rename()` like we did earlier), then using the `Janitor` package tidy everything up...

```{r, message=FALSE, cache=FALSE}
library(janitor)

LondonBoroughs <- LondonBoroughs %>%
  dplyr::rename(Borough=`Ward name`)%>%
  clean_names()
```

By defualt `Janitor` removes all capitals and uses an underscore wherever there is a space, this would be the same as using setting the `case` argument to snake... 

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="janitor::clean_names() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/janitor_clean_names.png')
```

If you wanted to now change it every word having a capital letter you would run...but don't do this now.

```{r, message=FALSE, cache=FALSE, eval=FALSE}
LondonBoroughs <- LondonBoroughs %>%
  #here the ., means all data
  clean_names(., case="big_camel")
```

#### More `dplyr` verbs

What about determining both:

* (a) the average of male and female life expectancy together
* (b) a normalised value for each London borough based on the London average. 

Then selecting only the name of the Borough, mean life expectancy and normalised life expectancy, arranging the output based on the normalised life expectancy in descending order...

To do this we will rely on the `mutate()` function that let's us add new variables based on existing ones...

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="dyplr mutate() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_mutate.png')
```

```{r, message=FALSE, warning = FALSE, cache=FALSE}
Life_expectancy <- LondonBoroughs %>% 
  #new column with average of male and female life expectancy
  mutate(averagelifeexpectancy= (female_life_expectancy_2009_13 +
                                    male_life_expectancy_2009_13)/2)%>%
  #new column with normalised life expectancy
  mutate(normalisedlifeepectancy= averagelifeexpectancy /
           mean(averagelifeexpectancy))%>%
  #select only columns we want
  dplyr::select(new_code,
         borough,
         averagelifeexpectancy, 
         normalisedlifeepectancy)%>%
  #arrange in descending order
  #ascending is the default and would be
  #arrange(normalisedlifeepectancy)
  arrange(desc(normalisedlifeepectancy))
```

We can also use `dplyr` to show us the top and bottom number of rows instead of using `head` or `tail` like we did earlier.

```{r, message=FALSE, warning = FALSE, cache=FALSE}
#top of data
slice_head(Life_expectancy, n=5)

#bottom of data
slice_tail(Life_expectancy,n=5)
```

#### Levelling up with`dplyr`

So far, we've really just covered basic operations with `dplyr` that you might have previously done in Excel. However, `dplyr` has much more powerful functions that can make advanced data wrangling a breeze. Whilst we've looked at life expectancy in the London boroughs relative to each other, how does the life expectancy of the London Boroughs compare the the UK average of 81.16?

To answer this question we can use the `case_when()`, whereby if the value is greater than 81.16 we can assign the Borough a string of "above UK average", and if below a string of "below UK average"....

```{r echo=FALSE, out.width = "500pt", fig.align='center', cache=FALSE, fig.cap="dplyr case_when() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_case_when.png')
```

```{r}
Life_expectancy2 <- Life_expectancy %>%
  mutate(UKcompare = case_when(averagelifeexpectancy>81.16 ~ "above UK average",
                               TRUE ~ "below UK average"))
Life_expectancy2
```

Now whilst this is useful, it doesn't tell is much more about the data itself, what if we wanted to know the range of life expectancies for London Boroughs that are above the national average....

```{r}
Life_expectancy2_group <- Life_expectancy2 %>%
  mutate(UKdiff = averagelifeexpectancy-81.16) %>%
  group_by(UKcompare)%>%
  summarise(range=max(UKdiff)-min(UKdiff), count=n(), Average=mean(UKdiff))

Life_expectancy2_group
```

This is useful, but now what if we wanted to have more information based on the distribution of the Boroughs compared to the national average, as opposed to just over or under....there are a few ways to do this..

We are going to:

1. Again work out difference between the life expectancy of the Boroughs compared to the national average
1. Round the whole table based on if the column is numeric (this isn't required and we're not adding a new column). Here we are using `across` that applies some kind of transformation across the columns selected (or that are numeric in this case).

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="dyplr::across() example. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dplyr_across.png')
```
Here we need to:

1. Round the column `UKdiff` to 0 decimal places (not adding a new column)
1. Use `case_when()` to find Boroughs that have an average age of equal to or over 81 and create a new column that contains text based combining `equal or above UK average by` then the years created in UKdiff. We do this through the `str_c()` function from the `stringr` package that let's us join two or more vector elements into a single character vector. Here `sep` determines how these two vectors are separated.
1. Then group by the `UKcompare` column
1. Finally, count the number in each group.

```{r}
Life_expectancy3 <- Life_expectancy %>%
  mutate(UKdiff = averagelifeexpectancy-81.16)%>%
  mutate(across(where(is.numeric), round, 3))%>%
  mutate(across(UKdiff, round, 0))%>%
  mutate(UKcompare = case_when(averagelifeexpectancy >= 81 ~ 
                                 str_c("equal or above UK average by",
                                       UKdiff, 
                                       "years", 
                                       sep=" "), 
                               TRUE ~ str_c("below UK average by",
                                            UKdiff,
                                            "years",
                                            sep=" ")))%>%
  group_by(UKcompare)%>%
  summarise(count=n())

Life_expectancy3
```

There is a lot of information here that we could use and make into a plot or map. For example, the Borough count of life expectancy difference could be visualised in a histogram (covered next week). Or, we could map the difference between the average life expectancy of each London Borough compared to the UK average..to do this would can just reuse some of the code from the example above....

```{r}
Life_expectancy4 <- Life_expectancy %>%
  mutate(UKdiff = averagelifeexpectancy-81.16)%>%
  mutate(across(is.numeric, round, 3))%>%
  mutate(across(UKdiff, round, 0))
```

Before you move on consider what you have learnt about `dplyr` in relation to this concept map. The teaching team will also explain it...

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE, fig.cap="dplyr concept map. Source: [Monica Alonso and Greg Wilson](https://github.com/rstudio/concept-maps)"}
knitr::include_graphics('prac2_images/dplyr.svg')
```

### Plotting

For a simple and quick plot, we can use the `plot()` function...

```{r, cache=FALSE}
plot(LondonBoroughs$male_life_expectancy_2009_13,
     LondonBoroughs$percent_children_in_reception_year_who_are_obese_2011_12_to_2013_14)
```

### Pimp my graph!

Now, of course, because this is R, we can pimp this graph using something a bit more fancy than the base graphics functions. Here we will use `plotly` an open source interactive graphing library...

```{r, eval=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
install.packages("plotly")
```

```{r message=FALSE, warning=FALSE}
library(plotly)
plot_ly(LondonBoroughs, 
        #data for x axis
        x = ~male_life_expectancy_2009_13, 
        #data for y axis
        y = ~percent_children_in_reception_year_who_are_obese_2011_12_to_2013_14, 
        #attribute to display when hovering 
        text = ~borough, 
        type = "scatter", 
        mode = "markers")
```

### Spatial Data in R

This next part of the practical applies the same principles introduced above to the much more complex problem of handling spatial data within R. 

In the remainder of this practical we will produce a map, the focus here is getting to grips with some of R's visulisation tools and not sound analysis (I know one is useless without the other!). Good quality spatial analysis will come in the rest of the module.

Whilst the instructions are step by step you are encouraged to start deviating from them (trying different colours for example) to get a better understanding of what we are doing.

1. The first package we need to install for this part of the practical is ```maptools``` –-- either find and install it using the RStudio GUI or do the following:

```{r, eval=FALSE, cache=FALSE}
install.packages("maptools")
```

There are a few other packages we’ll need to get to grips with. Some, like ```ggplot2``` (one of the most influential R packages ever) are part of the ```tidyverse``` package we came across earlier. Others we will need to install for the first time.

```{r, eval=FALSE, cache=FALSE}
install.packages(c("classInt", "tmap"))

# might also need these ones
install.packages(c("RColorBrewer", "sp", "rgeos", 
                   "tmaptools", "sf", "downloader", "rgdal", 
                   "geojsonio"))
```

1. Now that the packages have been installed you will not have to repeat the above steps again (when you use your account in these cluster rooms). Open a new script and save it to your working directory as ```wk2_maps.r```. As before, type each of the lines of code into this window and then select and use the ctrl return keys to run them. Be sure to save your script often.

1. The first task is to load the packages we have just installed. Note, you might have some issues with the OpenStreetMap package if your installation of java on your computer doesn’t match your installation of R --– e.g. if you have installed the 64bit version of R, you also need the 64bit version of java (same with the 32bit versions) --- you may also need to install the package `Rcpp` separately and try again.

Install Java 64-bit from: https://java.com/en/download/manual.jsp

```{r, message=FALSE, warning=FALSE, cache=FALSE}
#Load Packages (ignore any error messages about being built under a 
#different R version):
library(maptools)
library(RColorBrewer)
library(classInt)
library(sp)
library(rgeos)
library(tmap)
library(tmaptools)
library(sf)
library(rgdal)
library(geojsonio)
```

#### Background to spatial data in R

R has a very well developed ecosystem of packages for working with Spatial Data. Early pioneers like Roger Bivand and Edzer Pebesma along with various colleagues were instrumental in writing packages to interface with some powerful open source libraries for working with spatial data, such as GDAL and GEOS. These were accessed via the ```rgdal``` and ```rgeos``` packages. The  ```maptools``` package by Roger Bivand, amongst other things, allowed Shapefiles to be read into R. The ```sp``` package (along with  ```spdep```) by Edzer Pebesma was very important for defining a series of classes and methods for spatial data natively in R which then allowed others to write software to work with these formats. Other packages like ```raster``` advanced the analysis of gridded spatial data, while packages like ```classInt``` and ```RColorbrewer``` facilitated the binning of data and colouring of choropleth maps.

Whilst these packages were extremely important for advancing spatial data analysis in R, they were not always the most straightforward to use --- making a map in R could take quite a lot of effort and they were static and visually basic. However, more recently new packages have arrived to change this. Now ```leaflet``` enables R to interface with the leaflet javascript library for online, dynamic maps. ```ggplot2``` which was developed by Hadley Wickham and colleagues radically changed the way that people thought about and created graphical objects in R, including maps, and introduced a graphical style which has been the envy of other software to the extent that there are now libraries in Python which copy the ```ggplot2``` style!

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="ggplot2 introduction graphic. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/ggplot2_exploratory.png')
```

Building on all of these, the new ```tmap``` (Thematic Map) package has changed the game completely and now enables us to read, write and manipulate spatial data and produce visually impressive and interactive maps, very easily. In parallel, the ```sf``` (Simple Features) package is helping us re-think the way that spatial data can be stored and manipulated. It’s exciting times for geographic information / spatial data science!

#### Making some choropleth maps

Choropleth maps are thematic maps which colour areas according to some phenomenon. In our case, we are going to fill some irregular polygons (the London Boroughs) with a colour that corresponds to a particular attribute.

As with all plots in R, there are multiple ways we can do this. The basic ```plot()``` function requires no data preparation but additional effort in colour selection/ adding the map key etc. Quick plot (```qplot()```) and ```ggplot()``` (installed in the ```ggplot2``` package, part of the `tidyverse`) require some additional steps to format the spatial data but select colours and add keys etc automatically. Qplot is basically a shortcut for a quick map / plot, but if you have a lot of data use `ggplot()`. However, here, we are going to make use of the new ```tmap``` package which makes making maps very easy indeed. More on `tmap` when we start mapping..

1. So one mega cool thing about R is you can read spatial data in straight from the internetz! Try this below for downloading a GeoJson file...it might take a few minutes...

1. You can also either 

* (a) [Download the geojson file](https://opendata.arcgis.com/datasets/8edafbe3276d4b56aec60991cbddda50_2.geojson) 

* (b) [Download the shapefile](https://opendata.arcgis.com/datasets/8edafbe3276d4b56aec60991cbddda50_2.zip?outSR=%7B%22latestWkid%22%3A27700%2C%22wkid%22%3A27700%7D)from the [Office for National Statistics Open Geography Portal](http://geoportal.statistics.gov.uk/datasets/8edafbe3276d4b56aec60991cbddda50_2)

Move either to your project folder and read it in. The `.shp` is normally quicker to load.

```{r, cache=FALSE, eval=FALSE}
# this will take a few minutes
EW <- st_read("https://opendata.arcgis.com/datasets/8edafbe3276d4b56aec60991cbddda50_2.geojson")
```

```{r, cache=FALSE, eval=TRUE}
# this will take a few minutes
# geojson in local folder
#EW <- st_read(here::here("prac2_data",
#                         "Local_Authority_Districts__December_2015__Boundaries.geojson"))

# shapefile in local folder
EW <- st_read(here::here("prac2_data",
                        "Local_Authority_Districts_(December_2015)_Boundaries",
                        "Local_Authority_Districts_(December_2015)_Boundaries.shp"))
```

Pull out London using the  `str_detect()` function from the `stringr` package in combination with `filter()` from `dplyr` (again!). We will  look for the bit of the district code that relates to London (E09) from the 'lad15cd' column data frame of our `sf` object. 

```{r, cache=FALSE}
LondonMap<- EW %>%
  filter(str_detect(lad15cd, "^E09"))

#plot it using the qtm function
qtm(LondonMap)
```

#### Attribute data

OK, enough messing around, show us the maps!!

1. Hold your horses, before be can create a map, we need to join some attribute data to some boundaries, let's do it with ```merge()```, but first clean up all of our names with `Janitor` again.

```{r, warning=FALSE, cache=FALSE}
LondonData <- clean_names(LondonData)

#EW is the data we read in straight from the web
BoroughDataMap <- EW %>%
  clean_names()%>%
  # the . here just means use the data already loaded
  filter(str_detect(lad15cd, "^E09"))%>%
  merge(.,
        LondonData, 
        by.x="lad15cd", 
        by.y="new_code",
        no.dups = TRUE)%>%
  distinct(.,lad15cd,
           .keep_all = TRUE)
```

We've added some more arguments to `distinct()` that mean we only have unique rows based on the code, but we keep all other variables `.keep_all=TRUE`. If you change to `.keep_all=FALSE` (which is the default) then all the other variables (the attributes in the columns) will be removed.

An alternative to ```merge()``` would be to use a ```left_join()``` (like in SQL)...but it's similar to `merge()`. However, **always use a join type** (e.g. `left_join()`) where possible as it is easier to control how the join works (e.g. inner, left, right, full). `merge()` as default is the same as an inner join...

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="SQL join types. Source: [SQL Join Diagram, dofactory](https://www.dofactory.com/sql/join)"}
knitr::include_graphics('prac2_images/sql-joins.png') 
```

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="dplyr::left_join() example. Source: [Tidy explain by Garrick Aden‑Buie](https://www.garrickadenbuie.com/project/tidyexplain/)"}
knitr::include_graphics('prac2_images/left-join.gif') 
```

```{r, cache=FALSE, warning=FALSE, message=FALSE,eval=FALSE}
BoroughDataMap2 <- EW %>% 
  clean_names() %>%
  filter(str_detect(lad15cd, "^E09"))%>%
  left_join(., 
            LondonData,
            by = c("lad15cd" = "new_code"))

```

If there are multiple matches then all hits are returned...

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="dplyr::left_join() example with multiple matches. Source: [Tidy explain by Garrick Aden‑Buie](https://www.garrickadenbuie.com/project/tidyexplain/)"}
knitr::include_graphics('prac2_images/left-join-extra.gif') 
```

However, i've left out  `filter()` and `distinct()` which you would need to reduce the data to London and remove the duplicate City of London row afterwards...like in the step before with `merge` and as we did earlier on in the session.

### Simple mapping

`tmap` follows the idea of the grammar of graphics, similar to `dplyr` being the grammar of data manipulation. Essentially with the grammar of graphics the main data being mapped defines the location somewhere on Earth (loaded with `tm_shape`). Map aesthetics are then defined with a `+`, these usually include `tm_fill()` (fill of the polygons based on a variable) + `tm_borders()` (border of polygons). However, `tm_polygon` basically combines `tm_fill()` and `tm_borders()`...

So to conclude, data first then `+` aesthetic syntax. 

We're going to create a simple map with our spatial data, mapping and cartographic practice are covered in much more detail later in the course, but for now...

1. We can create a choropleth map very quickly now using ```qtm()``` as we've done before

```{r, cache=FALSE, message=FALSE}
library(tmap)
library(tmaptools)
tmap_mode("plot")
qtm(BoroughDataMap, 
    fill = "rate_of_job_seekers_allowance_jsa_claimants_2015")
```

But that's a bit basic! How about adding a basemap...to get a basemap we need to extract it from OpenStreetMap (OSM) using the `read_osm()` function from the `tmaptools` package. We talk about this in later weeks, but it's a free editable map of the World (the Wikipedia of maps). We are going to need to create a box (termed bounding box) around London using the `st_box()` function from the `sf` package to extract the basemap image (which is a raster). 

```{r, eval=TRUE, cache=FALSE}
tmaplondon <- BoroughDataMap %>%
  st_bbox(.) %>% 
  tmaptools::read_osm(., type = "osm", zoom = NULL)
```

Now we have the basemap, set `tmap` to plot, add the basemap, add the shape (our London layer), tell it which attribute to map (job seekers), the style to make the colour divisions (we explain this more in later weeks), the transparency (alpha), compass, scale and legend.

But remember what i explained earlier... data first then `+` aesthetic syntax. We can also double up on this, so below we have data data from our bounding box + it's raster aesthetic (`tm_rgb`) THEN ALSO the data from our London Borough layer and it's aesthetics. As they are the same place they plot over each other!

There is a bit of extra code below that we haven't explained:

* `style` --- how to divide the data into out colour breaks
* `palette` --- the colour scheme to use

```{r, eval=FALSE, cache=FALSE}
tmap_mode("plot")

tm_shape(tmaplondon)+
tm_rgb()+
tm_shape(BoroughDataMap) + 
tm_polygons("rate_of_job_seekers_allowance_jsa_claimants_2015", 
        style="jenks",
        palette="YlOrBr",
        midpoint=NA,
        title="Rate per 1,000 people",
        alpha = 0.5) + 
  tm_compass(position = c("left", "bottom"),type = "arrow") + 
  tm_scale_bar(position = c("left", "bottom")) +
  tm_layout(title = "Job seekers' Allowance Claimants", legend.position = c("right", "bottom"))

```

For more palette options, run `palette_explorer()` in the console.

So that's our first real map done! Awesome work. But remember our `Life_expectancy4` data that we wrangled earlier. Can you think of a way to map this? So we need to 

1. Merge our `Life_expectancy4map` with the spatial data `EW`
1. Map our merge with `tmap`

```{r}
Life_expectancy4map <- EW %>%
    inner_join(., 
            Life_expectancy4,
            by = c("lad15cd" = "new_code"))%>%
    distinct(.,lad15cd, 
           .keep_all = TRUE)
```

If you change `inner_join()` to `left_join()` what do you get?...now let's make the map!

```{r, message=FALSE}
tmap_mode("plot")

tm_shape(tmaplondon)+
tm_rgb()+
tm_shape(Life_expectancy4map) + 
tm_polygons("UKdiff", 
        style="pretty",
        palette="Blues",
        midpoint=NA,
        title="Number of years",
        alpha = 0.5) + 
  tm_compass(position = c("left", "bottom"),type = "arrow") + 
  tm_scale_bar(position = c("left", "bottom")) +
  tm_layout(title = "Difference in life expectancy", legend.position = c("right", "bottom"))
```

There are a few subtle differences in the code of this second map if you look closely:

* Style is now `pretty` not `jenks`. Style controls where the breaks are within the data that are then assigned to each colour for mapping. `pretty` rounds to whole numbers and evenly spaces them over the data.

* Palette in now `Blues` not `YlOrBr`. Palette controls the colour of the map, you can see more options through `tmaptools::palette_explorer()`

## Tidying data

As you progress through the programme you will probably notice that there is pretty much a tool or function for anything you could want. However, there has been little reserach into creating a standardised approach for wrangling data into a common format for analysis. This is where [Hadley Wickham's tidy data comes in]( https://www.jstatsoft.org/article/view/v059i10 ). As per the [R for Data Science book](https://r4ds.had.co.nz/tidy-data.html), tidy data is defined using the following three rules:

1. Each variable must have its own column.

1. Each observation must have its own row.

1. Each value must have its own cell.

This rules are shown visually in the below image, although this is not an image of tidy data....keep reading...

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="This figure is taken directly from Grolemund and Wickham (2017) Chapter 12.Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells."}
knitr::include_graphics('prac2_images/tidy-1.png') 
```


But, as per the book, these three requirements are interrelated as you can't only adhere to two without adhering to all three. So this gives us:

1. Put each dataset in a tibble

1. Put each variable in a column


This is an example of tidy data ...note that a value must have its own row, so no row can have multiple values...

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="This figure is taken directly from Grolemund and Wickham (2017) Chapter 12.Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells. Source: [KSK analytics](https://www.ksk-anl.com/blog/hadley-wickhams-tidy-data-in-rapidminer-part-1/)"}
knitr::include_graphics('prac2_images/messy-tidy-ex.png') 
```


Earlier we read in the data using:

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
flytipping <- read_csv("https://data.london.gov.uk/download/fly-tipping-incidents/536278ff-a391-4f20-bc79-9e705c9b3ec0/fly-tipping-borough.csv")
```

But we can also do something like this to force the columns to the appropriate data types (e.g. text, numeric)

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
flytipping1 <- read_csv("https://data.london.gov.uk/download/fly-tipping-incidents/536278ff-a391-4f20-bc79-9e705c9b3ec0/fly-tipping-borough.csv", 
                       col_types = cols(
                         code = col_character(),
                         area = col_character(),
                         year = col_character(),
                         total_incidents = col_number(),
                         total_action_taken = col_number(),
                         warning_letters = col_number(),
                         fixed_penalty_notices = col_number(),
                         statutory_notices = col_number(),
                         formal_cautions = col_number(),
                         injunctions = col_number(),
                         prosecutions = col_number()
                       ))
# view the data
view(flytipping1)
```

So we have a tibble with columns of each varaible (e.g. warning letters, total actions taken) where every row is a London borough. We want make sure that each observation has its own row...it doesn't as in the first row here we have observations for total incidents and total actions taken etc...to do this we will use `pivot_longer()`. Make sure you have the most recent version of `tidyverse` if you get an error.


```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
#convert the tibble into a tidy tibble
flytipping_long <- flytipping1 %>% 
  pivot_longer(
  cols = 4:11,
  names_to = "tipping_type",
  values_to = "count"
)

# view the data
view(flytipping_long)
```

Do you see the difference..the data has become longer!...this is classed as tidy data as every variable has a column, every observation has a row and every value has a cell. 

You could also use this to do the same thing...

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
#an alternative which just pulls everything out into a single table
flytipping2 <- flytipping1[,1:4]
```

But my advice would be to learn how to use the tidy tools! 

Now let's make it a bit more suitable for mapping with `pivot_wider()` by making coloumns for each year of each variable....in the original `.csv` we had a year coloumn that had values of 2011-2012 to 2017-2018, so if we wanted to map a specifc year we'd have to filter out the year then map. Here we can just alter the data from `pivot_longer()` using the year and tipping type...

> Note, just because the data is considered tidy doesn't mean it is directly appropriate for mapping. It might need to be tidy for analysis.

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
#pivot the tidy tibble into one that is suitable for mapping
flytipping_wide <- flytipping_long %>% 
  pivot_wider(
  id_cols = 1:2,
  names_from = c(year,tipping_type),
  names_sep = "_",
  values_from = count
)

view(flytipping_wide)
```

But what if you were just interested in a specific varaible and wanted the coloums to be each year of the data...again using `pivot_wider()`

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
widefly <- flytipping2 %>% 
  pivot_wider(
  names_from = year, 
  values_from = total_incidents)
```

You could now join this to the London borough `.shp` and produce a map...

For another quick worked example have a look at the [RLadies Sydney blog post on pivoting](https://rladiessydney.org/courses/ryouwithme/02-cleanitup-5/)

What's the take home from this? Basically always try to put your data into a certain format before doing further analysis on it as it will be easier for you to determine the right tools to select.

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 

<!--chapter:end:02-prac2.Rmd-->

# Spatial descriptive statistics

## Learning outcomes

By the end of this practical you should be able to:

1. Load, manipulate and interpret raster layers
1. Observe and critique different descriptive data manipulation methods and outputs

## Homework

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

The task is to manipulate some raster data and produce some descriptive statistics. Climatic models fed into the latest Intergovernmental Panel on Climate Change (IPCC), the models are divided into Shared Socioeconomic Pathways known as SSPs, ranging from [SSP1](https://view.es-doc.org/?renderMethod=name&project=cmip6&type=cim.2.designing.NumericalExperiment&client=esdoc-url-rewrite&name=ssp126) (lots of mitigation and adaption) to [SSP5](https://view.es-doc.org/?renderMethod=name&project=cmip6&type=cim.2.designing.NumericalExperiment&client=esdoc-url-rewrite&name=ssp126) (fossil fuel development). The [Carbon Brief explainer](https://www.carbonbrief.org/explainer-how-shared-socioeconomic-pathways-explore-future-climate-change) has more information on the scenarios. 

For any country in the World produce descriptive statistics that show the difference in maximum annual temperature for key cities between SSP1 and SSP5 for the years 2081-2100, using any model and resolution.

* [WorldClim future projections](https://www.worldclim.org/data/cmip6/cmip6_clim2.5m.html)
* [Country outlines](https://gadm.org/data.html)
* [World city points](https://hub.arcgis.com/datasets/esri::world-cities/explore?location=3.049068%2C-178.464838%2C1.71)

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

This week: 

* [Chapter 5 "Descriptive statistics"](https://learningstatisticswithr.com/book/descriptives.html) from Learning statistics with R: A tutorial for psychology students and other beginners by Navarro (2019)

* [Exploratory data analysis: using colour and layout for comparison](https://www.roger-beecham.com/comp-sds/class/04-class/) by Beecham (2021).

* [Chapter 7 "Reprojecting Geographic Data"](https://geocompr.robinlovelace.net/reproj-geo-data.html) from Geocomputation with R by Lovelace, Nowosad and Muenchow (2022).

**Watching**

* [Hadley Wickham's Keynote from the European Molecular Biology Laboratory (EMBL)](https://www.youtube.com/watch?v=9YTNYT1maa4). This will be the same for a few weeks.

* [Can you make an accurate map by SciShow](https://www.youtube.com/embed/8I_VpC6IuJs)

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/2P63KJNeC3DwaLpw8KHYqE). Oh Wonder, from London, an alt-pop duo according to Wikipedia. I just really like their music. Was due to see them in December in London, but it's been postponed. Ultralife is their first album and the one i prefer, tracks 2-4 are where it's at! 

[Adam](https://open.spotify.com/album/4hEKRyUeVXejefnsvKYERB?si=FSgLYASmTh6lLNIcKXqtjg) OK, this week it's the 21st Century's answer to Shakespear - the man who provided the soundtrack to countless post-club 'back-to-your-house?' early mornings in my youth. Yes, straight outta Brum (via Brixton), he's only gone and penned a bunch of awesome new tracks almost 20 years after he first burst out of his bedroom studio. It's only flippin' Mike Skinner. You're listening to the Streets!

## Introduction 

This practical is composed of three parts. To start with we're going to explore projection systems in more detail. In the second part we will load some global raster data into R. In the final part we extract data points (cities and towns) from this data and generate some descriptive statistics and histograms. 

## Part 1 projections

Projections systems are mathematical formulas that specify how our data is represented on a map. These can either be call geographic coordiate reference systems or projected coordinate reference systems. The former  treats data as a sphere and the latter as a flat object. You might come across phrases such as a resolution of 5 minutes or a resolution of 30 metres, which can be used to establish what kind of projection system has been used. Let me explain...

A minute type of resolution (e.g. 5 minute resolution) is a geographic reference system that treats the globe as if it was a sphere divided into 360 equal parts called degrees (which are angular units). Each degree has 60 minutes and each minute has 60 seconds. Arc-seconds of latitude (horizontal lines in the globe figure below) remain almost constant whilst arc-seconds of longitude (vertical lines in the globe figure below) decrease in a trigonometric cosine-based fashion as you move towards the Earth's poles...

```{r echo=FALSE,  out.width="49%", fig.align='center', cache=FALSE, fig.cap="Latitude and Longitude. Source: [ThoughtCo.](https://www.thoughtco.com/degree-of-latitude-and-longitude-distance-4070616)"}
knitr::include_graphics('prac3_images/arcseconds.jpg')
```


This causes problems as you increase or decrease latitude the longitudinal lengths alter...For example at the equator (0°, such as Quito) a degree is 111.3 km whereas at 60° (such as Saint Petersburg) a degree is 55.80 km  ...

**In contrast** a projected coordinate system is defined on a flat, two-dimensional plane (through projecting a spheroid onto a 2D surface) giving it constant lengths, angles and areas...


```{r vectorplots, fig.cap="Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula. Source: [Lovelace et al. (2019) section 2.2](https://geocompr.robinlovelace.net/spatial-class.html)", out.width="49%", fig.show='hold', echo=FALSE, cache=FALSE}
knitr::include_graphics(c("prac3_images/vector_lonlat.png","prac3_images/vector_projected.png"))
```

Knowing this, if we want to conduct analysis locally (e.g. at a national level) or use metric (e.g. kilometres) measurements we need to be able to change the projection of our data or "reproject" it. Most countries and even states have their own projected coordinate reference system such as British National Grid in the above example...Note how the origin (0,0) is has moved from the centre of the Earth to the bottom South West corner of the UK, which has now been ironed (or flattened) out.

::: {.infobox .warning data-latex="{note}"}

**Projection rules**

Units are angular (e.g. degrees, latitude and longitude) or the data is global = Geographic coordinate reference system

Units are linear (e.g. feet, metres) or data is at a local level (e.g. national, well the last one is not always true, but likely) = Projected coordinate reference system.
:::

You might hear some key words about projections that could terrify you! Let's break them down:

* Ellipsoid (or spheroid) = size of shape of the Earth (3d)
* Datum = contains the point relationship (where the origin (0,0) of the map is) between a Cartesian coordinates (flat surface) and Earth's surface. They can be local or geocentric (see below). They set the origin, the scale and orientation of the Coordiante Reference System (CRS).
* Local datum = changes the Ellipsoid to align with a certain location on the surface (e.g. BNG that uses the OSGB36 datum). A local datum is anything that isn't the centre of the Earth.
* Geocentric datum =  the centre is equal to the Earth's centre of gravity (e.g. WGS84).
* Geodetic datum = global datum (see above for datum meaning) for representing features (e.g. points and polygons) on earth
* Geodesy (from which we get Geodetic) = measuring Earth's shape and features (e.g. gravity field). 
* Coordinate reference system (CRS) = Formula that defines how the 2D map (e.g. on your screen or a paper map) relates to the 3D Earth. Sometimes called a spatial Reference System (SRS). It also stores the datum information.

::: {.infobox .tip data-latex="{note}"}

**Take home message**

When you do analysis on multiple datasets make sure they are all use the same Coordiante Reference System.

If it's local (e.g. city of country analysis) then use a local projected CRS where possible.
:::

### Changing projections

#### Vector

Until now, we’ve not really considered how our maps have been printed to the screen. Later on in the practical we will explore gridded temperature in Australia, as we will need an outline of Australia let's use that as an example here:

1. First, we need to source and load a vector of Australia. Go to: https://gadm.org/download_country_v3.html and download the GeoPackage

1. Once we've downloaded the `.gpkg` let's see what is inside it with `st_layers()`...

```{r, message=FALSE, cache=FALSE}
library(sf)
library(here)
st_layers(here("prac3_data", "gadm36_AUS.gpkg"))
```

1. Then read in the GeoPackage layer for the whole of Australia (layer ending in 0)

```{r, cache=FALSE}
library(sf)
Ausoutline <- st_read(here("prac3_data", "gadm36_AUS.gpkg"), 
                      layer='gadm36_AUS_0')
```

You can check that the coordinate reference systems of  ```sf ``` or  ```sp ``` objects using the print function:

```{r, cache=FALSE}
print(Ausoutline)
```
The coordinates stored in the ```geometry``` column of your ```sf``` object contain the information to enable points, lines or polygons to be drawn on the screen. You can see that our `Ausoutline` is a multipolygon and every point within the polygon will have coordinates that are in a certain reference system, here Geodetic CRS:  WGS 84. The geodetic means geographic, if it was a projected coordiante reference system it would say projected CRS..like the week 1 data of the London Boroughs said...`## Projected CRS: OSGB 1936 / British National Grid`

#### WGS84

The World Geodetic System 84 (WGS84 - last revised in 1984) is one of the most common global projection systems, used in nearly all GPS devices. However there are many versions of WGS84, some geographic and some projected coordinate reference systems. 

**3D globe**

* GPS devices and point data sets often use the Geographic version (EPSG code 4326), **usually referred to just as WGS84**
* Google Earth uses the Geographic version as it is a 3D globe (EPSG code 4326)

::: {.infobox .tip data-latex="{note}"}

In GIS if you add a layer that is 3D (e.g. in WGS84) it will map it on the 2D screen! But how? It takes the latitude and longitude values and maps them as planar coordinates. This means it linearly maps 3D points to a 2D plane....some people might refer to this as "unprojected" but i would say that it has a geographic coordinate reference system.

```{r planar, fig.align='center',fig.cap="Planar projections. Source: [Wikipedia (2023) ](https://en.wikipedia.org/wiki/Planar_projection)", out.width="20%", fig.show='hold', echo=FALSE, cache=FALSE}
knitr::include_graphics("prac3_images/150px-Axonometric_projection.svg.png")
```

:::


**Flat**

* Google Maps / Carto / Bing / Open street map use Web Mercator, Google Web Mercator, Spherical Mercator, WGS 84 Web Mercator or **WGS 84/Pseudo-Mercator** which is a projected coordinate reference system (EPSG code 3857). It is a variant of the Mercator map projection. 
* The WGS 1984 world Mercator projection is a projected coordinate reference system following the Mercator map transformation (EPSG code 3395)

The projected versions will have units of meters and the geographic versions units of degrees.

In the rare occasion some data was collected in a Geographic coordinate reference system other than WGS84, you might find that the points / polygons won't line up with data in WGS84. This is because different Geographic coordinate reference systems use different ellipsoids (shape / size of Earth) and/or datums (the origin point (0,0), typically they use Earth's centre of gravity). To make them match you need to transform a dataset. That said QGIS will project 'on the fly' meaning if you add layers with a different CRS it will make them appear the same on the screen (changing the projection live or 'on the fly'). It won't change the CRS of the data itself though, you have to do that manually. 

An example of another Geographic coordinate reference systems is the North American 1983 Datum (NAD83) that uses a different ellipsoid (longer by 0.21mm compared to WGS84), it also just has reference points on the North America plate (that moves 1-2cm a year), WGS84 has them all over the world.

This same logic applies for projected coordinate references systems that could be different, as they use a different origin and the projected coordinate reference system still contains the geographic one, the projected part tells the computer how to draw the shape.

#### Proj4

Whilst we were able to identify the CRS of our layer using `print` another alternative is to find the `proj4` string. A `proj4` string is meant to be a compact way of identifying a coordinate reference system. Let's extract ours...

```{r}
library(sf)
st_crs(Ausoutline)$proj4string
```

> “Well that’s clear as mud!” I hear you cry! Yes, not obvious is it!

The proj4-string basically tells the computer where on the earth to locate the coordinates that make up the geometries in your file and what distortions to apply (i.e. if to flatten it out completely etc.) It's composed of a list of parameters separated by a `+`. Here are projection `proj` uses latitude and longitude (so it's a geographic not projected CRS). The `datum` is WGS84 that uses Earth's centre mass as the coordinate origin (0,0). 

The [Coordiante systems in R chapter by Gimond (2019)](https://mgimond.github.io/Spatial/coordinate-systems-in-r.html#understanding-the-proj4-coordinate-syntax) provides much more information on Proj4. However, i'd advise trying to use EPSG codes, which we come onto next.

1. Sometimes you can download data from the web and it doesn’t have a CRS. If any boundary data you download does not have a coordinate reference system attached to it (NA is displayed in the coord. ref section), this is not a huge problem --- it can be added afterwards by adding the proj4string to the file or just assigning an EPSG code.

To find the proj4-strings for a whole range of different geographic projections, use the search facility at http://spatialreference.org/ or http://epsg.io/.

#### EPSG

Now, if you can store a whole proj4-string in your mind, you must be some kind of savant (why are you doing this course? you could make your fortune as a card-counting poker player or something!). The rest of us need something a little bit more easy to remember and for coordinate reference systems, the saviour is the European Petroleum Survey Group (EPSG) --- (naturally!). Now managed and maintained by the [International Association of Oil and Gas producers](http://www.epsg.org/) --- EPSG codes are short numbers represent all coordinate reference systems in the world and link directly to proj4 strings. We saw these last week in the [Making some maps] section.

The EPSG code for the WGS84 World Geodetic System (usually the default CRS for most spatial data) is 4326 --- http://epsg.io/4326

1. If our Australian outline didn't have a spatial reference system, we could have just set it using `st_set_crs()`

```{r, cache=FALSE, warning=FALSE, message=FALSE}
Ausoutline <- Ausoutline %>%
  st_set_crs(., 4326)
```

Or, more concisely...but remember this is only useful if there is no CRS when you load the data.

```{r, cache=FALSE, warning=FALSE, message=FALSE, eval=TRUE}
#or more concisely
Ausoutline <- st_read(here("prac3_data", "gadm36_AUS.gpkg"), 
                      layer='gadm36_AUS_0') %>% 
  st_set_crs(4326)
```

**Normally** if a layer has a missing CRS, it's WGS84. But check for any metadata that might list it.

#### Reprojecting your spatial data

Reprojecting your data is something that you might have to (or want to) do, on occasion. Why? Well, one example might be if you want to measure the distance of a line object, or the distance between two polygons. This can be done far more easily in a projected coordinate system  (where the units are measured in metres) than it can a geographic coordinate system such as WGS84 (where the units are degrees).

**However** for generating maps in packages like ```leaflet```, your maps will  need to be in WGS84, rather than a projected (flat) reference system .

1. So once your data has a coordinates system to work with, we can re-project or transform to anything we like. For SF objects, like our outline of Australia it’s carried out using ```st_transform```. Here we are changing from WGS84 to [GDA94](https://epsg.io/3112), which is a local CRS for Australia and has the EPSG code 3112....

```{r, cache=FALSE}
AusoutlinePROJECTED <- Ausoutline %>%
  st_transform(.,3112)

print(AusoutlinePROJECTED)
```

In the SF object, you can compare the values in the geometry column with those in the original file to look at how they have changed...

You might also encounter an `SP` object from the `sp` package. In this case i'd advise just transforming the `sp` object to `sf` and changing the projection....this was covered last week..but it's here too...

```{r, cache=FALSE}
#From sf to sp
AusoutlineSP <- Ausoutline %>%
  as(., "Spatial")

#From sp to sf
AusoutlineSF <- AusoutlineSP %>%
  st_as_sf()

```

If you are still a bit confused by coordinate reference systems then **stop** and take some time to have a look at the resources listed here. It is very important to understand projection systems.

This is the best resources I've come across explaining coordinate reference systems are:

* [I hate coordinate systems](https://ihatecoordinatesystems.com/#mental-model)

* [ESRI's coordinate systems and projections for beginners](https://communityhub.esriuk.com/geoxchange/2012/3/26/coordinate-systems-and-projections-for-beginners.html)

* [The story of Mercator](https://mercator.tass.com/mercator-heritage)


### WorldClim data 

So far we've only really considered vector data. Within the rest of this practical we will explore some raster data sources and processing techniques. If you recall rasters are grids of cell with individual values. There are many, many possible sources to obtain raster data from as it is the data type used for the majority (basically all) of remote sensing data.

We are going to use WorldClim data --- this is a dataset of free global climate layers (rasters) with a spatial resolution of between 1$km^2$ and 240$km^2$.

1. Download the data from: https://www.worldclim.org/data/worldclim21.html

1. Select any variable you want at the 5 minute second resolution. 

1. Unzip and move the data to your project folder. Now load the data. We could do this individually....

```{r ,message=FALSE}
library(raster)
library(terra)
jan<-terra::rast(here("prac3_data", "wc2.1_5m_tavg_01.tif"))
# have a look at the raster layer jan
jan
```

1. Then have a quick look at the data, we can see it's again in the geographic projection of WGS84.

```{r, cache=FALSE}
plot(jan)
```

To reproject a raster the whole grid must be recomputed (for a vector is was just the individual coordinates of the shapes), and the attributes then reestimated to the new grid. To do this we have to use `project()` from the `terra` package. This is a new(ish) package and function, it still accepts Proj4 strings in the first example below, but also accepts the much easier to deal with spatial references. I have tested some EPSG and ESRI references from [Spatial reference](https://spatialreference.org/ref/?search=Mollweide).

Now we can actually see some data...here is a quick example of using the Mollweide projection saved to a new object. The Mollweide projection retains area proportions whilst compromising accuracy of angle and shape 

```{r cache=FALSE, warning=FALSE, message=FALSE}
# set the proj 4 to a new object

pr1 <- terra::project(jan, "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

#or....

newproj<-"ESRI:54009"
# get the jan raster and give it the new proj4
pr1 <- jan %>%
  terra::project(., newproj)
plot(pr1)
```
Now back to WGS84.....

```{r cache=FALSE, warning=FALSE, message=FALSE}
pr1 <- pr1 %>%
  terra::project(., "EPSG:4326")
plot(pr1)
```

### Data loading

Ok, projections over. Let's move forward with the practical...

1. A better and more efficient way is to firstly list all the files stored within our directory with `dir_info()` from the `fs` pacakge, then use `dplyr` in conjunction with `str_detect()` from `stringr` to search for filenames containing `tif`. Finally just select the paths.

1. But let's firstly explore what `dir_info()` does...

```{r, cache=FALSE}
# look in our folder, find the files that end with .tif and 
library(fs)
dir_info("prac3_data/") 
```

Essentially it just gets the details you would normally see in the file explorer..however, we can use this data with `dplyr` to select the data we actually want. Now be careful! the function `select()` exists both within the `dplyr` and `raster` package so to make sure you use the right one `dplyr::select` forces `select` from `dplyr`.

```{r}
library(tidyverse)
listfiles<-dir_info("prac3_data/") %>%
  filter(str_detect(path, ".tif")) %>%
  dplyr::select(path)%>%
  pull()

#have a look at the file names 
listfiles
```

Here, we're also using `pull()` from `dplyr` which is the same as the `$` often used to extract columns as in the next stage the input must be filenames as characters (nothing else like a column name).

1. Then load all of the data straight into a SpatRaster. A SpatRaster is a collection of raster layers with the same spatial extent and resolution.

```{r, cache=FALSE}
worldclimtemp <- listfiles %>%
  terra::rast()
  
#have a look at the raster stack
worldclimtemp
```

In the stack you'll notice that under dimensions there are 12 layers (nlyr). The stack has loaded the 12 months of average temperature data for us in order. 

1. To access single layers within the stack:

```{r, cache=FALSE}

# access the january layer
worldclimtemp[[1]]

```

1. We can also rename our layers within the stack:

```{r, cache=FALSE}
month <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", 
           "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

names(worldclimtemp) <- month

```

Last week we used `rename()` from the `dplyr` package, however, this isn't yet available for raster data `r emo::ji("frowning_face")`

1. Now to get data for just January use our new layer name

```{r, cache=FALSE}
worldclimtemp$Jan
```

### Raster location

1. Using a raster stack we can extract data with a single command!! For example let's make a dataframe of some sample sites --- Australian cities/towns.

```{r, cache=FALSE}
site <- c("Brisbane", "Melbourne", "Perth", "Sydney", "Broome", "Darwin", "Orange", 
          "Bunbury", "Cairns", "Adelaide", "Gold Coast", "Canberra", "Newcastle", 
          "Wollongong", "Logan City" )
lon <- c(153.03, 144.96, 115.86, 151.21, 122.23, 130.84, 149.10, 115.64, 145.77, 
         138.6, 153.43, 149.13, 151.78, 150.89, 153.12)
lat <- c(-27.47, -37.91, -31.95, -33.87, 17.96, -12.46, -33.28, -33.33, -16.92, 
         -34.93, -28, -35.28, -32.93, -34.42, -27.64)
#Put all of this inforamtion into one list 
samples <- data.frame(site, lon, lat, row.names="site")
# Extract the data from the Rasterstack for all points 
AUcitytemp<- terra::extract(worldclimtemp, samples)
```

1. Add the city names to the rows of AUcitytemp

::: {.infobox .tip data-latex="{note}"}
When we extract data from a raster with a point or polygon it is termed **zonal statistics** in GIS - we want to get some statistics from the zone (point / polygon) for the area that is over the raster.
:::


```{r, cache=FALSE}
Aucitytemp2 <- AUcitytemp %>% 
  as_tibble()%>% 
  add_column(Site = site, .before = "Jan")
```

## Part 2 descriptive statistics

Descriptive (or summary) statistics provide a summary of our data, often forming the base of quantitative analysis leading to inferential statistics which we use to make inferences about our data (e.g. judegements of the probability that the observed difference between two data sets is not by chance) 

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, fig.cap="Summary statistics. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/summary_statistics.png')
```

### Data preparation 

1. Let's take Perth as an example. We can subset our data either using the row name:

```{r, cache=FALSE}
Perthtemp <- Aucitytemp2 %>%
  filter(site=="Perth")
```

1. Or the row location:

```{r, cache=FALSE, eval=FALSE}
Perthtemp <- Aucitytemp2[3,]
```

### Histogram

A histogram lets us see the frequency of distribution of our data. This will vary based on the data that you have downloaded. 

1. Make a histogram of Perth's temperature. The tibble stored the data as double and the base `hist()` function needs it as numeric..

```{r, cache=FALSE}
hist(as.numeric(Perthtemp))
```

Remember what we're looking at here. The ```x``` axis is the temperature and the ```y``` is the frequency of occurrence. 

There seems to be an outlier with this plot as we haven't removed the columns we don't need - look in the `Perthtemp` tibble and you will see an ID of 3 which is plotted above! We will solve this next...

1. That's a pretty simple histogram, let's improve the aesthetics a bit. 

```{r, cache=FALSE}
library(tidyverse)
#define where you want the breaks in the historgram
userbreak<-c(8,10,12,14,16,18,20,22,24,26)

# remove the ID and site columns
Perthtemp <- Aucitytemp2 %>%
  filter(site=="Perth")

t<-Perthtemp %>%
 dplyr::select(Jan:Dec)

  hist((as.numeric(t)), 
     breaks=userbreak, 
     col="red", 
     main="Histogram of Perth Temperature", 
     xlab="Temperature", 
     ylab="Frequency")
```

1. Check out the histogram information R generated

```{r warning=FALSE, fig.show='hide', cache=FALSE}
histinfo <- as.numeric(t) %>%
  as.numeric()%>%
  hist(.)

histinfo
```
Here we have:

* breaks --- the cut off points for the bins (or bars), we just specified these
* counts --- the number of cells in each bin
* midpoints --- the middle value for each bin
* density --- the density of data per bin

### Using more data

This was still a rather basic histogram, what if we wanted to see the distribution of temperatures for the whole of Australia in Jan (from averaged WorldClim data) as opposed to just our point for Perth. Here, we will use the outline of Australia we loaded earlier..

Check the layer by plotting the geometry...we could do this through...

```{r, cache=FALSE, warning=FALSE, message=FALSE}
plot(Ausoutline$geom)
```

But as the `.shp` is quite complex (i.e. lots of points) we can simplify it first with the `st_simplify()` function. It's good practice that when you load data into R you check to see what it looks like...Here the argument `dTolerance` controls the level of generalisation in the units of the map, you can also set `preserveTopology` to TRUE or FALSE, when true it means that polyongs aren't removed and holes in polygons are retained.  

```{r, cache=FALSE, warning=FALSE, message=FALSE}

AusoutSIMPLE <- Ausoutline %>%
  st_simplify(., dTolerance = 1000) %>%
  st_geometry()%>%
  plot()

```

This should load quicker, but for 'publication' or 'best' analysis (i.e. not just demonstrating or testing) i'd recommend using the real file to ensure you don't simplify a potentially important variable. 

1. Next, set our map extent (where we want to clip the data to) to the outline of Australia then crop our WorldClim dataset to it.

**HOWEVER**, we need to make sure that both of our layers are in the same coordinate reference system when we combine them...so..

```{r, cache=FALSE}
print(Ausoutline)
#this works nicely for rasters
crs(worldclimtemp)
```

Perfect! Now let's continue...

```{r, cache=FALSE}
Austemp <- Ausoutline %>%
  # now crop our temp data to the extent
  terra::crop(worldclimtemp,.)

# plot the output
plot(Austemp)

```

You'll notice that whilst we have the whole of Australia the raster hasn't been perfectly clipped to the exact outline....the crop here just specifies an extent box that will cover the whole of the shape. 

1. If want to just get raster data within the outline of the shape use trhge `mask()`function which uses a cookie cutter of the raster with the vector layer:

```{r, cache=FALSE}
exactAus<-terra::mask(Austemp, Ausoutline)
```

You could also run this using the original worldclimtemp raster, however, it may take some time. I'd recommend cropping to the extent first. 
1. Let's re-compute our histogram for Australia in March. We could just use hist like we have done before. We can either subset using the location (we know March is third in the raster).

```{r, cache=FALSE}
#subset using the known location of the raster
hist(exactAus[[3]], col="red", main ="March temperature")
```

However we have a bit more control with ```ggplot()```...

### Histogram with ggplot

1. We need to make our raster into a data.frame to be compatible with ```ggplot2```, using a dataframe or tibble

```{r, cache=FALSE}
exactAusdf <- exactAus %>%
  as.data.frame()
```

```{r, warning=FALSE, message=FALSE, cache=FALSE}
library(ggplot2)
# set up the basic histogram
gghist <- ggplot(exactAusdf, 
                 aes(x=Mar)) + 
  geom_histogram(color="black", 
                 fill="white")+
  labs(title="Ggplot2 histogram of Australian March temperatures", 
       x="Temperature", 
       y="Frequency")
# add a vertical line to the hisogram showing mean tempearture
gghist + geom_vline(aes(xintercept=mean(Mar, 
                                        na.rm=TRUE)),
            color="blue", 
            linetype="dashed", 
            size=1)+
  theme(plot.title = element_text(hjust = 0.5))
```

How about plotting multiple months of temperature data on the same histogram 

1. As we did in practical 2, we need to put our variable (months) into a one column using ```pivot_longer()```. Here, we are saying select columns 1-12 (all the months) and place them in a new column called `Month` and their values in another called `Temp`

```{r, cache=FALSE}
squishdata<-exactAusdf%>%
  pivot_longer(
  cols = 1:12,
  names_to = "Month",
  values_to = "Temp"
)
```
1. Then subset the data, selecting two months using `filter()` from `dplyr`

```{r, cache=FALSE}
twomonths <- squishdata %>%
  # | = OR
  filter(., Month=="Jan" | Month=="Jun")
```

1. Get the mean for each month we selected, remember `group_by()` and `summarise()` from last week?

```{r, cache=FALSE, messages=FALSE, warnings=FALSE}

meantwomonths <- twomonths %>%
  group_by(Month) %>%
  summarise(mean=mean(Temp, na.rm=TRUE))

meantwomonths
```

1. Select the colour and fill based on the variable (which is our month). The intercept is the mean we just calculated, with the lines also based on the coloumn variable.

```{r message=FALSE, warning=FALSE, cache=FALSE}
ggplot(twomonths, aes(x=Temp, color=Month, fill=Month)) +
  geom_histogram(position="identity", alpha=0.5)+
  geom_vline(data=meantwomonths, 
             aes(xintercept=mean, 
                 color=Month),
             linetype="dashed")+
  labs(title="Ggplot2 histogram of Australian Jan and Jun
       temperatures",
       x="Temperature",
       y="Frequency")+
  theme_classic()+
  theme(plot.title = element_text(hjust = 0.5))
```

> **Note** how i adjusted the title after i selected the theme, if i had done this before the theme defaults would have overwritten my command.

1. Have you been getting an annoying error message about bin size and non-finate values? Me too!...Bin size defaults to 30 in ```ggplot2``` and the non-finate values is referring to lots of NAs (no data) that we have in our dataset. In the code below i've:

* dropped all the NAs with `drop_na()`

* made sure that the Month column has the levels specified, which will map in descending order (e.g. Jan, Feb, March..)

* selected a bin width of 5 and produced a faceted plot...

```{r fig.height=10, fig.height=6, cache=FALSE}

data_complete_cases <- squishdata %>%
  drop_na()%>% 
  mutate(Month = factor(Month, levels = c("Jan","Feb","Mar",
                                          "Apr","May","Jun",
                                          "Jul","Aug","Sep",
                                          "Oct","Nov","Dec")))

# Plot faceted histogram
ggplot(data_complete_cases, aes(x=Temp, na.rm=TRUE))+
  geom_histogram(color="black", binwidth = 5)+
  labs(title="Ggplot2 faceted histogram of Australian temperatures", 
       x="Temperature",
       y="Frequency")+
  facet_grid(Month ~ .)+
  theme(plot.title = element_text(hjust = 0.5))

```

Does this seem right to you? Well...yes. It shows that the distribution of temperature is higher (or warmer) in the Australian summer (Dec-Feb) than the rest of the year, which makes perfect sense. 

How about an interactive histogram using ```plotly```...

1. See if you can understand what is going on in the code below. Run each line separately.

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(plotly)
# split the data for plotly based on month

jan <- squishdata %>%
  drop_na() %>%
  filter(., Month=="Jan")

jun <- squishdata %>%
  drop_na() %>%
  filter(., Month=="Jun")

# give axis titles
x <- list (title = "Temperature")
y <- list (title = "Frequency")

# set the bin width
xbinsno<-list(start=0, end=40, size = 2.5)

# plot the histogram calling all the variables we just set
ihist<-plot_ly(alpha = 0.6) %>%
        add_histogram(x = jan$Temp,
        xbins=xbinsno, name="January") %>%
        add_histogram(x = jun$Temp,
        xbins=xbinsno, name="June") %>% 
        layout(barmode = "overlay", xaxis=x, yaxis=y)

ihist
```
This format of code where you set lots of varaibles then call them within a plot, package or fuction is sometihng you should become more familiar with as it's considerd good practice. If you were to go on and produce multiple plots using the same legends / aesthetics you only ahve to set them once. 

Ok so enough with the histograms...the point is to think about how to best display your data both effectively and efficiently. 

1. Let's change the pace a bit and do a quickfire of other descrptive statistics you might want to use...

```{r message=FALSE, warning=FALSE, cache=FALSE}
# mean per month
meanofall <- squishdata %>%
  group_by(Month) %>%
  summarise(mean = mean(Temp, na.rm=TRUE))

# print the top 1
head(meanofall, n=1)

# standard deviation per month
sdofall <- squishdata %>%
  group_by(Month) %>%
  summarize(sd = sd(Temp, na.rm=TRUE))

# maximum per month
maxofall <- squishdata %>%
  group_by(Month) %>%
  summarize(max = max(Temp, na.rm=TRUE))

# minimum per month
minofall <- squishdata %>%
  group_by(Month) %>%
  summarize(min = min(Temp, na.rm=TRUE))

# Interquartlie range per month
IQRofall <- squishdata %>%
  group_by(Month) %>%
  summarize(IQR = IQR(Temp, na.rm=TRUE))

# perhaps you want to store multiple outputs in one list..
lotsofstats <- squishdata %>%
  group_by(Month) %>%
  summarize(IQR = IQR(Temp, na.rm=TRUE), 
            max=max(Temp, na.rm=T))

# or you want to know the mean (or some other stat) 
#for the whole year as opposed to each month...

meanwholeyear=squishdata %>%
  summarize(meanyear = mean(Temp, na.rm=TRUE))
  
```
## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 


<!--chapter:end:03-prac3.Rmd-->

# Git, GitHub and RMarkdown

## Learning outcomes

By the end of this practical you should be able to:

1. Explain the use of and differences between Git and GitHub
1. Create reproducible and open R code
1. Produce RMarkdown documents that explain code and analysis

## Homework

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**
Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

The task this week is to:

* Read in [global gender inequality data](https://hdr.undp.org/data-center/documentation-and-downloads) 
* Join the global gender inequality index to [spatial data of the World](https://hub.arcgis.com/datasets/2b93b06dc0dc4e809d3c8db5cb96ba69_0/explore?location=-2.688200%2C0.000000%2C1.41), creating a new column of difference in inequality between 2010 and 2019
* Share it with the World on GitHub
* Add you repository URL to the circulated spreadsheet

**Tip** the [countrycode R package](https://github.com/vincentarelbundock/countrycode) will be helpful!

**Tip** the gender inequality has changed in the last year, you will find what you need in the "All composite indices and components time series (1990-2021)" dataset, the metadata file beneath it will explain what the columns are.
 
:::

::: {.infobox .note data-latex="{note}"}

**Reading**

This week: 

* [Chapter 2 "Basics"](https://bookdown.org/yihui/rmarkdown/basics.html) from R Markdown: The Definitive Guide by Xie, Allaire and Grolemund (2019)

* [Chapter 2 "Why RMarkdown"](https://rmd4sci.njtierney.com/why-rmarkdown.html#reproducibility-is-a-problem) from RMarkdown for Scientists by Tierney (2020).  

* [Replication across space and time must be weak in the social and environmental sciences](https://www.pnas.org/doi/10.1073/pnas.2015759118?cookieSet=1) by Goodchild and Wenwen (2020).

* [The paper "Packaging Data Analytical Work Reproducibly Using R (and Friends)"](https://amstat.tandfonline.com/doi/full/10.1080/00031305.2017.1375986?scroll=top&needAccess=true) by Marwick, Boettiger & Mullen (2018).

**Watching**

* [Git for Humas by Alice Bartlett from UX Brighton](https://www.youtube.com/watch?v=eWxxfttcMts)

* [Hadley Wickham's Keynote from the European Molecular Biology Laboratory (EMBL)](https://www.youtube.com/watch?v=9YTNYT1maa4). This will be the same for a few weeks.

* [Karthik Ram's "A guide to modern reproducible data science with R"](https://rstudio.com/resources/rstudioconf-2019/a-guide-to-modern-reproducible-data-science-with-r-karthik-ram/)

* [R Markdown Notebooks](https://www.youtube.com/embed/zNzZ1PfUDNk)

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/4kUbTSoTsbKP5MRdYMDBx1) Beautiful people will ruin your life! One of my favorite bands...the Wombats. Formed in 2003 at the Liverpool institute of performing arts. Just really talented musicians.

[Adam](https://open.spotify.com/album/6SoIcnKddNcjL0GkjyTClJ?si=e2X98Ui8Q8SK5WIeLGWhSg) What happens when two of the greatest MCs ever to pick up a mic get together to make some music? They only smash out a double album with some of the biggest producers in drum & bass and absolutely kill it! Yes, known to their mums as Delroy and Dominic, to the rest of us as DRS and Dynamite, it's only Playing in the Dark by DRS and Dynamite!

## Introduction  

In this practical you will learn how to produce work that is open, reproducible, shareable and portable using RStudio, RMarkdown, Git and GitHub. As more and more researchers and organisations publish assocaited code with their manusripts or documents it's very imporant to become adept at using these tools.

The tools you will use are:

* RStudio is a graphical user interface (that you should already be familiar with) --- it contains a number of features which make it excellent for authoring reproducible and open geographic data science work.

* RMarkdown is a version of the Markdown markup language which enables plain text to be formatted to contain links to data, code to run, text to explain what you a producing and metadata to tell your software what kinds of outputs to generate from your markdown code. For more information on RMarkdown look [here](https://rmarkdown.rstudio.com/).

* Git is a software version control system which allows you to keep track of the code you produce and the changes that you or others make to it.

* GitHub is an online repository that allows anyone to view the code you have produced (in whatever language you choose to program in) and use/scrutinise/contribute to/comment on it.

## Git and GitHub 

### The three ways

There are three ways to make your RStudio project work with GitHub

1. Set up the GitHub repository, clone it to your Git then load it in RStudio --- using Git GUI
1. Create a new RStudio project and link it to GitHub --- new version control
1. If you have an existing RProject then you can link them manually --- existing project

I will show you all three, you should be able to do way 1, then way 2 using the same repository. Way 3 will have merge issues, so start with a fresh GitHub repository. It is useful if you have produced some code then want to share it at a later date. Follow what i do in the lecture.

My advice is to read the Git and GitHub parts of the practical before you start (until the [RMarkdown] section).

### Set up your GitHub

1. If you are working on your own computer, you will first need to install Git --- https://git-scm.com/ --- if you are working on the UCL Remote Desktop, you won’t need to do this as it is already installed for you.

1. Go to http://github.com, create an account and create a new repository (call it anything you like - ‘gis_code’ or something similar), making sure it is public and you check the box that says ‘initialise new repository with a README’ --- click ‘create repository’ at the bottom

```{r echo=FALSE, out.width = "700pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/github.png') 
```

1. Your new repository (‘repo’) will be created and this is where you will be able to store your code online. You will notice that a README.md markdown file has also been created. This can be edited to tell people what they are likely to find in this repository.

### Using RStudio with Git

In summer 2021 GitHub changed it's authentication process to a token based system as opposed to a password based system. David Keys provided an [excellent overview with some videos that documented this change and how to now set things up, which i have adapted here](https://rfortherestofus.com/2021/02/how-to-use-git-github-with-r/)

#### Check Git is installed 

In the console window you will see a terminal tab, check Git is installed with `which git` then `git --version` you should get a message in response that says where your git installation is and the version you have.

#### Configure your Git

You need to tell Git who you are and your GitHub username. The easiest way is to use the `usethis` package, you will need to install and library it.

Then, in the console, type the function `edit_git_config()`

A Git config will load and you need to change your name and email to match GitHub.

If this is empty use the following template and save the file.

```{r, eval=FALSE}
[user]
	name = 
	email = 
	username = 
```

#### Start your Git

To start Git you **need to be in a RStudio project**. Instructions below show you how to do this in various scenarios. For example, in the first Git way, we clone (copy) a remote repository (of our own) then if we wanted to make changes (to the remote) we would need to follow these instructions to link our Git to GitHub

In the first instance we just copy it from the remote (GitHub), that will have git ready to go - so don't do this now....but a very simple way is to again load the `usethis` package in the console and the function `use_git()`, then type option 1. You would do this for a project that you have started, which doesn't have git enabled. 

#### Connect Git to GitHub

Once we have an RStudio project with Git, either making it oursevles or downloading one from GitHub, we need to connect it to GitHub.

From GitHub you need to generate a personal access token. You can use the function `create_github_token()` from the `usethis` package or also through GitHub > settings > Developer settings > personal access tokens > generate new token.

Use a descriptive name and consider saving the token - it won't save on GitHub

The last step is to store this token in Git with the `gitcreds` package > install and load it > then use the function `gitcreds_set()` > copy your token in.

### Using the Git GUI - way 1

1. Now you have created your repo online, you need to ‘clone’ it so that there is an identical copy of it in a local folder on your computer.

There are a couple of ways of doing this, but the easy one is to use the GUI that comes packaged with your git installation.

1. The first thing you need to do is copy the Clone URL for your repo from the github website --- click the green button in your repo for ‘Clone or Download’ and copy the link:

```{r echo=FALSE, out.width = "700pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/githubrepodownload.png') 
```

1. Now in the windows start menu, go to Git > GUI

1. Select ‘Clone Existing Repository’ and paste the link from your GitHub account into the top box and the local directory that you want to create to store your repo in the bottom box (note, you will need to add a name for a new folder, once you have selected an existing directory, don't create a new folder in windows explorer you have to specify it in the file path).

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/gitsetup.png') 
```

1. After a few moments, you should now be able to view a copy of your GitHub repo on your local machine. This is where you will be able to store all of your code and some other files for your reproducible research.

1. Open RStudio and go File > New Project > Existing Directory

```{r echo=FALSE, out.width = "400pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/existing.png') 
```

1. Set the project working directory to what you specified in the Git GUI target directory. You have now linked your project to your local Git

>Note for later, when we try to push to GitHub from RStudio the push button might be geyed out..this is most likely due to your local Git branch not tracking (following) the GitHub branch!  I show you how to fix this in the greyed out push button section.

### Create a new version control in RStudio - way 2

There is an easier way to set up Git and GitHub with your project, but this assumes you are starting fresh (with no code in an RProject)!

1. Under [Set up your GitHub] we made a repository on GitHub. Copy that URL.

1. Open RStudio > File New Project > Version Control > Git

1. Copy in the repository URL and provide a project directory name...but it should populate when you paste in the URL

```{r echo=FALSE, out.width = "400pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/easyway.png') 
```

### If have an existing project - way 3

1. Open RStudio and your existing project (or make a new one...i will make one here). In RStudio Tools > Global Options, under ‘Git/SVN’ check the box to allow version control and locate the folder on your computer where the git.exe file is located --- if you have installed git then this should be automatically there. If you make a new project make sure you create a file (`.R` or `.Rmd` through File > New File), add something to it, then save it (File > Save As) into your project folder. When it saves it should appear in the bottom right Files window.

1. Next go Tools > Project Options > Git/SVN > and select the version control system as Git. You should now see a git tab in the environment window of RStudio (top right) and the files also appear under the Git tab. It should look something like this....

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/makeafile.png') 
```

Now you will be able to use Git and GitHub as per the following instructions...

### Commiting to Git

1. As well as saving (as you normally do with any file), which saves a copy to our local directory, we will also ‘commit’ or create a save point for our work on git. 

1. To do this, you should click the ‘Git’ icon and up will pop a menu like the one below:

```{r echo=FALSE, out.width = "400pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/commit1.png') 
```

You can also click the Git tab that will have appeared in the top-right window of RStudio. Up will then pop another window that looks a little like the one below:

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/commit2.png') 
```

1. Stage the changes, add a commit message so you can monitor the changes you make, then click commit

1. Make some more changes to your file and save it. Click commit again then in the review changes box you will be able to see what has changed within your file. Add a commit message and click commit:

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/commit3.png') 
```

### Push to Github

We need to create a new GitHub repo for our local project. Luckily the `usethis` package can do this for us. Simply type the function `use_github()` in the console and a new GitHub repo will appear using the name of your project! 

Now we can push our changes to GitHub using the up arrow either in the RStudio Git tab (environment quadrant), or from the review changes box (opens when you click commit).

But....if the push button is greyed out go to the section [Greyed out push button]

### Pull from GitHub

1. Pull will take any changes to the global repo and bring them into your local repo. Go to your example GitHub repo (online) and click on your test file > edit this file.

1. Add a line of code or a comment, preview the changes then commit directly to the main branch.

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/pullexample.png') 
```

1. Now in RStudio click the down arrow (Pull) request. Your file should update in RStudio. 
If you were to update your file on GitHub and your local one in RStudio separately you would receive an error message in RStudio when you attempted to commit.

### Using Git outside RStudio

Sometimes RStudio Git can be a bit temperamental. For example, when staging the files they can take some time to appear with the ticked box (I think this is because we are working from the Network). Normally in RStudio you click the commit button, select to stage all the files, wait a few seconds then close the review changes box and commit from the buttons in the Git tab in the environment quadrant. 

Alternatively if you would like to use Git but you’re working on the UCL Remote Desktop or you are experiening other problems with getting git working in RStudio, fear not, you can just use your raw Git installation.

1. In the Start Menu, open the git GUI. Start > Git > Git GUI. You should open the existing repository that you have just created.

1. Whenever you have made some changes to your files in your cloned repo, you can use git to review the changes and ‘Commit’ (save) them and then ‘Push’ them up to your main repository on GitHub.

1. To review and commit your changes, in the commit menu, simply:

a. scan for changes
b. stage them ready for committing
c. commit the changes
d. push the changes to your GitHub repo

### Troubleshooting

#### Were you challenged for your password?

As of January 2019 it is possible that Git will use a credential helper provided by the operating system. However, as of summer 2021 the token system has replaced this, so this is very unlikely.

You can however set your username and email manually using the git prompt.

Go Tools > Shell and enter: 

```{r, eval=FALSE, cache=FALSE}
git config --global user.name 'yourGitHubUsername'
git config --global user.email 'name@provider.com'
```
These only need to be set once.

#### Greyed out push button

Is your push button greyed out? Mine was when i tried to set it up within an existing project in the section [If have have an existing project] ... Fear not....

First, let's check your local repository (Git) is connected to a remote one (GitHub). 
Open the Shell again (Tools > Shell) and enter:

```{r, eval=FALSE, cache=FALSE}
git remote -v
## output

origin  https://github.com/andrewmaclachlan/example.git (fetch)
origin  https://github.com/andrewmaclachlan/example.git (push)
```

The fetch and push should be your repository on GitHub. If you need to set the remote repo use:

```{r, eval=FALSE, cache=FALSE}
git remote add origin https://github.com/andrewmaclachlanc/myrepo.git
```

**Replace** my name and myrepo with your account and repo --- it's the same URL that we cloned from GitHub...

Was it setup correctly ? Yes...

Then check the current branch in RStudio (and Git) is tracking a branch on the remote repo --- mine wasn't.

```{r, eval=FALSE, cache=FALSE}
git branch -vv

## output
main 3abe929 [origin/main] test3
```

Origin/main shows that the local main is tracking the origin/main on the remote repo. If you can't see origin/main then set it using the following code. At the moment RStudio and git still defaults to the starting branch of master so the fist line below will change it to main --- which is required to match with the remote (GitHub).

```{r, eval=FALSE, cache=FALSE}
git branch -M main
git push -u origin main
```

>Origin is the repository you cloned (from GitHub) and main is the name of the branch. You might see something like...your branch is ahead of origin/main by 1 commit. This means you have commited something you are working on in you local repo (Git) that hasn't yet been pushed to GitHub (the origin) and main branch...GitHub defaults the first branch to be called main

If you need to change the URL of your GitHub .... so where you push your local Git to the GitHub account (changing this), perhaps you have made a new GitHub repo...

```{r, eval=FALSE, cache=FALSE}
git remote set-url origin [enter your cloned URL from GitHUB here]```
```

For more trouble shooting on Git and GitHub have a look at the book [Happy Git and GitHub for the useR](https://happygitwithr.com/rstudio-git-github.html)

### Fork a repository 

A *Fork* in GitHub is a copy of someone else's repository to your own GitHub account. You could use it as a base starting point for your project or to make a fix and then submit a pull request to the original owner who would then *pull* your changes to their repository. 

1. You can fork a GitHub example repository from: https://github.com/octocat/Spoon-Knife 

Once you fork it, you should see it in your repositories 

### Branches

Each repository you make in git has a default branch but you can create new branches to isolate development of specific areas of work without affecting other branches --- like a test environment. 

1. Go to the test repository you just forked on github. Click the branch drop down and type in the name for a new branch:

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/branch.png') 
```

1. Now click on the README.md file > edit this file

1. Add some changes, preview them and complete the commit changes box at the bottom of the screen.

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/branchtest.png') 
```

1. Here, we're going to commit directly to the new branch. We could have made these changes to the main branch and then made a new branch for them at this stage. Commit the changes.

1. Go to the home page of our example branch (click the branch down arrow and select your example branch). You'll see that our example branch is now 1 commit ahead of the main 

Now let's create a **pull** request to the main branch. If you had modified someone else's code, then you would send a request to them to pull in the changes. Here we are doing a pull request for ourselves --- from our example branch to our main.

1. Click New pull request.

1. At the top you will see the branches that are being compared --- the base defaults to githubs example repository, change it to yours.

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/branchcompare.png') 
```

1. Now scroll down and you will see the comparison of between the two branches. Click create pull request.  

1. Select squash and merge > confirm squash and merge. This means that all our commits on the exmaple branch and squashed into one, as we only have one it doesn't matter but could be useful in future. 

1. Go back to your main branch repository and you should see the changes from the example branch have been merged.

We will show you how to publish RMarkdown documents online in a later practical.

#### Git commands

If you'd rather use shell to control Git then you can. If you have a large project RStudio sometimes has limits on filename length (e.g. this might occur with a book, like this one). To get around this you can use the following commands:

* `git add .` to stage all files
* `git commit -m "commit comment"` to commit all the staged files
* `git push` to push the commited files to the remote

### Health warning 

To avoid merge conflicts be careful with your commits, pushes and pulls. Think about what you are doing each time. GitHub help pages are quite comprehensive... https://help.github.com/en/articles/resolving-a-merge-conflict-on-github

## RMarkdown

OK, so now you have set everything up so that you can become a reproducible research ninja! All that remains is to do some reproducible research!

```{r echo=FALSE, fig.align='center', cache=FALSE}
#knitr::include_url("https://www.youtube.com/embed/zNzZ1PfUDNk")
```

R Markdown is awesome as you can show code, explanations and results within the same document!!!! Often it could be very hard to reproduce results owing to a lack of information in the methodology / userguides or walkthrougts not matching up with the latest version of software. Think back to a time where you had to use software and consult a massive userguide in how to use it...for me it was a very painful experience. R Markdown is a big improvement as it puts all of the information in the same document, which can then be convereted into a range of different formats --- html for webpages, word documents, PDFs, blogs, books --- virtually everything! 

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE}
knitr::include_graphics('allisonhorst_images/rmarkdown_rockstar.png')
```

It's also not limited to R code!!! To change the code language all you have to do is edit what is between the {} in a code chunk. In R by default you get {r}, put for python you just change this to {python}!!! COOL. You've also got to have all the python software installed and the R `reticulate()` package too..

Now, earlier on in this exercise, I got you to open a new R Script. You now need to open a new R Markdown document, you could also select an R Notebook...They are both RMarkdown documents, the notebook originally let you run code chunks that could be executed independently, however you can also now do this if you select a markdown file. To my knowledge the only difference is that a R Notebook adds ```output: html_notebook``` in the output option in the header of the file that adds a Preview button in the tool bar. If you don't have this then the preview option will be replaced with Knit.

```{r echo=FALSE, out.width = "300pt", fig.align='center', cache=FALSE}
knitr::include_graphics('allisonhorst_images/knit-logo.png')
```

But you can mix the output options in your header for the file to get the Preview button back if you wish to. Basically, there isn't much difference and you can manually change it with one line of code. Have a look [at this stackoverflow question](https://stackoverflow.com/questions/43820483/difference-between-r-markdown-and-r-notebook) for more infomation. For ease i'd just stick with R Markdown files

There are two ways to create an RMarkdown document 

1. File > New File > R Markdown

1. You can change the type in the bottom right corner of the script window....

```{r echo=FALSE, out.width = "400pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/changetype.png') 
```

I always use way no.1 (so use that here) and this will be populated with some example data, click Knit to see what it does...the file should load in the viewer pane, if you click the arrow and browser button it will open in an internet browser..

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/Rmakrdowneg.png')
```

### HTML

1. We are now going to insert some code from the practical last week into the new R Markdown document ...clear all of the code except the stuff between the ---

1. In RStudio, you can either select Code > Insert Chunk or you can Click the ‘Insert’ button and insert an R chunk

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/code_chunk.png')
```

1. A box will appear and in this box, you will be able to enter and run your R code. Try pasting in:

```{r warning=FALSE, cache=FALSE}
library(terra)
library(here)
jan<-terra::rast(here("prac3_data", "wc2.1_5m_tavg_01.tif"))
# have a look at the raster layer jan
plot(jan)
```

When including code chunks in your work, there are various options that allow you to do things like include the code, but not run it: display the output but not the code, hide warnings etc. Most of these can be input automatically by clicking the cog icon in the top-right of the chunk, or you can specify them in the code header of the chunk...if you toggle the buttons you'll see the code change in the chunk 'header'. There are also two useful icons to the right of the settings cog, the first will run all code above the current chunk (play symbol facing downwards) and the second will run the current code chunk (regular play symbol)

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/code_chunk_options.png')
```

### Knit options

Various other options and tips can be found in the full R Markdown guide on RStudio here: 

* https://rmarkdown.rstudio.com/lesson-1.html 
* https://rmarkdown.rstudio.com/lesson-3.html (for code chunk options)

### Shortcuts

This [Twitter thread started by We are R-Ladies](https://twitter.com/WeAreRLadies/status/1250310603970732036) is one of the best resources i've found for shortcuts using RMarkdown. Favorites that will help you are:

**New code chunk**
CTRL + ALT + i

**New comment in code**
CTRL + SHIFT + c

**Align code consistently**
CTRL+i

**Format ugly code to nice looking code**
CTRL + ALT + A 


**Insert section label which is fold-able and navigable** --- this only works in a `.R` file not a `.Rmd` but is still useful
CTRL + SHIFT + R

## Further reading

Since starting this little guide, I have come across the book [Happy Git and GitHub for the useR](http://happygitwithr.com/) on, well, using R and GitHub by Jenny Bryan and Jim Hester. It’s brilliant --- get involved! 

...Also the [GitHub guide](https://guides.github.com/activities/hello-world/)

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 

<!--chapter:end:04-prac4.Rmd-->

# Map making

## Learning outcomes

By the end of this practical you should be able to:

1. List and explain basic mapping concepts across QGIS and R
1. Interpret and manipulate data from multiple sources
1. Create near publishable static and interactive mapped outputs
1. Evaluate and critique mapping approaches between QGIS and R

## Homework

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

The task this week is to:

* Fork the repository below you from the spreadsheet last week
* Run the code, editing it if required
* Create a map (you can use additional data if you wish)
* submit a pull request to the original person

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

This week: 

* [Chapter 8 "Making maps with R"](https://geocompr.robinlovelace.net/adv-map.html) from Geocomputation with R by Lovelace, Nowosad and Muenchow (2020)

* [How to lie with maps, Chapter 10](https://ucl.primo.exlibrisgroup.com/discovery/fulldisplay?docid=alma990000462680204761&context=L&vid=44UCL_INST:UCL_VU2) by Monmonier (1996).

**Watching**

* [Episode 1 of Maptastic from the Financial Times with Professor Alasdair Rae formerly of the University of Sheffield](https://www.youtube.com/watch?v=CfrmHSmwOoo).

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/0Wmnkh4lzGy5rgkUPOjYbg). Mumford & Sons, unique sound classed as British folk rock apparently. Enjoy! 

[Adam](https://open.spotify.com/album/6QcNw2Tt4KxraptfxcYzNy) Your ears are in for an absolute treat this week. Hospital Records have only gone and put out a mind-blowing mini compilation album which completely smashes it. It's NHS400 - get your ears around this!

## Introduction 

In this practical we're going to focus on creating mapped outputs using QGIS, ArcMap and R. For fun we're going to use data from OpenStreetMap (OSM) and Airbnb. 

### OSM

OpenStreetMap is collaborative project that has created a free editable map of the World. As users can create their own content it is classed as Volunteered geographic Information (VGI). There is a lot of academic literature on VGI, it's advnatages and disadvantages. For an overview of VGI checkout this [article](https://link.springer.com/article/10.1007/s10708-007-9111-y) by Goodchild (2007).

If you are interested in exploring the power of VGI and OSM further checkout [missing maps](https://www.missingmaps.org/). They aim to map missing places, often in less developed countires, using OSM so that when natural disasters occur first responders can make data informed decisions. They run events all over the world and it's worth going to meet other spatial professionals, gain some experience with OSM and contribute to a good cause. 

### Airbnb

Airbnb is an online marketplace that connects people looking to rent homes to those seeking accomodation often over short time periods.

## Data

It’s possible to download OSM data straight from the website, although the interface can be a little unreliable (it works better for small areas). There are, however, a number of websites that allow OSM data to be downloaded more easily and are directly linked to from the ‘Export’ option in OSM. Geofabrik (one of these websites) allows you to download frequently updated shapefiles for various global subdivisions.

### OSM

1. Go to the Geofabrik download server [website](http://download.geofabrik.de/)

1. Navigate to: Europe > GreatBritain > England > Greater London

1. Download greater-london-latest-free.shp.zip

1. Unzip the data and save it to your current folder

### London boroughs

We'll use our London boroughs layer again, either load it from week 1 or download it:

1. To get the data go to [the London data store](https://data.london.gov.uk/)

1. Search for Statistical GIS Boundary Files for London

1. Download the statistical-gis-boundaries-london.zip

1. Unzip the data and save it to your current folder

### World cities

We will use World cities to provide some context to our maps.

1. Download them from the [ArcGIS HUB](https://hub.arcgis.com/datasets/6996f03a1b364dbab4008d99380370ed_0) > Download > Shapefile.

### Uk outline

1. Download [GADM data for the UK](https://gadm.org/download_country.html)

### Airbnb

1. Download the `listings.csv` from the [inside airbnb website](http://insideairbnb.com/get-the-data.html) for London.

::: {.infobox .warning data-latex="{note}"}
In the lecture we discussed how when producing maps there should be some sort of common denominator as opposed to mapping raw counts. Go and source a suitable common denominator then using the skills from previous weeks normalise your data. **Hint** there is a table on the [Office for National Statistics NOMIS website](https://www.nomisweb.co.uk/census/2011/data_finder) called number of bedrooms which would let you normalise the airbnb and hotel data based on the number of bedrooms in each ward. 
:::

## QGIS

Ok, now we're going to reproduce our map in QIGS.

### Load data

1. Load QGIS, Open and Save a new project (Project > New) 

1. Right click on ```GeoPackage``` and create a new database to store our data in ```.gpkg```

1. Load our data layers: London boroughs and OSM data (OSM data should be the  ```gis_osm_pois_a_free_1 polygon layer```). 

1. Make sure the processing toolbox is active...go Plugins > Manage and Install Plugins > Installed (left side of the box that opens), Processing should be ticked....then select the cog that is in the toolbar --- within the sqaure box in the image below. 

```{r echo=FALSE, out.width = "700", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/cog.png') 
```

You can then search for tools in the Processing Toolbox that appears on the right of QGIS.

### Manipulate data

If you recall from practical 1, QGIS sets the map document CRS to that of the first layer loaded. Our London boroughs layer is in British National Grid (EPSG: 27700) where as are OSM layers are in WGS 1984 (EPSG: 4326).

The OSM data will load and QGIS is pretty clever here as it will project ‘on the fly’ which means it can display the data stored in one projection as if it were in another, but the actual data is not altered. This is both good and bad. Good as it let’s us visualise our data quickly, but bad because if we have data with different projections you will run into problems during processing. My advice is to load the data and pick a projection to do all processing in.

1. Reproject the OSM data. If you scroll right in the dialogue box you'll be able to save it into your ```GeoPackage```. You might need to refresh the browers to see the layer.

```{r echo=FALSE, out.width = "800", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGIS_reproj.png') 
```

1. While we are working with projections...check the CRS of your map (bottom right)...mine is EPSG 4326 (WGS 1984) and we want it to be in British National Grid (which is ESPG: 27700), click on it, change it and apply.

1. For completness also drag and drop your London boroughs ```.shp``` from the Layers window (bottom left) into your ```GeoPacakge```. Remove the old one from the Layers window. Double click on the new ```London boroughs``` layer in the ```GeoPackage``` and it will open

1. To get only the hotels out of our OSM data we can use ```extract by attrbitue```...this is my tool dialogue box. You can find extract by attribute by clicking the toolbox cog, then searching for extract by attribute.

```{r echo=FALSE, out.width = "700", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/extractattribute.png') 
```

1. Refresh the browser ---you have to do this everytime. Double click the layer to load it.

1. Now ```extract by location using``` the file you just created and the London boroughs (so hotels within the London boroughs). Note that i selected that the hotels are within the Lonon boroughs

```{r echo=FALSE, out.width = "800", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/extractbylocation.png') 
```

1. Let's now count our hotels per London borough using ```Join Attributes by Location (Summary)```. Note i selected the ```osm_id``` field to summarise using count in summaries to calcualte....

```{r echo=FALSE, out.width = "800", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/joinosmandlondon.png') 
```

1. Next up is the Air b n b data, i'll show you how to load it then you need to produce a count of rentals per London borough using the same rules as before (entire place/apartment and available all year). To load the data click Data Source Manager > Delimited Text:

```{r echo=FALSE, out.width = "800", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGISxy.png') 
```

You need to: 

* Sort the projection out and save into your ```.gpkg```

* Select by attibute (entire place and 365 days)

* Select by location (within London boroughs)

* Join the output to a new (or original) London borough polygon layer

> **Note** You can filter by multiple attributes using extract by expression...here we would use the expression ```("room_type" ILIKE '%Entire home/apt%') AND ("availability_365" ILIKE '%365%')``` to filter based on entire home/apt and available 365 days of the year.

### Map data

1. So now you should have two London borough layers one with a count of all the hotels and the other with a count of all the air b n b properties...To make a thematic map right click on the hotel layer > Symbology (tab) select Graduated and your count coloumn as the coloumn, mode as natural breaks and then classify...

```{r echo=FALSE, out.width = "800", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGISsymbology.png') 
```

1. Now save the style so we can use it on our other layer....Style > Save Style > select in Database and provide a name

1. Go to the symbology of the other layer > select Graduated, select the correct count coloumn, then Style > Load Style, from database and your saved style should be listed. 

1. To create a new map document in QGIS go: Project > New Print Layout. The layout works by adding a new map which is a snapshop of the main QGIS document....

1. In the main QGIS document only select your airbnb layer, right click and zoom to it. GO back to the Print Layout > Add Item > Add Map..draw a sqaure...the layer should appear...In the window at the bottom right under Item Properties select to Lock layers...so now if you were to unselect that layer it would still remain on in the Print Layout

1. Go back to your main QGIS document, now only select the hotels layer...repeat the Add Map steps and lock the layers

1. Make sure you give the same size to both Maps...to do so click on a Map > Item Properties (bottom right) scroll down, expand Position and Size, give the same width and height values

```{r echo=FALSE, out.width = "400", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/positionsize.png') 
```

1. Add some guides to line everything up go: View > Manage Guides. The guides panel will appear in the bottom right hand corner, click the + to add a guide at a distance you specify. You can then drag your maps to snap to the guides.

1. Add a scale bar: Add Item > Add Scale Bar. To adjust it, right click > Item Properties...alter some of the properties to make it look appropraite.

1. Add a legend: Add Item > Add Legend and draw a sqaure. Same process to adjust it. Untick Auto update then you can use the ```+``` and ```-``` icons to remove items along with the edit icon to change the text...this is what mine looks like...

```{r echo=FALSE, out.width = "400", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGIS_legend.png') 
```

1. Add an arrow: Add Item > Add Arrow, left click to start (twice) and right click to finish.

1. Add text: In the left hand tool bar click add text box and draw a square

1. Let's add our extent map, load the UK ```.shp```, reproject it and save it into your  ```.gpkg  ```. Do the same for your city points but be sure to load them into your ```.gpkg  ``` before you run any tool (just drag and drop them). When reprojecting you might see a lot of errors for certain points in the processing box...don't worry ```British National Grid``` only covers the UK --- these errors will be for points outside of the UK which we will remove

1. Now replicate our ArcMap inset map by opening the Layer Properties of the new cities layer > Labels > Single Labels with city name, alter any of the text styles as you wish. Also play around with the symbology..

1. Add the new map into your map layout and move the items to appropraite locations...

This is what i came up with in my map layout

```{r echo=FALSE, out.width = "600", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGIS_maplayout.png') 
```

### Export map

To export your map to a file go: Layout > Export as Image and select crop to content...and here is my map...

```{r echo=FALSE, fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_data/QGIS_hotel.png') 
```

> **Note** there are a few problems with my map that could be improved:
(1) If you look closely at the vector layer for London you will see that one of the boroughs is missing from map (b) --- this is most likely because it has no data but could easily be fixed
(2) Whilst this time i've displayed all the city names the colour scheme needs work...for ideas on this check out colour brewer.

### Graphical modeler

As in ArcMap we can automate the methodological process in QGIS using the graphical modeler..again i'll provide a short example here

1. Go: Processing > Graphical Modeler

Graphical modeler is a bit different to model builder in ArcMap, here you drag inputs and algorthims from the inputs box (bottom left) into the model, you don't need to specify the inputs here. When you click the run buttom (play on the top toolbar) you'll be asked to provide the layers for the inputs. The options will be limited to those you currently have open in your map...check out the model i made to automate reprojecting cities and the UK outline, then extracting the cities within the UK outline...

```{r echo=FALSE, out.width = "600", fig.align='center', cache=FALSE}
knitr::include_graphics('prac5_images/QGIS_model.png') 
```

Make sure you save your model from the top tool bar either as a standalone model or within your project

## R

Your R and geographical skills are certainly improving by now, so i'm just going to provide you with the R code i used to do this analysis...

### Spatial joining

I will note that i have made use of a new function called `st_join()`. This is similar to the the joins we explored with attribute data (e.g. joining based on a unique attribute column) but here we just want to join datasets together and keep all their attribute data, this is useful in the code below where i want to join assign the London Borough to each hotel in London. The output will be a massive dataset where each hotel will be a new row and will retain the attributes of the hotel data but also append the attribute of the borough....`st_join()` defaults to a left join, so in this case the borough data is the left dataset and all the right data has been appended to it. If the left data (borough) had no matches (so no hotels) they would still appear in the final dataset. The default argument for this is `st_intersects` but we will explore this more next week.


```{r, message=FALSE}
library(sf)

Londonborough <- st_read(here::here("Prac1_data",
                                    "statistical-gis-boundaries-london", 
                                    "ESRI", 
                                    "London_Borough_Excluding_MHW.shp"))%>%
  st_transform(., 27700)

OSM <- st_read(here::here("prac5_data",
                          "greater-london-latest-free.shp", 
                          "gis_osm_pois_a_free_1.shp")) %>%
  st_transform(., 27700) %>%
  #select hotels only
  dplyr::filter(fclass == 'hotel')


join_example <-  st_join(Londonborough, OSM)

head(join_example)
```


### Static map

```{r message=FALSE, warning=FALSE, cache=FALSE, out.width="800pt"}
##Load all our data
library(sf)
library(tmap)
library(tmaptools)
library(tidyverse)
library(here)

# read in all the spatial data and 
# reproject it 

OSM <- st_read(here::here("prac5_data",
                          "greater-london-latest-free.shp", 
                          "gis_osm_pois_a_free_1.shp")) %>%
  st_transform(., 27700) %>%
  #select hotels only
  filter(fclass == 'hotel')

Worldcities <- st_read(here::here("prac5_data", 
                                  "World_Cities", 
                                  "World_Cities.shp")) %>%
  st_transform(., 27700)

UK_outline <- st_read(here::here("prac5_data", 
                                 "gadm36_GBR_shp", 
                                 "gadm36_GBR_0.shp")) %>%
  st_transform(., 27700)

#London Borough data is already in 277000
Londonborough <- st_read(here::here("Prac1_data",
                                    "statistical-gis-boundaries-london", 
                                    "ESRI", 
                                    "London_Borough_Excluding_MHW.shp"))%>%
  st_transform(., 27700)

# read in the .csv
# and make it into spatial data

Airbnb <- read_csv("prac5_data/listings.csv") %>%
  # longitude is considered x value here, latitude is y
  st_as_sf(., coords = c("longitude", "latitude"), 
                   crs = 4326) %>%
    st_transform(., 27700)%>%
    #select entire places that are available all year
    filter(room_type == 'Entire home/apt' & availability_365 =='365')


# make a function for the join
# functions are covered in practical 7
# but see if you can work out what is going on
# hint all you have to do is replace data1 and data2
# with the data you want to use

Joinfun <- function(data1, data2){

output<- data1%>%
  st_join(data2,.) %>%
  add_count(GSS_CODE, name="hotels_in_borough") 

  return(output)
}

# use the function for hotels
Hotels <- Joinfun(OSM, Londonborough)

# then for airbnb
Airbnb <- Joinfun(Airbnb, Londonborough)
 
Worldcities2 <- Worldcities %>%
  filter(CNTRY_NAME=='United Kingdom'&
           Worldcities$CITY_NAME=='Birmingham'|
           Worldcities$CITY_NAME=='London'|
           Worldcities$CITY_NAME=='Edinburgh')

newbb <- c(xmin=-296000, ymin=5408, xmax=655696, ymax=1000000)
  
UK_outlinecrop <- UK_outline$geometry %>%
  st_crop(., newbb)

Hotels <- Hotels %>%
  #at the moment each hotel is a row for the borough
  #we just one one row that has number of airbnbs
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))

Airbnb <- Airbnb %>%
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))
```
Make the map
```{r, warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}

tmap_mode("plot")

# set the breaks
# for our mapped data
breaks = c(0, 5, 12, 26, 57, 286) 

# plot each map
tm1 <- tm_shape(Hotels) + 
  tm_polygons("Accomodation count", 
              breaks=breaks,
              palette="PuBu")+
  tm_legend(show=FALSE)+
  tm_layout(frame=FALSE)+
  tm_credits("(a)", position=c(0,0.85), size=1.5)

tm2 <- tm_shape(Airbnb) + 
  tm_polygons("Accomodation count",
              breaks=breaks, 
              palette="PuBu") + 
  tm_legend(show=FALSE)+
  tm_layout(frame=FALSE)+
  tm_credits("(b)", position=c(0,0.85), size=1.5)

tm3 <- tm_shape(UK_outlinecrop)+ 
  tm_polygons(col="darkslategray1")+
  tm_layout(frame=FALSE)+
  tm_shape(Worldcities2) +
  tm_symbols(col = "red", scale = .5)+
  tm_text("CITY_NAME", xmod=-1, ymod=-0.5)

legend <- tm_shape(Hotels) +
    tm_polygons("Accomodation count",
                palette="PuBu") +
    tm_scale_bar(position=c(0.2,0.04), text.size=0.6)+
    tm_compass(north=0, position=c(0.65,0.6))+
    tm_layout(legend.only = TRUE, legend.position=c(0.2,0.25),asp=0.1)+
    tm_credits("(c) OpenStreetMap contrbutors and Air b n b", position=c(0.0,0.0))
  
t=tmap_arrange(tm1, tm2, tm3, legend, ncol=2)

t
```

We can also arrange our maps using the ```grid``` package...

```{r warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}

library(grid)
# erases the current device or moves to a new page 
# probably not needed but makes sure you are plotting on a new page.
grid.newpage()

pushViewport(viewport(layout=grid.layout(2,2)))
print(tm1, vp=viewport(layout.pos.col=1, layout.pos.row=1, height=5))
print(tm2, vp=viewport(layout.pos.col=2, layout.pos.row=1, height=5))
print(tm3, vp=viewport(layout.pos.col=1, layout.pos.row=2, height=5))
print(legend, vp=viewport(layout.pos.col=2, layout.pos.row=2, height=5))

```

### Inset map

```{r warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}

Londonbb <- st_bbox(Airbnb,
                    crs = st_crs(Airbnb))%>%
  #we need this to convert it into a class of sf
  # otherwise it our bb won't have a class it will just be x and y coordinates for the box
  # this makes it into a polygon
  st_as_sfc()

```


```{r warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}

main <- tm_shape(Airbnb, bbbox = Londonbb) + 
  tm_polygons("Accomodation count",
              breaks=breaks, 
              palette="PuBu")+
  tm_scale_bar(position = c("left", "bottom"), text.size = .75)+
  tm_layout(legend.position = c("right","top"), 
            legend.text.size=.75, 
            legend.title.size = 1.1,
            frame=FALSE)+
  tm_credits("(c) OpenStreetMap contrbutors and Air b n b", position=c(0.0,0.0))+
  #tm_text(text = "NAME", size = .5, along.lines =T, remove.overlap=T,  auto.placement=F)+
  tm_compass(type = "8star", position = c(0.06, 0.1)) +

  #bottom left top right
  tm_layout(inner.margin=c(0.02,0.02,0.02,0.2))
```

```{r warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}

inset = tm_shape(UK_outlinecrop) + tm_polygons() +
  tm_shape(Londonbb)+ 
  tm_borders(col = "grey40", lwd = 3)+
    tm_layout(frame=FALSE,
            bg.color = "transparent")+
  tm_shape(Worldcities2) +
  tm_symbols(col = "red", scale = .5)+
  tm_text("CITY_NAME", xmod=-1.5, ymod=-0.5)
```

```{r warning=FALSE, message=FALSE, out.width = "800pt", cache=FALSE}
library(grid)
main
print(inset, vp = viewport(0.86, 0.29, width = 0.5, height = 0.55))
```

### Export

So how do we output our map then...

```{r eval=FALSE, cache=FALSE}
tmap_save(t, 'hotelsandairbnbR.png')

library(grid)
tmap_save(main,insets_tm = inset,insets_vp=viewport(x=0.86, y=0.29, width=.5, height=.55), filename="test.pdf", dpi=600)
```

### Basic interactive map

But could we not also make an interactive map like we did in practical 2?

```{r message=FALSE, warning=FALSE, cache=FALSE}
tmap_mode("view")

tm_shape(Airbnb) + 
  tm_polygons("Accomodation count", breaks=breaks) 
```

### Advanced interactive map

But let's take it a bit further so we can select our layers on an interactive map..

```{r prac5leaf, message=FALSE, warning=FALSE, cache=FALSE, eval=TRUE}
# library for pop up boxes
library(leafpop)
library(leaflet)

#join data
Joined <- Airbnb%>%
  st_join(., Hotels, join = st_equals)%>%
  dplyr::select(GSS_CODE.x, NAME.x, `Accomodation count.x`, `Accomodation count.y`)%>%
  dplyr::rename(`GSS code` =`GSS_CODE.x`,
                `Borough` = `NAME.x`,
                `Airbnb count` = `Accomodation count.x`,
                `Hotel count`= `Accomodation count.y`)%>%
  st_transform(., 4326)
  
  
#remove the geometry for our pop up boxes to avoid
popupairbnb <-Joined %>%
  st_drop_geometry()%>%
  dplyr::select(`Airbnb count`, Borough)%>%
  popupTable()

popuphotel <-Joined %>%
  st_drop_geometry()%>%
  dplyr::select(`Hotel count`, Borough)%>%
  popupTable()

tmap_mode("view")

# set the colour palettes using our previously defined breaks


pal1 <- Joined %>%
  colorBin(palette = "YlOrRd", domain=.$`Airbnb count`, bins=breaks)

pal1 <-colorBin(palette = "YlOrRd", domain=Joined$`Airbnb count`, bins=breaks)

pal2 <- Joined %>%
  colorBin(palette = "YlOrRd", domain=.$`Hotel count`, bins=breaks)


map<- leaflet(Joined) %>%
  # add basemap options
  addTiles(group = "OSM (default)") %>%
  addProviderTiles(providers$Stamen.Toner, group = "Toner") %>%
  addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "CartoDB")%>%
  
  #add our polygons, linking to the tables we just made
  addPolygons(color="white", 
              weight = 2,
              opacity = 1,
              dashArray = "3",
              popup = popupairbnb,
              fillOpacity = 0.7,
              fillColor = ~pal2(`Airbnb count`),
              group = "Airbnb")%>%
  
  addPolygons(fillColor = ~pal2(`Hotel count`), 
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              popup = popupairbnb,
              fillOpacity = 0.7,group = "Hotels")%>%
  # add a legend
  addLegend(pal = pal2, values = ~`Hotel count`, group = c("Airbnb","Hotel"), 
            position ="bottomleft", title = "Accomodation count") %>%
  # specify layers control
  addLayersControl(
    baseGroups = c("OSM (default)", "Toner", "Toner Lite", "CartoDB"),
    overlayGroups = c("Airbnb", "Hotels"),
    options = layersControlOptions(collapsed = FALSE)
  )

# plot the map
map
```

::: {.infobox .warning data-latex="{note}"}
The legend on this map doesn't update when you select a different layer. I could have enabled this by chaning the `group` argument to just Airbnb or Hotel, then calling a second `addLegend()` function for the other group. However, when displaying maps such as these, it's often useful to have a consistent scale in the legend so they are **directly** comparable. 
:::

If you want to explore Leaflet more have a look at [the leaflet for R Guide](https://rstudio.github.io/leaflet/)

To see other basemap options (there are loads!) have a look here at [leaflet extras](http://leaflet-extras.github.io/leaflet-providers/preview/)


## Bad maps

What makes a bad map then... and what should you avoid:

* Poor labeling --- don't present something as an output with the file name (e.g. layer_1_osm) in the legend --- name your layers properly, it's **really easy** to do and makes a **big** difference to the quality of the map.
* No legend
* Screenshot of the map --- export it properly, we've been doing this a while and can tell
* Change the values in the legend ... what is aesthetically more pleasing 31.99999 or 32?. Make it as easy as possible to interpret your map.
* Too much data presented on one map --- be selective or plot multiple maps
* Presented data is too small or too big --- be critical about what you produce, it should be easy to read and understand
* A map or figure without enough detail --- **A reader should be able to understand a map or figure using the graphic in the figure/map and the caption alone!** A long caption is **fine** assuming it's all relevant information.

For more cartography ideas/advice have a look at [Katie Jolly's blog post on urban heat islands](https://www.katiejolly.io/blog/2019-08-28/nyt-urban-heat), consult [axis map catography guide](https://www.axismaps.com/guide/) and check out the [data is beautiful reddit](https://www.reddit.com/r/dataisbeautiful/).

Another decent resource is the [Fundamentals of Data Visualization book](https://serialmentor.com/dataviz/)

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 

<!--chapter:end:05-prac5.Rmd-->

# (PART) GIS analysis {-}

# Detecting spatial patterns

## Learning outcomes

By the end of this practical you should be able to:

1. Describe and evaluate methods for analysing spatial patterns 
1. Execute data cleaning and manipulation appropairte for analysis 
1. Determine the locations of spatial clusters using point pattern analysis methods

## Homework 

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

For the task this week use the tools you have learnt to start on a relevant practice exam question, **however**, next week we will explore spatial autocorrelation so you are not expected to finish your practice attempt this week.

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

This week: 

* [Chapter 11 "Point Pattern Analysis"](https://mgimond.github.io/Spatial/chp11_0.html) from Intro to GIS and Spatial Analysis by Gimond (2019).

* [Chapter 9 "Hypothesis testing"](https://moderndive.com/9-hypothesis-testing.html) from Modern Dive by Ismay and Kim (2019).

* [Local models for spatial analysis](https://www.vlebooks.com/Product/Index/2028147?page=0) by Lloyd (2010)

* [Using OpenStreetMap point-of-interest data to model urban change—A feasibility study](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0212606) by Zhang and Pfoser (2019).

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::
## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://www.youtube.com/watch?v=hlVBg7_08n0)

[Adam](https://open.spotify.com/album/4OCAtcMneSzQKZGJK95ayo?si=YRtNrsspTF6XpTPRjv2XFg) This week it's the head honcho himself, the man, the legend that is Tony Colman, CEO and founder of Hospital Records --- his new album Building Better Worlds is a masterpiece! Enjoy!  

## Introduction

In this practical you will learn how to begin to analyse patterns in spatial data. Using data you are already familiar with, in the first part of the practical, you will explore some techniques for analysing patterns of point data in R. Then, in the second part of the practial, you will explore spatial autocorrelation using R or ArcGIS...or both if you wish.

In this analysis we will analyse the patterns of Blue Plaques --- you will see these placed on around the UK linking the buildings of the present to people of the past.

The question we want to answer is: **"For any given London Borough, are the Blue Plaques within that borough distributed randomly or do they exhibit some kind of dispersed or clustered pattern?"**

Before we progress, take a minute to go back and refelct on [Grolemund and Wickham's typical workflow of a data science (or GIS) project from workshop 1](#General data flow)

To answer this question, we will make use of some of the Point Pattern Analysis functions found in the `spatstat` package.

```{r Library Initial Packages, message=FALSE, warning=FALSE, cache=FALSE}
#first library a few packages that we will use during the practical
#note you may need to install them first...
library(spatstat)
library(here)
library(sp)
library(rgeos)
library(maptools)
library(tmap)
library(sf)
library(geojson)
library(geojsonio)
library(tmaptools)
```
## Setting up your data

Now, assuming that you've got a copy of your London Boroughs shapefile (from week 1) in your new week 6 folder, along with a shapefile of your Blue Plaques. If not.. read in the data from [the ONS geoportal](http://geoportal.statistics.gov.uk/datasets/8edafbe3276d4b56aec60991cbddda50_2)

```{r, cache=FALSE, message=FALSE, warning=FALSE}
##First, get the London Borough Boundaries
LondonBoroughs <- st_read(here::here("Prac1_data", "statistical-gis-boundaries-london", "ESRI", "London_Borough_Excluding_MHW.shp"))

# Or use this to read in directly.
#LondonBoroughs <- st_read("https://opendata.arcgis.com/datasets/8edafbe3276d4b56aec60991cbddda50_4.geojson")
```

Pull out London using the  `str_detect()` function from the `stringr` package in combination with `filter()` from `dplyr` (again!). We will  look for the bit of the district code that relates to London (E09) from the 'lad15cd' column data frame of our `sf` object. 

```{r cache=FALSE}
library(stringr)
BoroughMap <- LondonBoroughs %>%
  dplyr::filter(str_detect(GSS_CODE, "^E09"))%>%
  st_transform(., 27700)

qtm(BoroughMap)
summary(BoroughMap)
```

Now get the location of all Blue Plaques in the City direct from the web

```{r eval=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
##Now get the location of all Blue Plaques in the City
#BluePlaques <- st_read("https://s3.eu-west-2.amazonaws.com/openplaques/open-plaques-london-2018-04-08.geojson")

```

Or read them in from your project folder.

```{r, message=FALSE, warning=FALSE}
BluePlaques <- st_read(here::here("prac6_data",
                                  "open-plaques-london-2018-04-08.geojson")) %>%
  st_transform(.,27700)
summary(BluePlaques)

#plot the blue plaques in the city
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(BluePlaques) +
  tm_dots(col = "blue")
```

### Data cleaning

Now, you might have noticed that there is at least one Blue Plaque that falls outside of the Borough boundaries. Errant plaques will cause problems with our analysis, so we need to clip the plaques to the boundaries...First we'll remove any Plaques with the same grid reference as this will cause problems later on in the analysis..

```{r, cache=FALSE, warning=FALSE, message=FALSE}
#remove duplicates
library(tidyverse)

library(sf)
BluePlaques <- distinct(BluePlaques)
```
### Spatial subsetting

Now just select the points inside London - thanks to Robin Lovelace for posting how to do this one, very useful! Here, the second operator is blank `, ,` - this controls which attributes are kept, although I'd rather keep all of them and manipulate with the `tidyverse`.

```{r, cache=FALSE, warning=FALSE, message=FALSE}
BluePlaquesSub <- BluePlaques[BoroughMap,]
#check to see that they've been removed
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue")
```

When we spatial subset data like this there are different topological relations we can specify. The default is intersects, but we could also use `BluePlaquesSub <- BluePlaques[BoroughMap, , op = st_within]`, with the operator or op set to `st_within`, to identify points completely within the borough outline, [or a variety of other options](http://postgis.net/workshops/postgis-intro/spatial_relationships.html) such as `st_overlaps`, `st_touches`, `st_contains`, `st_disjoint`. Any possible topological relationship you can think of a function will exist for it...visually this looks like...where each tick denotes the relations that apply to the polygons. Note, that in several cases multiple topological relations would work. 

```{r echo=FALSE, out.width = "600px", fig.align='center', cache=FALSE, fig.cap="Topological relations between vector geometries. Source: [Lovelace et al. 2022](https://geocompr.robinlovelace.net/spatial-operations.html)"}
knitr::include_graphics('prac6_images/relations-1.png') 
```

We can also just use the function which will have the indices of where they intersect.

```{r}
# add sparse=false to get the complete matrix.
intersect_indices <-st_intersects(BoroughMap, BluePlaques)
```

If you have used a graphic user interface GIS before, this is the same as `select by location` (e.g. [select by location in QGIS](https://docs.qgis.org/3.22/en/docs/user_manual/processing_algs/qgis/vectorselection.html#select-by-location)), and as using filter from `dplyr` is the same as `select by attribute`. 

::: {.infobox .warning data-latex="{note}"}
What is the [difference between intersects and within for points like ours?](https://gis.stackexchange.com/questions/345184/st-intersects-vs-st-within/345186#:~:text=ST_Intersects%3A%20https%3A%2F%2Fpostgis.net,of%20space%20then%20they%20intersect.&text=For%20points%2C%20there%20is%20no,do%20the%20same%20with%20lines.)
:::

### Spatial clipping

Whilst on the topic of spatial operations, in a similar theme to topological relations we can also use spatial clipping. This is where we take to layers and extract something. For example, where do the polygons from two different datasets overlap? We want to make a new layer of just the overlapping area...this is somewhat similar to the joins we explored with attribute data (e.g. joining based on a unique attribute column) but here we use shapes...

```{r echo=FALSE, out.width = "600px", fig.align='center', cache=FALSE, fig.cap="Topological relations between vector geometries. Source: [Lovelace et al. 2022](https://geocompr.robinlovelace.net/geometry-operations.html?q=st_intersection#clipping)"}
knitr::include_graphics('prac6_images/venn-clip-1.png') 
```

### Spatial joining

Recall from last week we also touched on spatial joining....well using the same example what if i changed the left dataset (in the left join) to the OSM data. We see that there are 715 rows compared to 712 from last week. This is because the hotels outside London are being included as all data on the left is retained....

```{r, warning=FALSE, message=FALSE}
Londonborough <- st_read(here::here("Prac1_data",
                                    "statistical-gis-boundaries-london", 
                                    "ESRI", 
                                    "London_Borough_Excluding_MHW.shp"))%>%
  st_transform(., 27700)

OSM <- st_read(here::here("prac5_data",
                          "greater-london-latest-free.shp", 
                          "gis_osm_pois_a_free_1.shp")) %>%
  st_transform(., 27700) %>%
  #select hotels only
  filter(fclass == 'hotel')


join_example <-  st_join(OSM, Londonborough)

nrow(join_example)
```

In the example from last week I:

* Loaded in OSM and airbnb data
* Counted it within each London Borough
* Joined the two sf datasets to make one sf object that had the number of hotels and airbnb per borough...specifically this was for the advanced interactive map i made.

Let's get to the point where i joined the two datasets...I've removed some of the other mapping code...

```{r, message=FALSE, warning=FALSE}
OSM <- st_read(here::here("prac5_data",
                          "greater-london-latest-free.shp", 
                          "gis_osm_pois_a_free_1.shp")) %>%
  st_transform(., 27700) %>%
  #select hotels only
  filter(fclass == 'hotel')


#London Borough data is already in 277000
Londonborough <- st_read(here::here("Prac1_data",
                                    "statistical-gis-boundaries-london", 
                                    "ESRI", 
                                    "London_Borough_Excluding_MHW.shp"))%>%
  st_transform(., 27700)

# read in the .csv
# and make it into spatial data

Airbnb <- read_csv("prac5_data/listings.csv") %>%
  st_as_sf(., coords = c("longitude", "latitude"), 
                   crs = 4326) %>%
    st_transform(., 27700)%>%
    #select entire places that are available all year
    filter(room_type == 'Entire home/apt' & availability_365 =='365')


# make a function for the join
# functions are covered in practical 7
# but see if you can work out what is going on
# hint all you have to do is replace data1 and data2
# with the data you want to use

Joinfun <- function(data1, data2){

output<- data1%>%
  st_join(Londonborough,.) %>%
  add_count(GSS_CODE, name="hotels_in_borough") 

  return(output)
}

# use the function for hotels
Hotels <- Joinfun(OSM, Londonborough)

# then for airbnb
Airbnb <- Joinfun(Airbnb, Londonborough)
 
Hotels <- Hotels %>%
  #at the moment each hotel is a row for the borough
  #we just one one row that has number of airbnbs
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))

Airbnb <- Airbnb %>%
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))

```
At this point I have

* `Airbnb` sf object = airbnbs per borough
* `Hotels` sf object = hotels per borough

Now how do i join them? Well i could try and use a `left_join()` but it won't work with spatial data...the error message says to use `st_join()`

```{r, message=FALSE, eval=FALSE}
 left_join<- left_join(Hotels, Airbnb,
            by = c("GSS_CODE" = "GSS_CODE"))
```
Ok, so `st_join()`

```{r, message=FALSE}

all_accomodation <- st_join(Hotels, Airbnb)

head(all_accomodation)
```

Now this produces something that looks wrong, as the first 6 rows are all for the City of London, but recall:

* `st_join` is a left join, here the left table is hotels
* `st_join` uses `st_intersects()` by default. This means for the hotel data, where the airbnb intersects each hotel borough a new row is added. Conceptually, this is the same as a left join  if there are multiple matches (but the matches here are defined by `st_intersects` not a column ID)...
* To further explain this open the `all_accomodation` and look at the `.y` columns, any borough that **intersects** another is added as a row ...

```{r echo=FALSE, out.width = "500px", fig.align='center', cache=FALSE, fig.cap="dplyr::left_join() example with multiple matches. Source: [Tidy explain by Garrick Aden‑Buie](https://www.garrickadenbuie.com/project/tidyexplain/)"}
knitr::include_graphics('prac2_images/left-join-extra.gif') 
```

* To further explain this open the `all_accomodation` and look at the `.y` columns, any borough that **intersects** another is added as a row ...
```{r echo=FALSE, out.width = "600px", fig.align='center', cache=FALSE, fig.cap="st_join example using st_intersects by default"}
knitr::include_graphics('prac6_images/st_join_example.png') 
```


To rectify this we can change the argument to `st_equals()` that returns the data based on the same geometries (or polygons)....

```{r, message=FALSE}

all_accomodation <- st_join(Hotels, Airbnb, join = st_equals)

head(all_accomodation)
```


### Key advice

You don't need to learn all the functions here, but you need to know where to look and essentially the responses to these questions...

Question....do i want to:

* Select points or polygons in a polygon = Selecting data by location = **spatial sub-setting**

* Determine where datasets overlap (or touch, or don't overlap) and extract those parts = **spatial clipping**

* Join two spatial datasets together = **spatial joining**, which can use spatial subsetting functions as the default is `st_intersects()`. This function joins spatial data. 

Finally,

* Selecting data by attributes = filtering or selecting rows / columns with dplyr 

Most of these functions are not R specific, you will find them other software such as PostGIS (a database for spatial data).

::: {.infobox .warning data-latex="{note}"}
What is the difference between `st_intersects()` and `st_intersection()`
:::

### Study area

From this point, we could try and carry out our analysis on the whole of London, but you might be waiting until next week for Ripley's K to be calculated for this many points. Therefore to speed things up and to enable us to compare areas within London, we will select some individual boroughs. First we need to subset our sf object to pull out a borough we are interested in. I'm going to choose Harrow as I know there are few enough points for the analysis to definitely work. If you wish, feel free to choose another borough in London and run the same analysis, but beware that if it happens that there are a lot of blue plaques in your borough, the analysis could fall over!!

```{r, cache=FALSE, warning=FALSE, message=FALSE}
#extract the borough

# select by attribute
Harrow <- BoroughMap %>%
  filter(., NAME=="Harrow")

#Check to see that the correct borough has been pulled out
tm_shape(Harrow) +
  tm_polygons(col = NA, alpha = 0.5)
```

Next we need to clip our Blue Plaques so that we have a subset of just those that fall within the borough or interest

```{r, cache=FALSE}
#clip the data to our single borough
BluePlaquesSub <- BluePlaques[Harrow,]
#check that it's worked
tmap_mode("plot")
tm_shape(Harrow) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue")
```

We now have all of our data set up so that we can start the analysis using `spatstat`. The first thing we need to do is create an observation window for `spatstat` to carry out its analysis within --- we'll set this to the extent of the Harrow boundary

```{r, cache=FALSE, warning=FALSE, message=FALSE}
#now set a window as the borough boundary
window <- as.owin(Harrow)
plot(window)
```

[`spatstat`](https://spatstat.org/) has its own set of spatial objects that it works with (one of the delights of R is that different packages are written by different people and many have developed their own data types) --- it does not work directly with the SpatialPolygonsDataFrames, SpatialPointsDataFrames or `sf` objects that we are used to. For point pattern analysis, we need to create a point pattern (ppp) object.

```{r, cache=FALSE, warning=FALSE, message=FALSE}
#create a sp object
BluePlaquesSub<- BluePlaquesSub %>%
  as(., 'Spatial')
#create a ppp object
BluePlaquesSub.ppp <- ppp(x=BluePlaquesSub@coords[,1],
                          y=BluePlaquesSub@coords[,2],
                          window=window)
```

Try to understand what the different elements in command above is doing. If you are unsure, you can run elements of the code, for example:

```{r, cache=FALSE}
BluePlaquesSub@coords[,1]
```

Have a look at the new ppp object

```{r, cache=FALSE}
BluePlaquesSub.ppp %>%
  plot(.,pch=16,cex=0.5, 
       main="Blue Plaques Harrow")

```

## Point pattern analysis

### Kernel Density Estimation

One way to summarise your point data is to plot the density of your points under a window called a 'Kernel'. The size and shape of the Kernel affects the density pattern produced, but it is very easy to produce a Kernel Density Estimation (KDE) map from a ppp object using the `density()` function.

```{r, cache=FALSE}
BluePlaquesSub.ppp %>%
  density(., sigma=500) %>%
  plot()
```

The sigma value sets the diameter of the Kernel (in the units your map is in --- in this case, as we are in British National Grid the units are in metres). Try experimenting with different values of sigma to see how that affects the density estimate.

```{r, cache=FALSE}
BluePlaquesSub.ppp %>%
  density(., sigma=1000) %>%
  plot()
```

### Quadrat Analysis

So as you saw in the lecture, we are interesting in knowing whether the distribution of points in our study area differs from 'complete spatial randomness' --- CSR. That's different from a CRS! Be careful!

The most basic test of CSR is a quadrat analysis. We can carry out a simple quadrat analysis on our data using the `quadrat count` function in `spatstat`. *Note, I wouldn't recommend doing a quadrat analysis in any real piece of analysis you conduct, but it is useful for starting to understand the Poisson distribution...*

```{r, cache=FALSE}
#First plot the points
plot(BluePlaquesSub.ppp,
     pch=16,
     cex=0.5, 
     main="Blue Plaques in Harrow")

#now count the points in that fall in a 6 x 6
#grid overlaid across the windowBluePlaquesSub.ppp2<-BluePlaquesSub.ppp %>%
BluePlaquesSub.ppp %>%
  quadratcount(.,nx = 6, ny = 6)%>%
    plot(., add=T, col="red")
  
```

In our case here, want to know whether or not there is any kind of spatial patterning associated with the Blue Plaques in areas of London. If you recall from the lecture, this means comparing our observed distribution of points with a statistically likely (Complete Spatial Random) distibution, based on the Poisson distribution. 

Using the same `quadratcount()` function again (for the same sized grid) we can save the results into a table:

```{r, cache=FALSE}
#run the quadrat count
Qcount <- BluePlaquesSub.ppp %>%
  quadratcount(.,nx = 6, ny = 6) %>%
  as.data.frame() %>%
  dplyr::count(Var1=Freq)%>%
  dplyr::rename(Freqquadratcount=n)

```

Check the data type in the first column --- if it is factor, we will need to convert it to numeric

```{r, cache=FALSE}
Qcount %>% 
  summarise_all(class)
```

OK, so we now have a frequency table --- next we need to calculate our expected values. The formula for calculating expected probabilities based on the Poisson distribution is:

$$Pr= (X =k) = \frac{\lambda^{k}e^{-\lambda}}{k!}$$
where:

* `x` is the number of occurrences 

* `λ` is the mean number of occurrences

* `e` is a constant- 2.718

```{r, cache=FALSE}
sums <- Qcount %>%
  #calculate the total blue plaques (Var * Freq)
  mutate(total = Var1 * Freqquadratcount) %>%
  dplyr::summarise(across(everything(), sum))%>%
  dplyr::select(-Var1) 

lambda<- Qcount%>%
  #calculate lambda
  mutate(total = Var1 * Freqquadratcount)%>%
  dplyr::summarise(across(everything(), sum)) %>%
  mutate(lambda=total/Freqquadratcount) %>%
  dplyr::select(lambda)%>%
  pull(lambda)

```


Calculate expected using the Poisson formula from above $k$ is the number of blue plaques counted in a square and is found in the first column of our table...

```{r, cache=FALSE}

QCountTable <- Qcount %>%
  mutate(Pr=((lambda^Var1)*exp(-lambda))/factorial(Var1))%>%
  #now calculate the expected counts based on our total number of plaques
  #and save them to the table
  mutate(Expected= (round(Pr * sums$Freqquadratcount, 0)))

#Compare the frequency distributions of the observed and expected point patterns
plot(c(1,5),c(0,14), type="n",
xlab="Number of Blue Plaques (Red=Observed,Blue=Expected)", 
     ylab="Frequency of Occurances")
points(QCountTable$Freqquadratcount, 
       col="Red", 
       type="o", 
       lwd=3)
points(QCountTable$Expected, col="Blue", 
       type="o", 
       lwd=3)
```
Comparing the observed and expected frequencies for our quadrant counts, we can observe that they both have higher frequency counts at the lower end --- something reminiscent of a Poisson distribution. This could indicate that for this particular set of quadrants, our pattern is close to Complete Spatial Randomness (i.e. no clustering or dispersal of points). But how do we confirm this?

To check for sure, we can use the `quadrat.test()` function, built into `spatstat`. This uses a Chi Squared test to compare the observed and expected frequencies for each quadrant (rather than for quadrant bins, as we have just computed above).

A Chi-Squared test determines if there is an association between two categorical variables. The higher the Chi-Squared value, the greater the difference.

If the p-value of our Chi-Squared test is < 0.05, then we can reject a null hypothesis that says “there is no pattern - i.e. complete spatial randomness - in our data” (think of a null-hypothesis as the opposite of a hypothesis that says our data exhibit a pattern). What we need to look for is a value for p > 0.05. If our p-value is > 0.05 then this indicates that we have CSR and there is no pattern in our points. If it is < 0.05, this indicates that we do have clustering in our points. 

```{r message=FALSE, warning=TRUE, cache=FALSE}

teststats <- quadrat.test(BluePlaquesSub.ppp, nx = 6, ny = 6)

plot(BluePlaquesSub.ppp,pch=16,cex=0.5, main="Blue Plaques in Harrow")
plot(teststats, add=T, col = "red")
```

Here our p-value = 0.2594, implying complete spatial randomness. But there are limitations of using qudrants like this...that we will explore next. 

Note the warning message --- some of the observed counts are very small (0) and this may affect the accuracy of the quadrant test. Recall that the Poisson distribution only describes observed occurrances that are counted in integers --- where our occurrences = 0 (i.e. not observed), this can be an issue. We also know that there are various other problems that might affect our quadrat analysis, such as the [modifiable areal unit problem](https://www.youtube.com/watch?v=cZdlxDx4Nvs).

In the new plot, we can see three figures for each quadrant. The top-left figure is the observed count of points; the top-right is the Poisson expected number of points; the bottom value is the  residual value (also known as Pearson residual value), or (Observed - Expected) / Sqrt(Expected).

::: {.infobox .note data-latex="{note}"}

This is the first mention of the mathematician Karl Pearson who founded the world's first university statistics department here at UCL. Pearson was a eugenicist and the Unversity's first Chair of Eugenics that was established on the request of Galton (who coined the term eugenics and Pearson studied under) for the residue of his estate. Throuhgout research you may encounter Pearson's name as it is used to identify certain techniques, for example, Pearson's product-moment coefficient (alternatively just product-moment coefficient). Where possible within this book I have removed references to Pearson, although as you will see later on some arguments in functions still require the value "pearson" and certain output messages default to include his name. UCL recently [denamed spaces and buildings](https://www.ucl.ac.uk/news/2020/jun/ucl-denames-buildings-named-after-eugenicists?utm_source=UCL%20%28Internal%20Communications%29&utm_medium=email&utm_campaign=11621861_Provost%27s%20View%3A%2019%20June%202020&utm_content=UCL%20News%20denaming%20story) named after Pearson and Galton.
:::

### Try experimenting...

Try running a quadrant analysis for different grid arrangements (2 x 2, 3 x 3, 10 x 10 etc.) --- how does this affect your results?

### Ripley's K

One way of getting around the limitations of quadrat analysis is to compare the observed distribution of points with the Poisson random model for a whole range of different distance radii. This is what Ripley's K function computes. 

We can conduct a Ripley's K test on our data very simply with the `spatstat` package using the `kest()` function. 

```{r, cache=FALSE}
K <- BluePlaquesSub.ppp %>%
  Kest(., correction="border") %>%
  plot()

Kval <- as.data.frame(Kest(BluePlaquesSub.ppp, correction = "Ripley"))

```
Ripley's K is defined as...

 $$K(r) = \lambda^{-1} \sum{i}\sum{j}\frac{I(d_ij<r)}{n}$$

* In English: Ripley’s K value for any circle radius $r$ = 

  * The average density of points for the **entire study region (of all locations)** $\lambda = (n/ \Pi r^2))$

  * Multiplied by the sum of the distances $d_ij$ between all points within that search radius, see [Dixon page 2](https://www3.nd.edu/~mhaenggi/ee87021/Dixon-K-Function.pdf) and [Amgad et al. 2015](file:///C:/Users/Andy/Downloads/Extending_Ripleys_K-Function_to_Quantify_Aggregat%20(1).pdf)

  * Divided by the total number of points, n

  * I = 1 or 0 depending if $d_ij < r$

The plot for K has a number of elements that are worth explaining. First, the *Kpois(r)* line in Red is the theoretical value of K for each distance window (r) under a Poisson assumption of Complete Spatial Randomness. The Black line is the estimated values of K accounting for the effects of the edge of the study area. 

Here, the correction specifies how points towards the edge are dealt with, in this case, border means that points towards the edge are ignored for the calculation but are included for the central points. [Section 2.1, here](https://www.statistics.gov.hk/wsc/IPS031-P2-S.pdf) explains the different options.

Where the value of K falls above the line, the data appear to be clustered at that distance. Where the value of K is below the line, the data are dispersed. From the graph, we can see that up until distances of around 1300 metres, Blue Plaques appear to be clustered in Harrow, however, at around 1500 m, the distribution appears random and then dispersed between about 1600 and 2100 metres. 

### Alternatives to Ripley's K

There are a number of alternative measures of spatial clustering which can be computed in `spatstat` such as the G and the L functions --- I won't go into them now, but if you are interested, you should delve into the following references:

* Bivand, R. S., Pebesma, E. J., & Gómez-Rubio, V. (2008). "Applied spatial data analysis with R." New York: Springer.

* Brundson, C., Comber, L. (2015) "An Introduction to R for Spatial Analysis & Mapping". Sage.

* Baddeley, A. (2010) ["Analysing spatial point patterns in R"](https://research.csiro.au/software/wp-content/uploads/sites/6/2015/02/Rspatialcourse_CMIS_PDF-Standard.pdf)

## Density-based spatial clustering of applications with noise: DBSCAN

Quadrat and Ripley's K analysis are useful exploratory techniques for telling us if we have spatial clusters present in our point data, but they are not able to tell us WHERE in our area of interest the clusters are occurring. To discover this we need to use alternative techniques. One popular technique for discovering clusters in space (be this physical space or variable space) is DBSCAN. For the complete overview of the DBSCAN algorithm, read the original paper by [Ester et al. (1996)](http://www.aaai.org/Papers/KDD/1996/KDD96-037.pdf) 
or consult the [wikipedia page](https://en.wikipedia.org/wiki/DBSCAN)

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(raster)
library(fpc)
```

We will now carry out a DBSCAN analysis of blue plaques in my borough to see if there are any clusters present.

```{r, cache=FALSE, message=FALSE, warning=FALSE}
#first check the coordinate reference system of the Harrow spatial polygon:
st_geometry(BoroughMap)
```
DBSCAN requires you to input two parameters:
1. *Epsilon* - this is the radius within which the algorithm with search for clusters
2. *MinPts* - this is the minimum number of points that should be considered a cluster

Based on the results of the Ripley's K analysis earlier, we can see that we are getting clustering up to a radius of around 1200m, with the largest bulge in the graph at around 700m. Therefore, 700m is probably a good place to start and we will begin by searching for clusters of at least 4 points...

```{r, cache=FALSE}
#first extract the points from the spatial points data frame
BluePlaquesSubPoints <- BluePlaquesSub %>%
  coordinates(.)%>%
  as.data.frame()

#now run the dbscan analysis
db <- BluePlaquesSubPoints %>%
  fpc::dbscan(.,eps = 700, MinPts = 4)

#now plot the results
plot(db, BluePlaquesSubPoints, main = "DBSCAN Output", frame = F)
plot(BoroughMap$geometry, add=T)
```
You could also use ```kNNdistplot()``` from the ```dbscan``` pacakge to find a suitable eps value based on the 'knee' in the plot... 

```{r eval=FALSE}
# used to find suitable eps value based on the knee in plot
# k is no of nearest neighbours used, use min points
library(dbscan)

BluePlaquesSubPoints%>%
  dbscan::kNNdistplot(.,k=4)
```

This plot shows for each point the average distance to the k neighbours, which are then plotted in ascending order. The knee is where this value (of distance to neighbours) increases. See [this article from Data Novia](https://www.datanovia.com/en/lessons/dbscan-density-based-clustering-essentials/) for more information on this

So the DBSCAN analysis shows that for these values of eps and MinPts there are three clusters in the area I am analysing. Try varying eps and MinPts to see what difference it makes to the output. 

Now of course the plot above is a little basic and doesn't look very aesthetically pleasing. As this is R and R is brilliant, we can always produce a much nicer plot by extracting the useful information from the DBSCAN output and use ```ggplot2``` to produce a much cooler map...

```{r, cache=FALSE}
library(ggplot2)
```

Our new db object contains lots of info including the cluster each set of point coordinates belongs to, whether the point is a seed point or a border point etc. We can get a summary by just calling the object

```{r, cache=FALSE}
db
```

If you open up the object in the environment window in RStudio, you will also see the various slots in the object, including cluster

```{r, cache=FALSE}
db$cluster
```

We can now add this cluster membership info back into our dataframe

```{r, cache=FALSE}
BluePlaquesSubPoints<- BluePlaquesSubPoints %>%
  mutate(dbcluster=db$cluster)
```

Next we are going to create some convex hull polygons to wrap around the points in our clusters.

```{r, cache=FALSE}
chulls <- BluePlaquesSubPoints %>%
  group_by(dbcluster) %>%
  dplyr::mutate(hull = 1:n(),
  hull = factor(hull, chull(coords.x1, coords.x2)))%>%
  arrange(hull)

#chulls2 <- ddply(BluePlaquesSubPoints, .(dbcluster), 
              #  function(df) df[chull(df$coords.x1, df$coords.x2), ])

```

As 0 isn't actually a cluster (it's all points that aren't in a cluster) drop it from the dataframe

```{r, cache=FALSE}
chulls <- chulls %>%
  filter(dbcluster >=1)
```

Now create a ```ggplot2``` object from our data

```{r, cache=FALSE}
dbplot <- ggplot(data=BluePlaquesSubPoints, 
                 aes(coords.x1,coords.x2, colour=dbcluster, fill=dbcluster)) 
#add the points in
dbplot <- dbplot + geom_point()
#now the convex hulls
dbplot <- dbplot + geom_polygon(data = chulls, 
                                aes(coords.x1,coords.x2, group=dbcluster), 
                                alpha = 0.5) 
#now plot, setting the coordinates to scale correctly and as a black and white plot 
#(just for the hell of it)...
dbplot + theme_bw() + coord_equal()
```

Now we are getting there, but wouldn't it be better to add a basemap?!

```{r Harrow bbox, fig.height=2, fig.width=2, message=TRUE, warning=TRUE, cache=FALSE, paged.print=TRUE}
###add a basemap
##First get the bbox in lat long for Harrow
HarrowWGSbb <- Harrow %>%
  st_transform(., 4326)%>%
  st_bbox()
```

Now convert the basemap to British National Grid

```{r, cache=FALSE, message=FALSE, warning=FALSE}
library(OpenStreetMap)

basemap <- OpenStreetMap::openmap(c(51.5549876,-0.4040502),c(51.6405356,-0.2671315),
                         zoom=NULL,
                         "osm")

  # convert the basemap to British National Grid
basemap_bng <- openproj(basemap, projection="+init=epsg:27700")
```
Now we can plot our fancy map with the clusters on...

```{r, cache=FALSE}
#autoplot(basemap_bng) sometimes works
autoplot.OpenStreetMap(basemap_bng)+ 
  geom_point(data=BluePlaquesSubPoints, 
             aes(coords.x1,coords.x2, 
                 colour=dbcluster, 
                 fill=dbcluster)) + 
  geom_polygon(data = chulls, 
               aes(coords.x1,coords.x2, 
                   group=dbcluster,
                   fill=dbcluster), 
               alpha = 0.5)  

```

## Point pattern analysis summary

This is end of the point pattern analysis section of the practical. You have  been introduced to the basics of Point Pattern Analysis examining the distribution of Blue Plaques in a London Borough. At this point, you may wish to try running similar analyses on different boroughs (or indeed the whole city) and playing with some of the outputs --- although you will find that Ripley's K will fall over very quickly if you try to run the analysis on that many points) 

This how you might make use of these techniques in another context or with different point data...

<!--chapter:end:06-prac6.Rmd-->

# Spatial autocorrelation

## Learning outcomes

By the end of this practical you should be able to:

1. Execute data cleaning and manipulation appropriate for analysis 
1. Explain and implement different models for spatial relationships (e.g. spatial weights)
1. Investigate the degree to which values at spatial points are similar (or different) to each other
1. Interpret the meaning of spatial autocorrleation in spatial data

## Homework 

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

::: {.infobox .assignment data-latex="{note}"}
**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

For the task this week complete the practice exam question you started last week with the new tools you have learnt.

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

This week:

* [What Problem? Spatial Autocorrelation and Geographic Information Science](https://onlinelibrary.wiley.com/doi/10.1111/j.1538-4632.2009.00769.x) by Goodchild (2009).

* [Chapter 13 "Spatial Autocorrelation"](https://mgimond.github.io/Spatial/spatial-autocorrelation.html) from Intro to GIS and Spatial Analysis by Gimond (2019).

* [Spatial Point Pattern Analysis and Its Application in Geographical Epidemiology](https://www.jstor.org/stable/pdf/622936.pdf) by Gatrell et al. (1996)

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.
:::
## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://www.youtube.com/watch?v=hlVBg7_08n0)

[Adam](https://open.spotify.com/album/4OCAtcMneSzQKZGJK95ayo?si=YRtNrsspTF6XpTPRjv2XFg) This week it's the head honcho himself, the man, the legend that is Tony Colman, CEO and founder of Hospital Records --- his new album Building Better Worlds is a masterpiece! Enjoy!  

## Introduction

### Analysing Spatial Autocorrelation with Moran's I, LISA and friends

In this section we are going to explore patterns of spatially referenced continuous observations using various measures of spatial autocorrelation. Spatial autocorrelation is a measure of similarity between nearby data. Check out the various references in the reading list for more information about the methods we will explore today. There are also useful links in the help file of the `spdep` package which we will be using here.

This week my question might be **Are the values (in this case the density of blue plaques) similar (or dissimilar) across the wards of London**

### Data download

Before we get any further, let's get some ward boundaries read in to R --- download LondonWardData from [the London Data store](https://data.london.gov.uk/dataset/statistical-gis-boundary-files-london) and read it in...

**Use the data in the statistical-gis-boundaries-london.zip**

```{r, cache=FALSE, message=FALSE, warning=FALSE}
library(here)
library(janitor)
library(sf)
library(tidyverse)
#read the ward data in
LondonWards <- st_read(here::here("prac6_data", "LondonWards.shp"))

LondonWardsMerged <- st_read(here::here("prac6_data", 
                                        "statistical-gis-boundaries-london", 
                                        "statistical-gis-boundaries-london", 
                                        "ESRI",
                                        "London_Ward_CityMerged.shp"))%>%
  st_transform(.,27700)
WardData <- read_csv("https://data.london.gov.uk/download/ward-profiles-and-atlas/772d2d64-e8c6-46cb-86f9-e52b4c7851bc/ward-profiles-excel-version.csv",
                    locale = locale(encoding = "latin1"),
                     na = c("NA", "n/a")) %>% 
  clean_names()

LondonWardsMerged <- LondonWardsMerged %>% 
  left_join(WardData, 
            by = c("GSS_CODE" = "new_code"))%>%
  dplyr::distinct(GSS_CODE, .keep_all = T)%>%
  dplyr::select(GSS_CODE, ward_name, average_gcse_capped_point_scores_2014)
  
```

It's probably projected correctly, but in case it isn't give it a projection using the ```st_crs()``` function in the ```sf``` package

```{r, cache=FALSE, message=FALSE, warning=FALSE}
#have a look to check that it's 
#in the right projection
st_crs(LondonWardsMerged)
```

Always plot the data to check it looks reasonable (e.g. there are no points in other countries / the latitude and longitude are correct)

```{r, cache=FALSE, message=FALSE, warning=FALSE}

library(tmap)

BluePlaques <- st_read(here::here("prac6_data",
                                  "open-plaques-london-2018-04-08.geojson")) %>%
    st_transform(.,27700)

tmap_mode("plot")
tm_shape(LondonWardsMerged) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(BluePlaques) +
  tm_dots(col = "blue")
```

## Data cleaning 

Ah yes, we might need to lose the blue plaques that fall outside of London

```{r, cache=FALSE}
summary(BluePlaques)
BluePlaquesSub <- BluePlaques[LondonWardsMerged,]

tm_shape(LondonWardsMerged) +
  tm_polygons(col = NA, alpha = 0.5) +
tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue")
```

## Data manipulation 

The measures of spatial autocorrelation that we will be using require continuous observations (counts of blue plaques, average GCSE scores, average incomes etc.) to be spatially referenced (i.e. attached to a spatial unit like a ward or a borough). The file you have already has the various obervations associated with the London Ward data file already attached to it, but let's continue with our blue plaques example for now. 

To create a continuous observation from the blue plaques data we need to count all of the blue plaques that fall within each Ward in the City. Luckily, we can do this using the ```st_intersects()``` function from the `sf` package.

```st_intersects()``` will return a list of which points (plaques) are in each polygon (wards). So each row will be a polygon and the ID are the point IDs that intersect the polygon.

In this case we don't want to use `st_join()` (which by default uses `st_intersects()`) as `st_join()` is like a left join and will retain all the data in on the left. So if a ward is empty, there will still be a row for that ward. So, we use `st_intersects()` on its own. We could also use other topological relationship functions such as `st_within()` instead...

```{r echo=TRUE, results='hide', cache=FALSE}
example<-st_intersects(LondonWardsMerged, BluePlaquesSub)

example

```

Here the polygon with the ID of 6 Kingston upon Thames - Coombe Hill has three plaques within it...we can check this with st_join (or using QGIS by opening the data)...we have three plaques...But note the ID column added is different to the ID of the data...open blueplaques from the environment window and you will see the IDs that were returned in `st_intersects()`.

```{r}
check_example <- LondonWardsMerged%>%
  st_join(BluePlaquesSub)%>%
  filter(ward_name=="Kingston upon Thames - Coombe Hill")
```

Now we just take the length of each list per polygon and add this as new column...

```{r echo=TRUE, results='hide', cache=FALSE}
library(sf)
points_sf_joined <- LondonWardsMerged%>%
  mutate(n = lengths(st_intersects(., BluePlaquesSub)))%>%
  janitor::clean_names()%>%
  #calculate area
  mutate(area=st_area(.))%>%
  #then density of the points per ward
  mutate(density=n/area)%>%
  #select density and some other variables 
  dplyr::select(density, ward_name, gss_code, n, average_gcse_capped_point_scores_2014)

```

How about a quick choropleth map to see how we are getting on...

```{r, cache=FALSE}

points_sf_joined<- points_sf_joined %>%                    
  group_by(gss_code) %>%         
  summarise(density = first(density),
          wardname= first(ward_name),
          plaquecount= first(n))

tm_shape(points_sf_joined) +
    tm_polygons("density",
        style="jenks",
        palette="PuOr",
        midpoint=NA,
        popup.vars=c("wardname", "density"),
        title="Blue Plaque Density")
```

So, from the map, it looks as though we might have some clustering of blue plaques in the centre of London so let's check this with Moran's I and some other statistics. 

## Weight matrix

Before being able to calculate Moran's I and any similar statistics, we need to first define a \(W_{ij}\) spatial weights matrix

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(spdep)
```

First calculate the centroids of all Wards in London

```{r message=FALSE, warning=FALSE, cache=FALSE}
#First calculate the centroids of all Wards in London

coordsW <- points_sf_joined%>%
  st_centroid()%>%
  st_geometry()
  
plot(coordsW,axes=TRUE)

```

Now we need to generate a spatial weights matrix (remember from the lecture). We'll start with a simple binary matrix of queen's case neighbours (otherwise known as Contiguity edges corners). This method means that polygons with a shared  edge or a corner will be included in computations for the target polygon...A **spatial weight matrix represents the spatial element of our data**, this means we are trying to conceptualize and model how parts of the data are linked (or not linked) to each other spatially, using rules that we will set. 

**A note on spatial weight matrices**

If the features share a boundary they are **contiguous**, this can also be classed as only common boundaries --- a **rook** (like chess a rook can move forwards or side wards) or any point in common (e.g. corners / other boundaries) --- a **queen** (like chess a queen can move forwards, backwards or on a diagonal).


```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="Source: [Manuel S. Gonzalez Canche](https://rpubs.com/msgc/matrices_influence)"}
knitr::include_graphics('prac6_images/weights.png')
```

**Alternatively** instead of using contiguous relationships you can use **distance** based relationships. This is frequently done with k nearest neighbours in which k is set to the closest observations. e.g. K=3 means the three closest observations. 

In the first instance we must create a neighbours list --- which is a list of all the neighbours. To do so we will use `poly2nb()` with the argument `queen=T` saying we want a to use Queens case. Let's see a summary of the output

```{r message=FALSE, warning=FALSE, cache=FALSE}
#create a neighbours list
LWard_nb <- points_sf_joined %>%
  poly2nb(., queen=T)

```

The output is a neighbour list object hence why i've called the object `LWard_nb`. We can get some summary info and plot the matrix.

```{r message=FALSE, warning=FALSE, cache=FALSE}
summary(LWard_nb)
```
Here it is telling us that the average number of neighbours is 5.88. Now let's plot the neighbours.

```{r message=FALSE, warning=FALSE, cache=FALSE}
#plot them
plot(LWard_nb, st_geometry(coordsW), col="red")
#add a map underneath
plot(points_sf_joined$geometry, add=T)
```

### Matrix style

From the weights list we must now make a spatial weight matrix. This makes a matrix the size of the number of neighbourhoods with values indicating if the elements in the rows are a neighbour or not. The style of weight is especially important here:

* B is the basic binary coding (1/0)
* W is **row** standardised (sums over all links to n)
* C is **globally** standardised (sums over all links to n)
* U is equal to C divided by the number of neighbours (sums over all links to unity)
* S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).

To understand this further let's start with binary. 

```{r message=FALSE, warning=FALSE, cache=FALSE}
#create a spatial weights matrix from these weights
Lward.lw <- LWard_nb %>%
  nb2mat(., style="B")

sum(Lward.lw)
```
Summing the binary (1/0) shows that we have 3680 neighbours. Now if we were to do **global** standardisation this would mean dividing our 625 wards by the total number of neighbours meaning each spatial weight has a value of 0.169.

Alternatively we can do **row** standardisation where 1 is divided by the sum of the number of neighbours in each row. For example, row 1 here sums to 6, meaning each weight would be 0.166 in row 1 only.

```{r message=FALSE, warning=FALSE, cache=FALSE}
sum(Lward.lw[1,])
```
Standardisation permits comparable spatial parameters. But you also need to consider geographical features --- should a neighbour be a neighbour if there is a river between them?

## Autocorrelation

Now we have defined our \(W_{ij}\) matrix, we can calculate the Moran's I and other associated statistics. However, Moran's I requires a spatial weight **list** type object as opposed to **matrix**, this is simply...

```{r message=FALSE, warning=FALSE, cache=FALSE}
Lward.lw <- LWard_nb %>%
  nb2listw(., style="C")
```

### Moran's I

Moran's I test tells us whether we have clustered values (close to 1) or dispersed values (close to -1), we will calculate for the densities rather than raw values (think about why this is?). 

```{r, cache=FALSE}
I_LWard_Global_Density <- points_sf_joined %>%
  pull(density) %>%
  as.vector()%>%
  moran.test(., Lward.lw)

I_LWard_Global_Density
```

### Geary's C

Geary's C as well..? This tells us whether similar values or dissimilar values are clustering

```{r, cache=FALSE}
C_LWard_Global_Density <- 
  points_sf_joined %>%
  pull(density) %>%
  as.vector()%>%
  geary.test(., Lward.lw)

C_LWard_Global_Density
```

### Getis Ord

Getis Ord General G...? This tells us whether high or low values are clustering. If G > Expected = High values clustering; if G < expected = low values clustering

```{r, cache=FALSE}
G_LWard_Global_Density <- 
  points_sf_joined %>%
  pull(density) %>%
  as.vector()%>%
  globalG.test(., Lward.lw)

G_LWard_Global_Density
```

So the global statistics are indicating that we have spatial autocorrelation of Blue Plaques in London:

### Summary

The Moran's I statistic = 0.67 (remember 1 = clustered, 0 = no pattern, -1 = dispersed) which shows that we have some distinctive clustering

The Geary's C statistic = 0.41 (remember Geary's C falls between 0 and 2; 1 means no spatial autocorrelation, <1 - positive spatial autocorrelation or similar values clustering, >1 - negative spatial autocorreation or dissimilar values clustering) which shows that similar values are clustering

The General G statistic = G > expected, so high values are tending to cluster. 

### Local Moran's I 

We can now also calculate local versions of the Moran's I statistic (for each Ward) and a Getis Ord \(G_{i}^{*}\) statistic to see *where* we have hot-spots...

Local Moran's I is:

* The difference between a value and neighbours * the sum of differences between neighbours and the mean
* Where the the difference between a value and neighbours is divided by the standard deviation (how much values in neighbourhood vary about the mean)

It returns several columns, of most interest is the Z score. A Z-score is **how many standard deviations a value is away (above or below) from the mean**. This allows us to state if our value is significantly different than expected value at this location considering the neighours. 

We are comparing our value of Moran's I to that of an expected value (computed from a separate equation that uses the spatial weight matrix, and therefore considers the neighbouring values). We are expecting our value of Moran's I to be in the middle of the distribution of the expected values. These expected values follow a normal distribution, with the middle part representing complete spatial randomness. This is **typically** between < -1.65 or > +1.65 standard deviations from the mean  

The **null hypothesis** is always there is complete spatial randomness. A null hypothesis means:

>  no statistical significance exists in a set of given observations

If our value is towards the tails of the distribution then it is unlikely that the value is completely spatially random and we can reject the null hypothesis...as it is not what we expect at this location.

In the example where we use a z-score of >2.58 or <-2.58 we interpret this as...

...> 2.58 or <-2.58 standard deviations away from the mean are significant at the 99% level...this means there is a <1% chance that autocorrelation is not present

The [Global vs location spatial autocorrelation resource](https://storymaps.arcgis.com/stories/5b26f25bb81a437b89003423505e2f71) goes through the specific formulas here, but the most important parts are knowing

* What we are comparing values to in Local Moran's I
* What the results mean 
* Why the results could be important

```{r, cache=FALSE}
#use the localmoran function to generate I for each ward in the city

I_LWard_Local_count <- points_sf_joined %>%
  pull(plaquecount) %>%
  as.vector()%>%
  localmoran(., Lward.lw)%>%
  as_tibble()

I_LWard_Local_Density <- points_sf_joined %>%
  pull(density) %>%
  as.vector()%>%
  localmoran(., Lward.lw)%>%
  as_tibble()

#what does the output (the localMoran object) look like?
slice_head(I_LWard_Local_Density, n=5)
```

There are 5 columns of data. We want to copy some of the columns (the I score (column 1) and the z-score standard deviation (column 4)) back into the LondonWards spatialPolygonsDataframe

```{r, cache=FALSE}
points_sf_joined <- points_sf_joined %>%
  mutate(plaque_count_I = as.numeric(I_LWard_Local_count$Ii))%>%
  mutate(plaque_count_Iz =as.numeric(I_LWard_Local_count$Z.Ii))%>%
  mutate(density_I =as.numeric(I_LWard_Local_Density$Ii))%>%
  mutate(density_Iz =as.numeric(I_LWard_Local_Density$Z.Ii))
```

#### Mapping 

No we can plot a map of the local Moran's I outputs...

We'll set the breaks manually based on the rule that data points >2.58 or <-2.58 standard deviations away from the mean are significant at the 99% level (<1% chance that autocorrelation not present); >1.96 - <2.58 or <-1.96 to >-2.58 standard deviations are significant at the 95% level (<5% change that autocorrelation not present). >1.65 = 90% etc.

```{r, cache=FALSE}
breaks1<-c(-1000,-2.58,-1.96,-1.65,1.65,1.96,2.58,1000)
```

Now create a new diverging colour brewer palette and reverse the order using `rev()` (reverse) so higher values correspond to red

```{r, cache=FALSE}
library(RColorBrewer)
MoranColours<- rev(brewer.pal(8, "RdGy"))
```

Plot on an interactive map

```{r, cache=FALSE}
tm_shape(points_sf_joined) +
    tm_polygons("plaque_count_Iz",
        style="fixed",
        breaks=breaks1,
        palette=MoranColours,
        midpoint=NA,
        title="Local Moran's I, Blue Plaques in London")
```

This map shows some areas in the centre of London that have relatively high scores, indicating areas with lots of blue plaques neighbouring other areas with lots of blue plaques.

### Local Getis Ord \(G_{i}^{*}\) 

What about the Getis Ord \(G_{i}^{*}\) statistic for hot and cold spots...

This is a very similar concept to Local Moran's I except it just returns a z-score...remember that a z-score  shows **how many standard deviations a value (our value) is away (above or below) from the mean (of the expected values)**

Ultimately a z-score is defined as:

 $$Z = \frac{x-\mu}{\sigma}$$
Where:

* $x$ = the observed value
* $\mu$ = the mean of the sample
* $\sigma$ = standard deviation of sample

**Note**, consult the [Global vs location spatial autocorrelation resource](https://storymaps.arcgis.com/stories/5b26f25bb81a437b89003423505e2f71) for how this is computed in Local Moran's I if you are interested, although interpretation is the most important part here.

**However**, in the case of Getis Ord \(G_{i}^{*}\) this is the local sum (of the neighbourhood) compared to the sum of all features

In Moran's I this is just the value of the spatial unit (e.g. polygon of the ward) compared to the neighbouring units.

Here, to be significant (or a hot spot) we will have a high value surrounded by high values. The local sum of these values will be different to the expected sum (think of this as all the values in the area) then where this difference is large we can consider it to be not by chance...

The same z-score criteria then applies as before..

This summary from L3 Harris nicely summaries the Getis Ord \(G_{i}^{*}\) output...

> The result of Getis Ord \(G_{i}^{*}\) analysis is an array of Z-scores, one for each pixel [or polygon], which is the number of standard deviations that the pixel [or polygon] and its neighbors are from the global mean. High Z-scores indicate more intense clustering of high pixel values, indicating hot spots. Low Z-scores indicate more intense clustering of low values, indicating cold spots. Individual pixels with high or low values by themselves might be interesting but not necessarily significant.

```{r, cache=FALSE}
Gi_LWard_Local_Density <- points_sf_joined %>%
  pull(density) %>%
  as.vector()%>%
  localG(., Lward.lw)

head(Gi_LWard_Local_Density)

```

Check the help file  (?localG) to see what a localG object looks like 

**Note** that because of the differences in Moran's I and Getis Ord \(G_{i}^{*}\) there will be differences between polyogons that are classed as significant. 

Add the Getis Ord \(G_{i}^{*}\) data to the simple feature...

```{r, cache=FALSE}
points_sf_joined <- points_sf_joined %>%
  mutate(density_G = as.numeric(Gi_LWard_Local_Density))
```

And map the outputs...

```{r, cache=FALSE}
library(RColorBrewer)

GIColours<- rev(brewer.pal(8, "RdBu"))

#now plot on an interactive map
tm_shape(points_sf_joined) +
    tm_polygons("density_G",
        style="fixed",
        breaks=breaks1,
        palette=GIColours,
        midpoint=NA,
        title="Gi*, Blue Plaques in London")

```

## Other variables

The local Moran's I and \(G_{i}^{*}\) statistics for wards clearly show that the density of blue plaques in the centre of the city exhibits strong (and positive) spatial autocorrelation, but neither of these maps are very interesting. Why not try some alternative variables and see what patterns emerge... here I'm going to have a look at Average GSCE scores...

```{r, cache=FALSE}
#use head to see what other variables are in the data file

slice_head(points_sf_joined, n=2)
```

Or print out the class of each column like we did in week 2, although we need to drop the geometry. 

```{r}
Datatypelist <- LondonWardsMerged %>% 
  st_drop_geometry()%>%
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist
```


```{r, echo=TRUE, eval=FALSE, cache=FALSE}

I_LWard_Local_GCSE <- LondonWardsMerged %>%
  arrange(GSS_CODE)%>%
  pull(average_gcse_capped_point_scores_2014) %>%
  as.vector()%>%
  localmoran(., Lward.lw)%>%
  as_tibble()

points_sf_joined <- points_sf_joined %>%
  arrange(gss_code)%>%
  mutate(GCSE_LocIz = as.numeric(I_LWard_Local_GCSE$Z.Ii))


tm_shape(points_sf_joined) +
    tm_polygons("GCSE_LocIz",
        style="fixed",
        breaks=breaks1,
        palette=MoranColours,
        midpoint=NA,
        title="Local Moran's I, GCSE Scores")
```

Now the Gi* statistic to look at clusters of high and low scores and explain what the output map is showing and what other questions this can lead us to ask next week.....

```{r, cache=FALSE}

G_LWard_Local_GCSE <- LondonWardsMerged %>%
  dplyr::arrange(GSS_CODE)%>%
  dplyr::pull(average_gcse_capped_point_scores_2014) %>%
  as.vector()%>%
  localG(., Lward.lw)

points_sf_joined <- points_sf_joined %>%
  dplyr::arrange(gss_code)%>%
  dplyr::mutate(GCSE_LocGiz = as.numeric(G_LWard_Local_GCSE))

tm_shape(points_sf_joined) +
    tm_polygons("GCSE_LocGiz",
        style="fixed",
        breaks=breaks1,
        palette=GIColours,
        midpoint=NA,
        title="Gi*, GCSE Scores")

```

So this is the end of the practical. Hopefully you have learned a lot about the different methods we can employ to analyse patterns in spatial data. 

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 

<!--chapter:end:07-prac7.Rmd-->

# Explaining spatial patterns

## Learning objectives

By the end of this practical you should be able to:

1. Explain hypothesis testing
1. Execute regression in R
1. Describe the assumptions associated with regression models 
1. Explain steps to deal with spatially autocorrelated (spatial similarity of nearby observations) residuals.  

## Homework 

::: {.infobox .assignment data-latex="{note}"}

Outside of our scheduled sessions you should be doing around 12 hours of extra study per week. Feel free to follow your own GIS interests, but good places to start include the following:

**Exam**

Each week we will provide a short task to test your knowledge, these should be used to guide your study for the final exam.

For the task this week have a go at the practice exam questions, you should be able to answer either of the following questions:

* New York Eviction
* Graffiti mitigation

The actual exam will be distributed using the same format, so it's vital to do this.

:::

::: {.infobox .note data-latex="{note}"}
**Reading**

This week:

* [Chapter 2 "Linear Regression"](https://bradleyboehmke.github.io/HOML/linear-regression.html#ref-faraway-2016-linear) from Hands-On Machine Learning with R by Boehmke & Greenwell (2020).

* [Chapter 7 "Linear Regression"](https://argoshare.is.ed.ac.uk/healthyr_book/chap07-h1.html) from R for Health Data Science by Ewen Harrison and Riinu Pius (2021). **This chapter is excellent, especially section 7.1**.

* [Chapter 5 and 6 "Basic Regression and "Multiple Regression"](https://moderndive.com/5-regression.html) from Modern Dive by Ismay and Kim (2019).

* [Chapter 9 Spatial regression models](https://maczokni.github.io/crime_mapping_textbook/spatial-regression-models.html) from Crime Mapping in R by Juanjo Medina and Reka Solymosi (2019).

* [Introduction to Research Methods](https://bookdown.org/ejvanholm/Textbook/) by Eric van Holm, 2021. Chapters on regression and spatial regression

* [GWR a road map](https://onlinelibrary.wiley.com/doi/full/10.1111/gean.12316) by Comber et al. 2022.There are related papers that have added to this discussion, such as:
  * [Taylor Oshan](https://onlinelibrary.wiley.com/doi/full/10.1111/gean.12345)
  * [Levi Wolf](https://onlinelibrary.wiley.com/doi/10.1111/gean.12346)

Remember this is just a starting point, explore the [reading list](https://rl.talis.com/3/ucl/lists/139FBAF8-DACD-60FB-8BDC-E9C9E09BA885.html?lang=en-GB&login=1), practical and lecture for more ideas.

**Doing**

*  Read through the start of [MLU Linear Regression](https://mlu-explain.github.io/linear-regression/), until learning the coefficients, which goes beyond the course here. 

* If you need a refresher/into to summary stats go through [Teacup Giraffes](https://tinystats.github.io/teacups-giraffes-and-statistics/02_bellCurve.html)

:::

## Recommended listening `r emo::ji("headphones")`

Some of these practicals are long, take regular breaks and have a listen to some of our fav tunes each week.

[Andy](https://open.spotify.com/album/6NtEjhPWfZcvJQuvjGX4bk) Haim. Can all play loads of instuments and just switch during live sets. 

[Adam](https://open.spotify.com/album/6EO1grYN4T3D6HQpBdp3Ad) Music this week - time for some big, dirty rock and roll. The Wildhearts have only gone and released a massive live album - oh yes!

## Introduction

In this practical you will be introduced to a suite of different models that will allow you to test a variety of research questions and hypotheses through modelling the associations between two or more spatially reference variables. 

In the worked example, we will explore the factors that might affect the average exam scores of 16 year-old across London. GSCEs are the exams taken at the end of secondary education and here have been aggregated for all pupils at their home addresses across the City for Ward geographies. 

The London Data Store collates a range of other variables for each Ward and so we will see if any of these are able to help explain the patterns of exam performance that we see.

This practical will walk you through the common steps that you should go through when building a regression model using spatial data to test a stated research hypothesis; from carrying out some descriptive visualisation and summary statistics, to interpreting the results and using the outputs of the model to inform your next steps.

::: {.infobox .warning data-latex="{note}"}

This practical is long and we will have two weeks to cover it. 

It will first cover **linear regression** which you may have covered in other modules. It will then move to **spatial regression models**. 

If you have a solid understanding of linear regression please progress to the [spatial regression models](https://andrewmaclachlan.github.io/CASA0005repo/explaining-spatial-patterns.html#spatial-regression-models) section.   
:::

### Setting up your Data

First, let's set up R and read in some data to enable us to carry out our analysis. 

```{r, message = FALSE, cache=FALSE, message=FALSE}
#library a bunch of packages we may (or may not) use - install them first if not installed already. 
library(tidyverse)
library(tmap)
library(geojsonio)
library(plotly)
library(rgdal)
library(broom)
library(mapview)
library(crosstalk)
library(sf)
library(sp)
library(spdep)
library(car)
library(fs)
library(janitor)
```
Read some ward data in [from London Data Store](https://data.london.gov.uk/dataset/statistical-gis-boundary-files-london)

```{r, eval=FALSE}
#download a zip file containing some boundaries we want to use

download.file("https://data.london.gov.uk/download/statistical-gis-boundary-files-london/9ba8c833-6370-4b11-abdc-314aa020d5e0/statistical-gis-boundaries-london.zip", 
              destfile="prac7_data/statistical-gis-boundaries-london.zip")
```

Get the zip file and extract it

```{r, eval=FALSE}
library(fs)
listfiles<-dir_info(here::here("prac7_data")) %>%
  dplyr::filter(str_detect(path, ".zip")) %>%
  dplyr::select(path)%>%
  pull()%>%
  #print out the .gz file
  print()%>%
  as.character()%>%
  utils::unzip(exdir=here::here("prac7_data"))
```

Look inside the zip and read in the `.shp`

```{r, message=FALSE, cache=FALSE}

#look what is inside the zip

Londonwards<-fs::dir_info(here::here("prac7_data", 
                                 "statistical-gis-boundaries-london", 
                                 "ESRI"))%>%
  #$ means exact match
  dplyr::filter(str_detect(path, 
                           "London_Ward_CityMerged.shp$"))%>%
  dplyr::select(path)%>%
  dplyr::pull()%>%
  #read in the file in
  sf::st_read()

#check the data
qtm(Londonwards)
```

Now we are going to read in some data from the [London Data Store](https://data.london.gov.uk/)

```{r echo=TRUE, message=FALSE, paged.print=TRUE}
#read in some attribute data
LondonWardProfiles <- read_csv("https://data.london.gov.uk/download/ward-profiles-and-atlas/772d2d64-e8c6-46cb-86f9-e52b4c7851bc/ward-profiles-excel-version.csv", 
                               col_names = TRUE, 
                               locale = locale(encoding = 'Latin1'))
```

```{r eval=FALSE}
#check all of the columns have been read in correctly
Datatypelist <- LondonWardProfiles %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist
```

#### Cleaning the data as you read it in

Examining the dataset as it is read in above, you can see that a number of fields in the dataset that should have been read in as numeric data, have actually been read in as character (text) data. 

If you examine your data file, you will see why. In a number of columns where data are missing, rather than a blank cell, the values 'n/a' have been entered in instead. Where these text values appear amongst numbers, the software will automatically assume the whole column is text. 

To deal with these errors, we can force `read_csv` to ignore these values by telling it what values to look out for that indicate missing data

```{r, message=FALSE, cache=FALSE, eval=FALSE}
#We can use readr to deal with the issues in this dataset - which are to do with text values being stored in columns containing numeric values

#read in some data - couple of things here. Read in specifying a load of likely 'n/a' values, also specify Latin1 as encoding as there is a pound sign (£) in one of the column headers - just to make things fun!

LondonWardProfiles <- read_csv("https://data.london.gov.uk/download/ward-profiles-and-atlas/772d2d64-e8c6-46cb-86f9-e52b4c7851bc/ward-profiles-excel-version.csv", 
                               na = c("", "NA", "n/a"), 
                               locale = locale(encoding = 'Latin1'), 
                               col_names = TRUE)

```

Or download it from the [London data store](https://data.london.gov.uk/dataset/ward-profiles-and-atlas) and read it in...it's the ward Profiles excel download.

```{r}
LondonWardProfiles <- read_csv("prac7_data/ward-profiles-excel-version.csv", 
                               na = c("", "NA", "n/a"), 
                               locale = locale(encoding = 'Latin1'), 
                               col_names = TRUE)
```


```{r eval=FALSE}
#check all of the columns have been read in correctly
Datatypelist <- LondonWardProfiles %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist
```

Now you have read in both your boundary data and your attribute data, you need to merge the two together using a common ID. In this case, we can use the ward codes to achieve the join

```{r, message=FALSE, cache=FALSE}
#merge boundaries and data
LonWardProfiles <- Londonwards%>%
  left_join(.,
            LondonWardProfiles, 
            by = c("GSS_CODE" = "New code"))

#let's map our dependent variable to see if the join has worked:
tmap_mode("plot")
qtm(LonWardProfiles, 
    fill = "Average GCSE capped point scores - 2014", 
    borders = NULL,  
    fill.palette = "Blues")
```

#### Additional Data

In addition to our main datasets, it might also be useful to add some contextual data. While our exam results have been recorded at the home address of students, most students would have attended one of the schools in the City. 

Let's add some schools data as well. In the `st_as_sf` function `x` is longitude, `y` is latitude.

```{r, message=FALSE, cache=FALSE}
#might be a good idea to see where the secondary schools are in London too
london_schools <- read_csv("https://data.london.gov.uk/download/london-schools-atlas/57046151-39a0-45d9-8dc0-27ea7fd02de8/all_schools_xy_2016.csv")

#from the coordinate values stored in the x and y columns, which look like they are latitude and longitude values, create a new points dataset
lon_schools_sf <- st_as_sf(london_schools, 
                           coords = c("x","y"), 
                           crs = 4326)

lond_sec_schools_sf <- lon_schools_sf %>%
  filter(PHASE=="Secondary")

tmap_mode("plot")
qtm(lond_sec_schools_sf)
```

## Analysing GCSE exam performance - testing a research hypothesis

To explore the factors that might influence GCSE exam performance in London, we are going to run a series of different regression models. A regression model is simply the expression of a linear relationship between our outcome variable (Average GCSE score in each Ward in London) and another variable or several variables that might explain this outcome. 

### Research Question and Hypothesis

Examining the spatial distribution of GSCE point scores in the map above, it is clear that there is variation across the city. My research question is:

**What are the factors that might lead to variation in Average GCSE point scores across the city?**

My research hypothesis that I am going to test is that there are other observable factors occurring in Wards in London that might affect the average GCSE scores of students living in those areas. 

In inferential statistics, we cannot definitively prove a hypothesis is true, but we can seek to *disprove* that there is absolutely nothing of interest occurring or no association between variables. 
The *null hypothesis* that I am going to test empirically with some models is that there is *no* relationship between exam scores and other observed variables across London. 

### Regression Basics

For those of you who know a bit about regression, you might want to skip down to the next section. However, if you are new to regression or would like a refresher, read on...

The linear relationship in a regression model is probably most easily explained using a scatter plot...

```{r, message=FALSE, cache=FALSE}
q <- qplot(x = `Unauthorised Absence in All Schools (%) - 2013`, 
           y = `Average GCSE capped point scores - 2014`, 
           data=LonWardProfiles)

#plot with a regression line - note, I've added some jitter here as the x-scale is rounded
q + stat_smooth(method="lm", se=FALSE, size=1) + 
  geom_jitter()

```

Here, I have plotted the average GCSE point score for each Ward in London against another variable in the dataset that I think might be influential: the % of school days lost to unauthorised absences in each ward. 

Remember that my *null hypothesis* would be that there is no relationship between GCSE scores and unauthorised absence from school. If this null hypothesis was true, then I would not expect to see any pattern in the cloud of points plotted above. 

As it is, the scatter plot shows that, generally, as the $x$ axis *independent variable* (unauthorised absence) goes up, our $y$ axis *dependent variable* (GCSE point score) goes down. This is not a random cloud of points, but something that indicates there could be a relationshp here and so I might be looking to reject my null hypothesis. 

**Some conventions** - In a regression equation, the dependent variable is always labelled $y$ and shown on the $y$ axis of a graph, the predictor or independent variable(s) is(are) always shown on the $x$ axis. 

I have added a blue line of best-fit - this is the line that can be drawn by minimising the sum of the squared differences between the line and the residuals. The residuals are all of the dots not falling exactly on the blue line. An algorithm known as 'ordinary least squares' (OLS) is used to draw this line and it simply tries a selection of different lines until the sum of the squared divations between all of the residuals and the blue line is minimised, leaving the final solution. 

As a general rule, the better the blue line is at summarising the relationship between $y$ and $x$, the better the model. 

The equation for the blue line in the graph above can be written:

$$y_i = \beta_0 + \beta_1x_i + \epsilon_i$$

where:

$\beta_0$ is the intercept (the value of $y$ when $x = 0$ - somewhere around 370 on the graph above); 

$\beta_1$ is sometimes referred to as the 'slope' parameter and is simply the change in the value of $y$ for a 1 unit change in the value of $x$ (the slope of the blue line) - reading the graph above, the change in the value of $y$ reading between 1.0 and 2.0 on the $x$ axis looks to be around -40.

$\epsilon_i$ is a random error term (positive or negative) that should sum to 0 - esentially, if you add all of the vertical differences between the blue line and all of the residuals, it should sum to 0.

Any value of $y$ along the blue line can be modelled using the corresponding value of $x$ and these parameter values. Examining the graph above we would expect the average GCSE point score for a student living in a Ward where 0.5% of school days per year were missed, to equal around 350, but we can confirm this by plugging the $\beta$ parameter values and the value of $x$ into equation (1):

```{r, message=FALSE, cache=FALSE}
370 + (-40*0.5) + 0
```

### Running a Regression Model in R

In the graph above, I used a method called 'lm' in the `stat_smooth()` function in `ggplot2` to draw the regression line. 'lm' stands for 'linear model' and is a standard function in R for running linear regression models. Use the help system to find out more about `lm` - `?lm`

Below is the code that could be used to draw the blue line in our scatter plot. Note, the tilde `~` symbol means "is modelled by".

First though, we're going to clean up all our data names with `Janitor` then select what we want.

```{r, message=FALSE, cache=FALSE}
#run the linear regression model and store its outputs in an object called model1
Regressiondata<- LonWardProfiles%>%
  clean_names()%>%
  dplyr::select(average_gcse_capped_point_scores_2014, 
                unauthorised_absence_in_all_schools_percent_2013)

#now model
model1 <- Regressiondata %>%
  lm(average_gcse_capped_point_scores_2014 ~
               unauthorised_absence_in_all_schools_percent_2013,
     data=.)
```

Let's have a closer look at our model...

```{r, message=FALSE, cache=FALSE}
#show the summary of those outputs
summary(model1)
```

#### Interpreting and using the model outputs

In running a regression model, we are effectively trying to test (disprove) our null hypothesis. If our null hypothesis was true, then we would expect our coefficients to = 0. 

In the output summary of the model above, there are a number of features you should pay attention to:

**Coefficient Estimates** - these are the $\beta_0$ (intercept) and $\beta_1$ (slope) parameter estimates from Equation 1. You will notice that at $\beta_0 = 371.471$ and $\beta_1 = -41.237$ they are pretty close to the estimates of 370 and -40 that we read from the graph earlier, but more precise. 

**Coefficient Standard Errors** - these represent the average amount the coefficient varies from the average value of the dependent variable (its standard deviation). So, for a 1% increase in unauthorised absence from school, while the model says we might expect GSCE scores to drop by -41.2 points, this might vary, on average, by about 1.9 points. As a rule of thumb, we are looking for a lower value in the standard error relative to the size of the coefficient. 

**Note that is the coefficient represents a one unit change, here it is %, as the variable is % unauthorized absence in school** So one unit is a 1% change...

**Coefficient t-value** - this is the value of the coefficient divided by the standard error and so can be thought of as a kind of standardised coefficient value. The larger (either positive or negative) the value the greater the relative effect that particular independent variable is having on the dependent variable (this is perhaps more useful when we have several independent variables in the model) .

**Coefficient p-value - Pr(>|t|)** - the p-value is a measure of significance. There is lots of debate about p-values which I won't go into here, but essentially it refers to the probability of getting a coefficient as large as the one observed in a set of random data. p-values can be thought of as percentages, so if we have a p-value of 0.5, then there is a 5% chance that our coefficient could have occurred in some random data, or put another way, a 95% chance that out coefficient could have only occurred in our data. 
As a rule of thumb, the smaller the p-value, the more significant that variable is in the story and the smaller the chance that the relationship being observed is just random. Generally, statisticians use 5% or 0.05 as the acceptable cut-off for statistical significance - anything greater than that we should be a little sceptical about. 

In `r` the codes `***, **, **, .` are used to indicate significance. We generally want at least a single `*` next to our coefficient for it to be worth considering. 

**R-Squared** - This can be thought of as an indication of how good your model is - a measure of 'goodness-of-fit' (of which there are a number of others). $r^2$ is quite an intuitite measure of fit as it ranges between 0 and 1 and can be thought of as the % of variation in the dependent variable (in our case GCSE score) explained by variation in the independent variable(s). In our example, an $r^2$ value of 0.42 indicates that around 42% of the variation in GCSE scores can be explained by variation in unathorised absence from school. In other words, this is quite a good model. The $r^2$ value will increase as more independent explanatory variables are added into the model, so where this might be an issue, the adjusted r-squared value can be used to account for this affect

#### broom

The output from the linear regression model is messy and like all things R mess can be tidied, in this case with a broom! Or the package `broom` which is also party of the [package `tidymodels`](https://www.tidymodels.org/).

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, results=FALSE}
knitr::include_graphics('allisonhorst_images/broom_package.png')
```

Here let's load `broom` and tidy our output...you will need to either install `tidymodels` or `broom`. The `tidy()` function will just make a tibble or the statistical findings from the model!

```{r, message=FALSE, cache=FALSE}
library(broom)
tidy(model1)
```

We can also use `glance()` from `broom` to get a bit more summary information, such as $r^2$ and the adjusted r-squared value. 

```{r, message=FALSE, cache=FALSE}
glance(model1)
```

But wait? Didn't we try to model our GCSE values based on our unauthorised absence variable? Can we see those predictions for each point, yes, yes we can...with the `tidypredict_to_column()` function from `tidypredict`, which adds the `fit` column in the following code.

```{r}
library(tidypredict)
Regressiondata %>%
  tidypredict_to_column(model1)
```

### tidymodels

Before we move on it's worth pointing out that a new iteration of modelling is being developed through [`tidymodels`](https://www.tidymodels.org/)...the benefit of this is that we can easily change the modelling method or as they term it...`engine`...(e.g. to [RandomForest](https://www.rebeccabarter.com/blog/2020-03-25_machine_learning/))

```{r, message=FALSE, cache=FALSE}
library(tidymodels)

# set the model
lm_mod <- linear_reg()

# fit the model
lm_fit <- 
  lm_mod %>% 
  fit(average_gcse_capped_point_scores_2014 ~
               unauthorised_absence_in_all_schools_percent_2013,
     data=Regressiondata)

# we cover tidy and glance in a minute...
tidy(lm_fit)
glance(lm_fit)
```

**However** at the moment we can't do spatial modelling using `tidymodels`...but this is probably coming soon.

### Bootstrap resampling

If we only fit our model once, how can we be confident about that estimate? Bootstrap resampling is where we take the original dataset and select random data points from within it, but in order to keep it the same size as the original dataset some records are duplicated. This is known as bootstrap resampling by replacement. We used to briefly cover this within this practical but have recently removed it. If you wish to explore it then consult the [bootstrap resampling section from previous years](https://andrewmaclachlan.github.io/CASA0005repo_20202021/gwr-and-spatially-lagged-regression.html#bootstrap-resampling), but this is not a requirement and only for interest. 

### Variables 

Common questions i get asked about regression that are **not** within scope of the module, but there are some resources here should you want to use them in future (e.g. dissertations):

> Must my variables be normally distrubuted

The right answer is **no**. Although different academics have different responses. If the data is not normally distributed the residuals *may* be not normally distributed (hence why i suggest it here), although this could be an issue with the model / independent variables selected and not the data. They residuals may well be normally distributed, but could vary (meaning we have hetroscedasticity) which we discuss later on. So you might only want to transform the data if it is very skewed.  

> How do i select my variables 

Either with logic and reasoning (e.g. in the exam), with the support of academic literature or methods such as [best subset regression, k-fold cross validation](http://www.sthda.com/english/articles/37-model-selection-essentials-in-r/155-best-subsets-regression-essentials-in-r/) or [gradient descent](https://mlu-explain.github.io/linear-regression/). It does not form part of this module. Other regression methods such as [Ridge, LASSO and elastic net regression](https://andrewmaclachlan.github.io/CASA0005repo_20202021/advanced-r-maup-and-more-regression.html#advanced-regression) can reduce the influence of variables that are not useful in the model. But again, this is beyond the scope of this module.     

> Should i center and scale my data

This means giving all your variables a mean of 0 (centering) and standard deviation of 1 (scaling). This is done through subtracting the mean from each value and dividing by the standard deviation (this latter part is often called standardizing). There is [much debate on when to do this](https://stats.stackexchange.com/questions/29781/when-conducting-multiple-regression-when-should-you-center-your-predictor-varia). Neal Goldstein has [a good list of why and when to do this](https://www.goldsteinepi.com/blog/thewhyandwhenofcenteringcontinuouspredictorsinregressionmodeling/index.html) and [this blog provides a nice explanation](https://tungmphung.com/when-to-do-feature-centering-and-scaling/). Typically reasons might include multicollinearity and large differences in data ranges. To interpret the coefficient of this it you can [transform them back](https://stats.stackexchange.com/questions/388772/normalized-regression-coefficients-interpretation). **But** this does not form part of this module.

> What is confounding

A confounding variable is where an extraneous variable (an external to your model variable) is related to both the dependent and independent (those used to predict the dependent) variables.  

An example from [Scribbr](https://www.scribbr.co.uk/research-methods/confounding-variable/) is that if you are modelling sunburn using ice cream consumption then temperature will influence both of these variables. 

There are several ways to solve this explained in Scribbr article, one approach is to include the variables as control variables (this is not of interest in the study but must be accounted for) in the model so you can account for them.

For a confounding variable it must be:

* correlated with other independent variables (see Assumption 3 - No Multicolinearity in the independent variables)
* causally related to the dependent - known to influence the dependent variable

**However**, in our work, if our independent variables are correlated we might remove the one that has least influence on the model to resolve this situation.

For details on regression diagnostics see [testing the assumptions of linear regression](https://people.duke.edu/~rnau/testing.htm#:~:text=The%20dependent%20and%20independent%20variables,need%20to%20be%20normally%20distributed.)

### Assumptions Underpinning Linear Regression

### Assumption 1 - There is a linear relationship between the dependent and independent variables

The best way to test for this assumption is to plot a scatter plot similar to the one created earlier. It may not always be practical to create a series of scatter plots, so one quick way to check that a linear relationship is probable is to look at the frequency distributions of the variables. If they are normally distributed, then there is a good chance that if the two variables are in some way correlated, this will be a linear relationship.

For example, look at the frequency distributions of our two variables earlier:

```{r}


#let's check the distribution of these variables first

ggplot(LonWardProfiles, aes(x=`Average GCSE capped point scores - 2014`)) + 
  geom_histogram(aes(y = ..density..),
                 binwidth = 5) + 
  geom_density(colour="red", 
               size=1, 
               adjust=1)

```

Here, adding `..density..` means that the histogram is a density plot, this plots the chance that any value in the data is equal to that value.

```{r, message=FALSE, cache=FALSE}
ggplot(LonWardProfiles, aes(x=`Unauthorised Absence in All Schools (%) - 2013`)) +
  geom_histogram(aes(y = ..density..),
                 binwidth = 0.1) + 
  geom_density(colour="red",
               size=1, 
               adjust=1)
```

We would describe both of these distribution as being relatively ['normally' or gaussian disributed](https://en.wikipedia.org/wiki/Normal_distribution), and thus more likely to have a linear correlation (if they are indeed associated).

Contrast this with the median house price variable:

**Note** in the code below I've renamed the `Median House Price (£) - 2014` column manually. The data provider changed this variable to be called `median_house_price<c2>2014` around the 21/10/22 and then recently corrected it back to `Median House Price (£) - 2014` (November 2022). However, when i render this book it still doesn't like it. So to fix this i just manually renamed the column and then used `clean_names()` for the rest of the columns. **Good code is code that works and doesn't always need to be pretty / clean** 

```{r, message=FALSE, cache=FALSE}
library(ggplot2)

# from 21/10 there is an error on the website with 
# median_house_price_2014 being called median_house_price<c2>2014
# this was corrected around 23/11 but can be corrected with rename..

LonWardProfiles <- LonWardProfiles %>%
  #try removing this line to see if it works...
  dplyr::rename(median_house_price_2014 =`Median House Price (£) - 2014`)%>%
  janitor::clean_names()

ggplot(LonWardProfiles, aes(x=median_house_price_2014)) + 
  geom_histogram()
```

We would describe this as a [not normal and/or positively 'skewed'](https://en.wikipedia.org/wiki/Skewness) distribution, i.e. there are more observations towards the lower end of the average house prices observed in the city, however there is a long tail to the distribution, i.e. there are a small number of wards where the average house price is very large indeed.

```{r echo=FALSE, out.width = "300pt", fig.align='center', cache=FALSE, message=FALSE, results=FALSE}
knitr::include_graphics('allisonhorst_images/not_normal.png')
```

If we plot the raw house price variable against GCSE scores, we get the following scatter plot:

```{r, message=FALSE, cache=FALSE}
qplot(x = median_house_price_2014, 
      y = average_gcse_capped_point_scores_2014, 
      data=LonWardProfiles)
```

This indicates that we do not have a linear relationship, indeed it suggests that this might be a curvilinear relationship.

#### Transforming variables

One way that we might be able to achieve a linear relationship between our two variables is to transform the non-normally distributed variable so that it is more normally distributed. 

There is some debate as to whether this is a wise thing to do as, amongst other things, the coefficients for transformed variables are much harder to interpret, however, we will have a go here to see if it makes a difference.

**Tukey's ladder of transformations**

You might be asking how we could go about transforming our variables. In 1977, Tukey described a series of power transformations that could be applied to a variable to alter its frequency distribution. 

In regression analysis, you analysts will frequently take the log of a variable to change its distribution, but this is a little crude and may not result in a completely normal distribution. For example, we can take the log of the house price variable:

```{r, message=FALSE, cache=FALSE}
ggplot(LonWardProfiles, aes(x=log(median_house_price_2014))) + 
  geom_histogram()
```

This looks a little more like a normal distribution, but it is still a little skewed. 

Fortunately in R, we can use the `symbox()` function in the `car` package to try a range of transfomations along Tukey's ladder: 

```{r, message=FALSE, cache=FALSE}
symbox(~median_house_price_2014, 
       LonWardProfiles, 
       na.rm=T,
       powers=seq(-3,3,by=.5))
```

Observing the plot above, it appears that raising our house price variable to the power of -1 should lead to a more normal distribution:

```{r, message=FALSE, cache=FALSE}
ggplot(LonWardProfiles, aes(x=(median_house_price_2014)^-1)) + 
  geom_histogram()
```

```{r, message=FALSE, cache=FALSE}
qplot(x = (median_house_price_2014)^-1, 
      y = average_gcse_capped_point_scores_2014,
      data=LonWardProfiles)
```

Compare this with the logged transformation:

```{r, message=FALSE, cache=FALSE}
qplot(x = log(median_house_price_2014), 
      y = average_gcse_capped_point_scores_2014, 
      data=LonWardProfiles)
```

Depending on if the independent or dependent (GCSE point score) variables have been transformed depends on how we interpret them - [see these rules for interpretation](https://data.library.virginia.edu/interpreting-log-transformations-in-a-linear-model/)

#### Should I transform my variables?

The decision is down to you as the modeller - it might be that a transformation doesn't succeed in normalising the distribution of your data or that the interpretation after the transformation is problematic, however it is important not to violate the assumptions underpinning the regression model or your conclusions may be on shaky ground. 

::: {.infobox .warning data-latex="{note}"}
**Be careful** The purpose of doing theses transformations is to make your data normally distributed, however you will be changing the relationship of your data - it won't be linear anymore! This could improve your model but is at the expense of interpretation. Aside from log transformation which has the rules in the link above.

Typically if you do a power transformation you can keep the direction of the relationship (positive or negative) and the t-value will give an idea of the importance of the variable in the model - that's about it!

For more information here read [Transforming Variables in Regression](https://bookdown.org/ejvanholm/Textbook/transforming-variables-in-regression.html) by Eric van Holm, 2021
:::


### Assumption 2 - The residuals in your model should be normally distributed

This assumption is easy to check. When we ran our Model1 earlier, one of the outputs stored in our Model 1 object is the residual value for each case (Ward) in your dataset. We can access these values using `augment()` from `broom` which will add model output to the original GCSE data...

We can plot these as a histogram and see if there is a normal distribution:

```{r, message=FALSE, cache=FALSE}
#save the residuals into your dataframe

model_data <- model1 %>%
  augment(., Regressiondata)

#plot residuals
model_data%>%
dplyr::select(.resid)%>%
  pull()%>%
  qplot()+ 
  geom_histogram() 
  
```

Examining the histogram above, we can be happy that our residuals look to be relatively normally distributed. 

### Assumption 3 - No Multicolinearity in the independent variables

Now, the regression model we have be experimenting with so far is a simple bivariate (two variable) model. One of the nice things about regression modelling is while we can only easily visualise linear relationships in a two (or maximum 3) dimension scatter plot, mathematically, we can have as many dimensions / variables as we like. 

As such, we could extend model 1 into a multiple regression model by adding some more explanatory variables that we think could affect GSCE scores. Let's try the log or ^-1 transformed house price variable from earlier (the rationale being that higher house prices indicate more affluence and therefore, potentially, more engagement with education):

```{r, message=FALSE, cache=FALSE}

Regressiondata2<- LonWardProfiles%>%
  clean_names()%>%
  dplyr::select(average_gcse_capped_point_scores_2014,
         unauthorised_absence_in_all_schools_percent_2013,
         median_house_price_2014)

model2 <- lm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), data = Regressiondata2)

#show the summary of those outputs
tidy(model2)

glance(model2)

#and for future use, write the residuals out
model_data2 <- model2 %>%
  augment(., Regressiondata2)

# also add them to the shapelayer
LonWardProfiles <- LonWardProfiles %>%
  mutate(model2resids = residuals(model2))

```

Examining the output above, it is clear that including median house price into our model improves the fit from an $r^2$ of around 42% to an $r^2$ of 48%. Median house price is also a statistically significant variable. 

But do our two explanatory variables satisfy the no-multicoliniarity assumption? If not and the variables are highly correlated, then we are effectively double counting the influence of these variables and overstating their explanatory power. 

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="Word anatomy of multicollinearity. Source: [What the Heck is Multicollinearity?, Andrew Ozbun](https://medium.com/geekculture/what-the-heck-is-multicollinearity-c5582ddbb2f7)"}
knitr::include_graphics('prac8_images/multicollinearity_explain.png')
```

To check this, we can compute the product moment correlation coefficient between the variables, using the `corrr()` pacakge, that's part of `tidymodels`. In an ideal world, we would be looking for something less than a 0.8 correlation

```{r, message=FALSE, cache=FALSE}
library(corrr)

Correlation <- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(average_gcse_capped_point_scores_2014,
         unauthorised_absence_in_all_schools_percent_2013,
         median_house_price_2014) %>%
  mutate(median_house_price_2014 =log(median_house_price_2014))%>%
    correlate() %>%
  # just focus on GCSE and house prices
  focus(-average_gcse_capped_point_scores_2014, mirror = TRUE) 


#visualise the correlation matrix
rplot(Correlation)
```

Looking at either the correlation matrix or the correlation plot of that matrix, it's easy to see that there is a low correlation (around 30%) between our two independent variables. However, at this stage we might wish to introduce more variables into our model to improve our prediction of the dependent variable (GCSE scores), this is called **multiple linear regression**...multiple linear regression can be explained nicely with this example from [allison_horst](https://twitter.com/allison_horst).

Let's meet our Multiple Linear Regression teaching assistants:

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="Multiple linear regression assistants. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragons.png')
```

Here my research question might be

**What are the factors that might lead to variation in dragon weight?**

We might have both categorical predictor variables such as if the dragon is spotted then they might weight 0.6 more tons than on average...So if the dragon is not spotted then in the equation bellow 0.6 x (0) --- 0 as it's not spotted, it would be 1 if spotted is 0 so the weight would be 2.4 tonnes.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="How to interpret coefficients for categorical variables. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragon_regression.png')
```

But we could also have a continuous predictor variable ...here a 1 foot taller dragon would have an additional 0.3 tonnes on average, as the equation would be 2.4 + 0.3(1)...

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="How to interpret coefficients for continuous variables. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragons_continuous.png')
```

We can use these equations to make predicitons about a new dragon...here the dragon is striped, so spotted equals 0, and it's height is 5.1. So that gives us 2.4 + (0.3*5.1) which equals 3.9 tonnes. 

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="How to make predictions using a regression model. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragons_continuous.png')
```

However, we need to check the residuals --- difference between the predicted weight and acutal weight...here it's 0.3 tonnes as the actual weight of the dragon was 4.2 tonnes.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="How to understand residuals of a regression model. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragon_residual.png')
```

Then for all the dragons we need to make sure these residuals are normally distributed, but you should also check all the other assumptions (1-5) shown within this practical and give brief evidence in reports that they are all valid.

```{r echo=FALSE, out.width = "450pt", fig.align='center', cache=FALSE, message=FALSE, fig.cap="Checking residual normality from a regression model. Source: [Allison Horst data science and stats illustrations](https://github.com/allisonhorst/stats-illustrations)"}
knitr::include_graphics('allisonhorst_images/dragon_residual_distribution.png')
```

#### Variance Inflation Factor (VIF)

Another way that we can check for Multicolinearity is to examine the VIF for the model. If we have VIF values for any variable exceeding 10, then we may need to worry and perhaps remove that variable from the analysis:

```{r, message=FALSE, cache=FALSE}
vif(model2)
```

Both the correlation plots and examination of VIF indicate that our multiple regression model meets the assumptions around multicollinearity and so we can proceed further. 

If we wanted to add more variables into our model, it would be useful to check for multicollinearity amongst every variable we want to include, we can do this by computing a correlation matrix for the whole dataset or checking the VIF after running the model:

```{r, message=FALSE, cache=FALSE}
position <- c(10:74)

Correlation_all<- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(position)%>%
    correlate()

rplot(Correlation_all)
```

### Assumption 4 - Homoscedasticity

Homoscedasticity means that the errors/residuals in the model exhibit constant / homogenous variance, if they don't, then we would say that there is hetroscedasticity present. Why does this matter? Andy Field does a much better job of explaining this in [discovering statistics](https://www.discoveringstatistics.com/tag/homoscedasticity/) --- but essentially, if your errors do not have constant variance, then your parameter estimates could be wrong, as could the estimates of their significance. 

The best way to check for homo/hetroscedasticity is to plot the residuals in the model against the predicted values. We are looking for a cloud of points with no apparent patterning to them. 

```{r, message=FALSE, cache=FALSE}
#print some model diagnositcs. 
par(mfrow=c(2,2))    #plot to 2 by 2 array
plot(model2)
```

In the series of plots above, the first plot (residuals vs fitted), we would hope to find a random cloud of points with a straight horizontal red line. Looking at the plot, the curved red line would suggest some hetroscedasticity, but the cloud looks quite random. Similarly we are looking for a random cloud of points with no apparent patterning or shape in the third plot of standardised residuals vs fitted values. Here, the cloud of points also looks fairly random, with perhaps some shaping indicated by the red line. 

[Section 5.7.6 in Tidyverse Skills for Data Science explains each of these plots in more detail](https://jhudatascience.org/tidyversecourse/model.html#model-diagnostics)

In the plots here we are looking for:

* Residuals vs Fitted: a flat and horizontal line. This is looking at the linear relationship assumption between our variables 

* Normal Q-Q: all points falling on the line. This checks if the residuals (observed minus predicted) are normally distributed

* Scale vs Location: flat and horizontal line, with randomly spaced points. This is **the homoscedasticity** (errors/residuals in the model exhibit constant / homogeneous variance). Are the residuals (also called errors) spread equally along all of the data. 

* Residuals vs Leverage - Identifies outliers (or influential observations), the three largest outliers are identified with values in the plot.

The University of Viginia Library provides [examples of good and bad models in relation to these plots](https://data.library.virginia.edu/diagnostic-plots/#:~:text=Scale%2DLocation,equally%20(randomly)%20spread%20points.).

There is an easier way to produce this plot using `check_model()` from the `performance` package, that even includes what you are looking for...note that the Posterior predictive check is the comparison between the fitted model and the observed data.

The default argument is `check=all` but we can specify what to check for...see the [arguments section in the documentation](https://rdrr.io/cran/performance/man/check_model.html)...e.g. `check = c("vif", "qq")`

```{r message=FALSE, cache=FALSE}
library(performance)

check_model(model2, check="all")

```


### Assumption 5 - Independence of Errors

This assumption simply states that the residual values (errors) in your model must not be correlated in any way. If they are, then they exhibit *autocorrelation* which suggests that something might be going on in the background that we have not sufficiently accounted for in our model. 

#### Standard Autocorrelation

If you are running a regression model on data that do not have explicit space or time dimensions, then the standard test for autocorrelation would be the Durbin-Watson test. 

This tests whether residuals are correlated and produces a summary statistic that ranges between 0 and 4, with 2 signifiying no autocorrelation. A value greater than 2 suggesting negative autocorrelation and and value of less than 2 indicating postitve autocorrelation. 

In his [excellent text book](https://www.discoveringstatistics.com/books/discovering-statistics-using-r/), Andy Field suggests that you should be concerned with Durbin-Watson test statistics <1 or >3. So let's see:

```{r, message=FALSE, cache=FALSE}
#run durbin-watson test
DW <- durbinWatsonTest(model2)
tidy(DW)
```

As you can see, the DW statistics for our model is 1.61, so some indication of autocorrelation, but perhaps nothing to worry about. 

**HOWEVER**

We are using spatially referenced data and as such we should check for *spatial*-autocorrelation.

The first test we should carry out is to map the residuals to see if there are any apparent obvious patterns:

```{r, message=FALSE, cache=FALSE}

#now plot the residuals
tmap_mode("view")
#qtm(LonWardProfiles, fill = "model1_resids")

tm_shape(LonWardProfiles) +
  tm_polygons("model2resids",
              palette = "RdYlBu") +
tm_shape(lond_sec_schools_sf) + tm_dots(col = "TYPE")

```

Looking at the map above, there look to be some blue areas next to other blue areas and some red/orange areas next to other red/orange areas. This suggests that there could well be some spatial autocorrelation biasing our model, but can we test for spatial autocorrelation more systematically?

Yes - and some of you will remember this from the practical two weeks ago. We can calculate a number of different statistics to check for spatial autocorrelation - the most common of these being Moran's I. 


```{r, message=FALSE, cache=FALSE, warning=FALSE}

#calculate the centroids of all Wards in London
coordsW <- LonWardProfiles%>%
  st_centroid()%>%
  st_geometry()

plot(coordsW)

#Now we need to generate a spatial weights matrix 
#(remember from the lecture a couple of weeks ago). 
#We'll start with a simple binary matrix of queen's case neighbours

LWard_nb <- LonWardProfiles %>%
  poly2nb(., queen=T)

#or nearest neighbours
knn_wards <-coordsW %>%
  knearneigh(., k=4)

LWard_knn <- knn_wards %>%
  knn2nb()

#plot them
plot(LWard_nb, st_geometry(coordsW), col="red")
plot(LWard_knn, st_geometry(coordsW), col="blue")
```



```{r}
#create a spatial weights matrix object from these weights

Lward.queens_weight <- LWard_nb %>%
  nb2listw(., style="W")

Lward.knn_4_weight <- LWard_knn %>%
  nb2listw(., style="W")
```

The `style` argument means the style of the output --- `B` is binary encoding listing them as neighbours or not, `W` row standardised that we saw last week.

Now run a moran's I test on the residuals, first using queens neighbours

```{r, message=FALSE, cache=FALSE}

Queen <- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(model2resids)%>%
  pull()%>%
  moran.test(., Lward.queens_weight)%>%
  tidy()

```

Then nearest k-nearest neighbours

```{r, message=FALSE, cache=FALSE}
Nearest_neighbour <- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(model2resids)%>%
  pull()%>%
  moran.test(., Lward.knn_4_weight)%>%
  tidy()

Queen
Nearest_neighbour
```

Observing the Moran's I statistic for both Queen's case neighbours and k-nearest neighbours of 4, we can see that the Moran's I statistic is somewhere between 0.27 and 0.29. Remembering that Moran's I ranges from between -1 and +1 (0 indicating no spatial autocorrelation) we can conclude that there is some weak to moderate spatial autocorrelation in our residuals. 

This means that despite passing most of the assumptions of linear regression, we could have a situation here where the presence of some spatial autocorrelation could be leading to biased estimates of our parameters and significance values. 

##### waywiser

This process of detecting spatial autocorrelation is becoming much easier. Whilst this is a beyond the scope of the module, the new package [waywiser](https://www.mm218.dev/posts/2022-08-11-waywiser-010-is-now-on-cran/) let's you conduct this analysis (build a weight matrix and then run spatial autocorrelation in model residuals) in just a few lines of code...This is beyond the scope here.

## Spatial Regression Models

### Dealing with Spatially Autocorrelated Residuals - Spatial Lag and Spatial Error models

#### The Spatial Lag (lagged dependent variable) model

In the example models we ran above we were testing the null-hypothesis that there is no relationship between the average GCSE scores recorded for secondary school pupils in different Wards in London and other explanatory variables. Running regression models that tested the effects of absence from school and average house price, early indications were that we could reject this null-hypothsis as the regression models ran indicated that close to 50% of the variation in GCSE scores could be explained by variations in unauthorised absence from school and average house prices. 

However, running a Moran's I test on the residuals from the model suggested that there might be some spatial autocorreation occurring suggesting that places where the model over-predicted GCSE scores (those shown in blue in the map above with negative residuals) and under-predicted (those shown in red/orange) occasionally were near to each other. 

Overlaying the locations of secondary schools in London onto the map reveals why this could be the case. Many of the schools in London lie on or near the bounaries of the wards that pupils will live in. Therefore, it is likely that pupils attending a school could come from a number of neighbouring wards. 

As such the average GCSE score in one ward could be related to that in another as the pupils living in these wards may be attending the same school. This could be the source of the autocorrelation. 

Ward and Gleditsch (2008) describe this situation (where the value of our $y$ dependent variable - GCSE scores - may be influenced by neighbouring values) and suggest the way to deal with it is to incorporate a *spatially-lagged* version of this variable amongst the independent variables on the right-hand side of the equation. In this case, Equation 1 would be updated to look like this:

$$y_i = \beta_0 + \beta_1x_i + \rho w_i.y_i + \epsilon_i$$

In this equation, $w$ is the spatial weights matrix you generated and $w_i$ is vector of all neighbouring areas (in our case, Wards) for any Ward $y_i$. 

In this model, a positive value for the $\rho w_i.y_i$ parameter would indicate that the average value for GCSE scores is expected to be higher if, on average, Wards neighbouring also have higher GCSE score values. 

* $\rho$ denotes (represents) the spatial lag

For more details on running a spatially lagged regression model and interpreting the outputs, see the chapter on spatially lagged models by Ward and Gleditsch (2008) available online here: https://methods.sagepub.com/book/spatial-regression-models/n2.xml

Let's run the original model again to remind ourselves of the paramters:

```{r, message=FALSE, cache=FALSE}
#Original Model
model2 <- lm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), data = LonWardProfiles)

tidy(model2)
```
##### Queen's case lag

Now run a spatially-lagged regression model with a queen's case weights matrix

```{r, message=FALSE, cache=FALSE}
library(spatialreg)

slag_dv_model2_queen <- lagsarlm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), 
               data = LonWardProfiles, 
               nb2listw(LWard_nb, style="C"), 
               method = "eigen")

#what do the outputs show?
tidy(slag_dv_model2_queen)

#glance() gives model stats but this need something produced from a linear model
#here we have used lagsarlm()
glance(slag_dv_model2_queen)

t<-summary(slag_dv_model2_queen)

sum(t$residuals)
```

Running the spatially-lagged model with a Queen's case spatial weights matrix reveals that in this example, there is an insignificant and small effect associated with the spatially lagged dependent variable. However, a different conception of neighbours we might get a different outcome

Here:

* Rho is our spatial lag (0.0051568) that measures the variable in the surrounding spatial areas as defined by the spatial weight matrix. We use this as an extra explanatory variable to account for clustering (identified by Moran's I). If significant it means that the GCSE scores in a unit vary based on the GCSE scores in the neighboring units. If it is positive it means as the GCSE scores increase in the surrounding units so does our central value

* Log likelihood shows how well the data fits the model (like the AIC, which we cover later), the higher the value the better the models fits the data.

* Likelihood ratio (LR) test shows if the addition of the lag is an improvement (from linear regression) and if that's significant. This code would give the same output...

```{r, eval=FALSE}
library(lmtest)
lrtest(slag_dv_model2_queen, model2)
```

* Lagrange Multiplier (LM) is a test for the absence of spatial autocorrelation in the lag model residuals. If significant then you can reject the Null (no spatial autocorrelation) and accept the alternative (is spatial autocorrelcation)

* Wald test (often not used in interpretation of lag models), it tests if the new parameters (the lag) should be included it in the model...if significant then the new variable improves the model fit and needs to be included. This is similar to the LR test and i've not seen a situation where one is significant and the other not. Probably why it's not used!

In this case we have spatial autocorrelation in the residuals of the model, but the model is not an improvement on OLS --- this can also be confirmed with the AIC score (we cover that later) but the lower it is the better. Here it is 5217, in OLS (model 2) it was 5215. The Log likelihood is the other way around but very close, model 2 (OLS) it was -2604, here it is -2603. 

##### Lag impacts

**Warning** according to Solymosi and Medina (2022) you must not not compare the coefficients of this to regular OLS...**Why ?**

Well in OLS recall we can use the coefficients to say...a 1 unit change in the independent variable means a drop or rise in the dependent (for a 1% increase in unauthorised absence from school GSCE scores to drop by -41.2 points). **BUT** here the model is not consistent as the observations will change based on the weight matrix neighbours selected which might vary (almost certainly in a distance based matrix). This means we have a direct effect (standard OLS) and then an indirect effect in the model (impact of the spatial lag).

We can compute these direct and indirect effects using code from Solymosi and Medina (2022) and the [spatialreg](https://r-spatial.github.io/spatialreg/reference/impacts.html) package. Here the `impacts()` function calculates the impact of the spatial lag. We can fit this to our entire spatial weights....

```{r, message=FALSE, cache=FALSE}

# weight list is just the code from the lagsarlm
weight_list<-nb2listw(LWard_knn, style="C")

imp <- impacts(slag_dv_model2_queen, listw=weight_list)

imp

```

Now it is appropriate to compare these coefficients to the OLS outputs...**however** if you have a very large matrix this might not work, instead a sparse matrix that uses approximation methods (see Solymosi and Medina (2022) and within that resource, Lesage and Pace 2009). This is beyond the scope of the content here, but essentially this makes the method faster on larger data...but only row standardised is permitted here...

```{r, message=FALSE, cache=FALSE}

slag_dv_model2_queen_row <- lagsarlm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), 
               data = LonWardProfiles, 
               nb2listw(LWard_nb, style="W"), 
               method = "eigen")


W <- as(weight_list, "CsparseMatrix")

trMatc <- trW(W, type="mult")
trMC <- trW(W, type="MC")

imp2 <- impacts(slag_dv_model2_queen_row, tr=trMatc, R=200)

imp3 <- impacts(slag_dv_model2_queen_row, tr=trMC, R=200)

imp2
imp3
```

We can also get the p-values (where an R is set, this is the number of simulations to use)...from the sparse computation

```{r, message=FALSE, cache=FALSE}

sum <- summary(imp2,  zstats=TRUE, short=TRUE)

sum

```

The results on the entire datasets will differ as that used `C` which is a globally standardised weight matrix.

In the sparse example, there are different two examples using slightly different arguments that control the sparse matrix, this is beyond the scope here (so don't worry about it) but for reference.... 

* `mult` which is (default) for powering a sparse matrix (with moderate or larger N, the matrix becomes dense, and may lead to swapping)

*  `MC` for Monte Carlo simulation of the traces (the first two simulated traces are replaced by their analytical equivalents)

The purpose of providing this extra step **is in case you have a large data set in the exam and wish to do compute the direct and indirect**.  

**However**, when discussing this with Adam, he believes the coefficients across models can be compared as essentially you are still trying to model the same dependent variable...what do you think?
  
For more details and another example see [Fitting and interpreting a spatially lagged model](https://maczokni.github.io/crime_mapping_textbook/spatial-regression-models.html#fitting-and-interpreting-a-spatially-lagged-model) by Solymosi and Medina (2022).

##### KNN case lag

Now let's run a model with nearest neigh ours as opposed to queens neighbours

```{r, message=FALSE, cache=FALSE}
#run a spatially-lagged regression model
slag_dv_model2_knn4 <- lagsarlm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), 
               data = LonWardProfiles, 
               nb2listw(LWard_knn, 
                        style="C"), 
               method = "eigen")

#what do the outputs show?
tidy(slag_dv_model2_knn4)
```

Using the 4 nearest neighbours instead of just considering all adjacent zones in the spatial weights matrix, the size and significance of the spatially lagged term changes quite dramatically. In the 4 nearest neighbour model it is both quite large, positive and statistically significant (<0.05), conversely the effects of unauthorised absence and (log (median house price)) are reduced. **Remember...this is how we interpret the coefficients...**

* Before a 1% increase (or 1 unit, it is % as the variable is %) in unauthorized absence meant GCSE scores dropped by -36.36 points, now they just drop by -28.5 points.

* Here as we have logged the median house price we must [follow the rules](https://data.library.virginia.edu/interpreting-log-transformations-in-a-linear-model/)...
  * Divide the coefficient by 100 (it was 12.65 it is now 9.29 = 0.1265 and 0.0929)
  * For every 1% increase in the independent variable (median house price) the dependent (GCSE scores) increases by around 0.09 points (previously 0.12)
  
What this means is that in our study area, the average GCSE score recorded in Wards across the city varies partially with the average GCSE score found in neighbouring Wards. Given the distribution of schools in the capital in relation to where pupils live, this makes sense as schools might draw pupils from a few close neighbouring wards rather than all neighbour bordering a particular Ward. 

Effectively, by ignoring the effects of spatial autocorrelation in the original OLS model, the impacts of unauthorised absence and affluence (as represented by average house price) were slightly overplayed or exaggerated (meaning the OLS coefficients were too high). 

We can also now check that the residuals from the spatially lagged model are now no-longer exhibiting spatial autocorrelation:

```{r, message=FALSE, cache=FALSE}
#write out the residuals

LonWardProfiles <- LonWardProfiles %>%
  mutate(slag_dv_model2_knn_resids = residuals(slag_dv_model2_knn4))

KNN4Moran <- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(slag_dv_model2_knn_resids)%>%
  pull()%>%
  moran.test(., Lward.knn_4_weight)%>%
  tidy()

KNN4Moran
```

#### The Spatial Error Model

Another way of coneptualising spatial dependence in regression models is not through values of the dependent variable in some areas affecting those in neighbouring areas (as they do in the spatial lag model), but in treating the spatial autocorrelation in the residuals as something that we need to deal with, perhaps reflecting some spatial autocorrelation amongst unobserved independent variables or some other mis-specification of the model. 

Ward and Gleditsch (2008) characterise this model as seeing spatial autocorrelation as a nuisance rather than being particularly informative, however it can still be handled within the model, albeit slightly differently.

The spatial error model can be written:

$$y_i = \beta_0 + \beta_1x_i + \lambda w_i.\xi_i + \epsilon_i$$

where

* $\xi_i$ is the spatial component of the error terms...in other words the residuals of the values in surrounding spatial units based on the weight matrix.

* $\lambda$ is a measure of correlation between neighbouring residuals.. "it indicates the extent to which the spatial component of the errors $\xi_i$ are correlated with one another for nearby observations" as per the weight matrix, Ward and Gleditsch (2008). **If there is no correlation between the then this defaults to normal OLS regression**

For more detail on the spatial error model, see Ward and Gleditsch (2008) -  https://methods.sagepub.com/Book/spatial-regression-models/n3.xml 

We can run a spatial error model on the same data below:

```{r, message=FALSE, cache=FALSE}
sem_model1 <- errorsarlm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014), 
               data = LonWardProfiles,
               nb2listw(LWard_knn, style="C"), 
               method = "eigen")

tidy(sem_model1)
```

Comparing the results of the spatial error model with the spatially lagged model and the original OLS model, the suggestion here is that the spatially correlated errors in residuals lead to an over-estimate of the importance of unauthorised absence in the OLS model and an under-estimate of the importance of affluence, represented by median house prices. Conversely, the spatial error model estimates higher parameter values for both variables when compared to the spatially lagged model. 

Note, here we can compare to OLS as there is no spatial lag.

Both the $\lambda$ parameter in the spatial error model and the $\rho$ parameter in the spatially lagged model are larger than their standard errors, so we can conclude that spatial dependence should be borne in mind when interpreteing the results of this regression model. 

### Key advice

The **lag** model accounts for situations where the value of the dependent variable in one area might be associated with or influenced by the values of that variable in neighbouring zones (however we choose to define neighbouring in our spatial weights matrix). With our example, average GCSE scores in one neighbourhood might be related to average GCSE scores in another as the students in both neighbourhoods could attend the same school. You may be able to think of other examples where similar associations may occur. You might run a lag model if you identify spatial autocorrelation in the dependent variable (closer spatial units have similar values) with Moran’s I.

The **error** model deals with spatial autocorrelation (closer spatial units have similar values) of the residuals (vertical distance between your point and line of model – errors – over-predictions or under-predictions) again, potentially revealed though a Moran’s I analysis. The error model is not assuming that neighbouring independent variables are influencing the dependent variable but rather the assumption is of an **issue with the specification of the model or the data used** (e.g. clustered errors are due to some un-observed clustered variables not included in the model). For example, GCSE scores may be similar in bordering neighbourhoods but not because students attend the same school but because students in these neighbouring places come from similar socio-economic or cultural backgrounds and this was not included as an independent variable in the original model. There is no spatial process (no cross Borough interaction) just a cluster of an un-accounted for but influential variable.

Usually you might run a **lag** model when you have an idea of what is causing the spatial autocorrelation in the dependent variable and an **error** model when you aren’t sure what might be missing. However, you can also use a more scientific method - the Lagrange Multiplier test.

But! recall from a few weeks ago when I made a big deal of type of standardisation for the spatial weight matrix? This test **expects** row standardisation.  

The Lagrange multiple tests are within the function `lm.LMtests` from the package `spdep`:

* `LMerr` is the spatial error model test
* `LMlag` is the lagged test

With each also having a robust form, being robust to insensitivities to changes (e.g. outliers, non-normality). 

```{r}
library(spdep)

Lward.queens_weight_ROW <- LWard_nb %>%
  nb2listw(., style="W")

lm.LMtests(model2, Lward.queens_weight_ROW, test = c("LMerr","LMlag","RLMerr","RLMlag","SARMA"))
 
```

Here, we look to see if either the standard tests `LMerr` or `LMlag` are significant (p <0.05), if one is then that is our answer. If both are move to the robust tests and apply the same rule.

If everything is significant then Prof Anselin (2008) proposed:

* One robust test will often be much more significant than the other. In which select the most significant model.

* In the case both a highly significant select the largest test statistic value - but here, there may be violations of the regression assumptions

Here, based on this test and guidance which is the right model to select? 

For more information on the Lagrange Multipler see:

* [Lagrange multiple tests from crime mapping in R](https://maczokni.github.io/crime_mapping_textbook/spatial-regression-models.html#activity-4-lagrange-multiplier-tests)

* [Luc Anselin's 2003 tutorial](http://labs.bio.unc.edu/Buckley/documents/AnselinIntroSpatRegres.pdf)

**Geographically weighted regression (GWR)** will be explored next, but simply assumes that spatial autocorrelation is not a problem, but a global regression model of all our data doesn't have the same regression slope - e.g. in certain areas (Boroughs, Wards) the relationship is different, termed non-stationary. GWR runs a local regression model for adjoining spatial units and shows how the coefficients can vary over the study area.

### Which model to use

Usually you will run OLS regression first then look for spatial autocorrelation of the residuals (Moran's I).

Once at this stage you need to make a decision about the model:

* Is it a global model (error / lag) or a local model (GWR)?
* Can a single model (error/lag) be fitted to the study area?
* Is the spatial autocorrelation a problem (error) or showing local trends (GWR)?

Of course you could do a OLS, spatial lag and GWR as long as they all contribute something to your analysis. 

### More data

We will now read in some extra data which we will use shortly

```{r, message=FALSE, cache=FALSE}
extradata <- read_csv("https://www.dropbox.com/s/qay9q1jwpffxcqj/LondonAdditionalDataFixed.csv?raw=1")

#add the extra data too
LonWardProfiles <- LonWardProfiles%>%
  left_join(., 
            extradata, 
            by = c("gss_code" = "Wardcode"))%>%
  clean_names()

#print some of the column names
LonWardProfiles%>%
  names()%>%
  tail(., n=10)
```

### Extending your regression model - Dummy Variables

What if instead of fitting one line to our cloud of points, we could fit several depending on whether the Wards we were analysing fell into some or other group. What if the relationship between attending school and achieving good exam results varied between inner and outer London, for example. Could we test for that? Well yes we can - quite easily in fact.

If we colour the points representing Wards for Inner and Outer London differently, we can start to see that there might be something interesting going on. Using 2011 data (as there are not the rounding errors that there are in the more recent data), there seems to be a stronger relationship between absence and GCSE scores in Outer London than Inner London. We can test for this in a standard linear regression model.  

```{r, message=FALSE, cache=FALSE}
p <- ggplot(LonWardProfiles, 
            aes(x=unauth_absence_schools11, 
                y=average_gcse_capped_point_scores_2014))
p + geom_point(aes(colour = inner_outer)) 
```

Dummy variables are always **categorical** data (inner or outer London, or red / blue etc.). When we incorporate them into a regression model, they serve the purpose of splitting our analysis into groups. In the graph above, it would mean, effectively, having a separate regression line for the red points and a separate line for the blue points. 

Let's try it!

```{r, message=FALSE, cache=FALSE}
#first, let's make sure R is reading our InnerOuter variable as a factor
#see what it is at the moment...
isitfactor <- LonWardProfiles %>%
  dplyr::select(inner_outer)%>%
  summarise_all(class)

isitfactor

# change to factor

LonWardProfiles<- LonWardProfiles %>%
  mutate(inner_outer=as.factor(inner_outer))

#now run the model
model3 <- lm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014) + 
               inner_outer, 
             data = LonWardProfiles)
 
tidy(model3)
```

So how can we interpret this?

Well, the dummy variable is statistically significant and the coefficient tells us the difference between the two groups (Inner and Outer London) we are comparing. In this case, it is telling us that living in a Ward in **outer** London will improve your average GCSE score by 10.93 points, on average, compared to if you lived in Inner London. The R-squared has increased slightly, but not by much. 

You will notice that despite there being two values in our dummy variable (Inner and Outer), we only get one coefficient. This is because with dummy variables, one value is always considered to be the control (comparison/reference) group. In this case we are comparing Outer London to Inner London. If our dummy variable had more than 2 levels we would have more coefficients, but always one as the reference.

The order in which the dummy comparisons are made is determined by what is known as a 'contrast matrix'. This determines the treatment group (1) and the control (reference) group (0). We can view the contrast matrix using the `contrasts()` function:  

```{r, message=FALSE, cache=FALSE}
contrasts(LonWardProfiles$inner_outer)
```

If we want to change the reference group, there are various ways of doing this. We can use the `contrasts()` function, or we can use the `relevel()` function. Let's try it:

```{r, message=FALSE, cache=FALSE}

LonWardProfiles <- LonWardProfiles %>%
  mutate(inner_outer = relevel(inner_outer, 
                               ref="Outer"))

model3 <- lm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
               log(median_house_price_2014) + 
               inner_outer, 
             data = LonWardProfiles)

tidy(model3)
```

You will notice that the only thing that has changed in the model is that the coefficient for the inner_outer variable now relates to Inner London and is now negative (meaning that living in Inner London is likely to reduce your average GCSE score by 10.93 points compared to Outer London). The rest of the model is exactly the same. 

### TASK: Investigating Further - Adding More Explanatory Variables into a multiple regression model

Now it's your turn. You have been shown how you could begin to model average GCSE scores across London, but the models we have built so far have been fairly simple in terms of explanatory variables. 

You should try and build the optimum model of GCSE performance from your data in your LondonWards dataset. Experiment with adding different variables - when building a regression model in this way, you are trying to hit a sweet spot between increasing your R-squared value as much as possible, but with as few explanatory variables as possible.

#### A few things to watch out for...

* You should never just throw variables at a model without a good theoretical reason for why they might have an influence. Choose your variables carefully!

* Be prepared to take variables out of your model either if a new variable **confounds** (becomes more important than) earlier variables or turns out not to be significant. 

For example, let's try adding the rate of drugs related crime (logged as it is a positively skewed variable, where as the log is normal) and the number of cars per household... are these variables significant? What happens to the spatial errors in your models?

## Task 3 - Spatial Non-stationarity and Geographically Weighted Regression Models (GWR)

Here's my final model from the last section:

```{r, message=FALSE, cache=FALSE}
#select some variables from the data file
myvars <- LonWardProfiles %>%
  dplyr::select(average_gcse_capped_point_scores_2014,
         unauthorised_absence_in_all_schools_percent_2013,
         median_house_price_2014,
         rate_of_job_seekers_allowance_jsa_claimants_2015,
         percent_with_level_4_qualifications_and_above_2011,
         inner_outer)

#check their correlations are OK
Correlation_myvars <- myvars %>%
  st_drop_geometry()%>%
  dplyr::select(-inner_outer)%>%
  correlate()

#run a final OLS model
model_final <- lm(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
                    log(median_house_price_2014) + 
                    inner_outer + 
                    rate_of_job_seekers_allowance_jsa_claimants_2015 +
                    percent_with_level_4_qualifications_and_above_2011, 
                  data = myvars)

tidy(model_final)

LonWardProfiles <- LonWardProfiles %>%
  mutate(model_final_res = residuals(model_final))

par(mfrow=c(2,2))
plot(model_final)
```

```{r, message=FALSE, cache=FALSE}
qtm(LonWardProfiles, fill = "model_final_res")

final_model_Moran <- LonWardProfiles %>%
  st_drop_geometry()%>%
  dplyr::select(model_final_res)%>%
  pull()%>%
  moran.test(., Lward.knn_4_weight)%>%
  tidy()

final_model_Moran
```

Now, we probably could stop at running a spatial error model at this point, but it could be that rather than spatial autocorrelation causing problems with our model, it might be that a "global" regression model does not capture the full story. In some parts of our study area, the relationships between the dependent and independent variable may not exhibit the same slope coefficient. While, for example, increases in unauthorised absence usually are negatively correlated with GCSE score (students missing school results in lower exam scores), in some parts of the city, they could be positively correlated (in affluent parts of the city, rich parents may enrol their children for just part of the year and then live elsewhere in the world for another part of the year, leading to inflated unauthorised absence figures. Ski holidays are cheaper during the school term, but the pupils will still have all of the other advantages of living in a well off household that will benefit their exam scores. 

If this occurs, then we have **'non-stationarity'** - this is when the global model does not represent the relationships between variables that might vary locally.

This part of the practical will only skirt the edges of GWR, for much more detail you should visit the GWR website which is produced and maintained by Prof Chris Brunsdon and Dr Martin Charlton who originally developed the technique - http://gwr.nuim.ie/

There are various packages which will carry out GWR in R, for this pracical we we use `spgwr` (mainly because it was the first one I came across), although you could also use `GWmodel` or `gwrr`. 

I should also acknowledge [the guide on GWR produced by the University of Bristol](http://www.bris.ac.uk/cmpo/events/2009/segregation/gwr.pdf), which was a great help when producing this exercise.

```{r message=FALSE, warning=FALSE, cache=FALSE}
library(spgwr)

coordsW2 <- st_coordinates(coordsW)

LonWardProfiles2 <- cbind(LonWardProfiles,coordsW2)

GWRbandwidth <- gwr.sel(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
                    log(median_house_price_2014) + 
                    inner_outer + 
                    rate_of_job_seekers_allowance_jsa_claimants_2015 +
                    percent_with_level_4_qualifications_and_above_2011, 
                  data = LonWardProfiles2, 
                        coords=cbind(LonWardProfiles2$X, LonWardProfiles2$Y),
                  adapt=T)
GWRbandwidth
```

Setting `adapt=T` here means to automatically find the proportion of observations for the weighting using k nearest neighbours (an adaptive bandwidth), False would mean a global bandwidth and that would be in meters (as our data is projected).

Occasionally data can come with longitude and latitude as columns (e.g. WGS84) and we can use this straight in the function to save making centroids, calculating the coordinates and then joining - the argument for this is `longlat=TRUE` and then the columns selected in the `coords` argument e.g. `coords=cbind(long, lat)`. The distance result will then be in KM. 

The optimal bandwidth is about 0.015 meaning 1.5% of all the total spatial units should be used for the local regression based on k-nearest neighbours. Which is about 9 of the 626 wards. 

This approach uses cross validation to search for the optimal bandwidth, it compares different bandwidths to minimise model residuals --- this is why we specify the regression model within `gwr.sel()`. It does this with a Gaussian weighting scheme (which is the default) - meaning that near points have greater influence in the regression and the influence decreases with distance - there are variations of this, but Gaussian is a fine to use in most applications. To change this we would set the argument  `gweight = gwr.Gauss` in the `gwr.sel()` function --- `gwr.bisquare()` is the other option. We don't go into cross validation in this module. 

**However** we could set either the number of neighbours considered or the distance within which to considered points ourselves, manually, in the `gwr()` function below.

To set the number of other neighbours considered simply change the `adapt` argument to the value you want - it must be the number of neighbours divided by the total (e.g. to consider 20 neighbours it would be 20/626 and you'd use the value of 0.0319)

The set the bandwidth, **remove** the `adapt` argument and replace it with `bandwidth` and set it, in this case, in meters.

To conclude, we can:

* set the bandwidth in `gwr.sel()` automatically using:
  * the number of neighbors
  * a distance threshold
  
* Or, we can set it manually in `gwr()` using:
  * a number of neighbors
  * a distance threshold


::: {.infobox .tip data-latex="{note}"}
**BUT** a problem with setting a fixed bandwidth is we assume that all variables have the same relationship across **the same space (using the same number of neighbours or distance)**...(such as rate_of_job_seekers_allowance_jsa_claimants_2015 and percent_with_level_4_qualifications_and_above_2011). We can let these bandwidths vary as some relationships will operate on different spatial scales...this is called **Multiscale GWR** and Lex Comber recently said that all GWR should be Multisacle (oops!). We have already covered a lot here so i won't go into it. If you are interested Lex has a [good tutorial on Multiscale GWR](https://rpubs.com/lexcomber/INIA_Session7)
:::


```{r message=FALSE, warning=FALSE}
#run the gwr model
gwr.model = gwr(average_gcse_capped_point_scores_2014 ~ unauthorised_absence_in_all_schools_percent_2013 + 
                    log(median_house_price_2014) + 
                    inner_outer + 
                    rate_of_job_seekers_allowance_jsa_claimants_2015 +
                    percent_with_level_4_qualifications_and_above_2011, 
                  data = LonWardProfiles2, 
                coords=cbind(LonWardProfiles2$X, LonWardProfiles2$Y), 
                adapt=GWRbandwidth,
                #matrix output
                hatmatrix=TRUE,
                #standard error
                se.fit=TRUE)

#print the results of the model
gwr.model
```

The output from the GWR model reveals how the coefficients vary across the 626 Wards in our London Study region. You will see how the global coefficients are exactly the same as the coefficients in the earlier `lm` model. In this particular model (yours will look a little different if you have used different explanatory variables), if we take unauthorised absence from school, we can see that the coefficients range from a minimum value of -47.06 (1 unit change in unauthorised absence resulting in a drop in average GCSE score of -47.06) to +6.8 (1 unit change in unauthorised absence resulting in an increase in average GCSE score of +6.8). For half of the wards in the dataset, as unauthorised absence rises by 1 point, GCSE scores will decrease between -30.80 and -14.34 points (the inter-quartile range between the 1st Qu and the 3rd Qu). 

You will notice that the R-Squared value (Quasi global R-squared) has improved - this is not uncommon for GWR models, but it doesn't necessarily mean they are definitely better than global models. The small number of cases under the kernel means that GW models have been criticised for lacking statistical robustness.

The best way to compare models is with the **AIC (Akaike Information Criterion) or for smaller sample sizes the sample-size adjusted AICc**, especially when you number of points is [less than 40!](https://towardsdatascience.com/introduction-to-aic-akaike-information-criterion-9c9ba1c96ced) Which it will be in GWR. The models must also be using the same data and be over the same study area! 

AIC is calculated using the:

* number of independent variables
* maximum likelihood estimate of the model (how well the model reproduces the data).

The lower the value the better the better the model fit is, see [scribbr](https://www.scribbr.com/statistics/akaike-information-criterion/)if you want to know more here..although this is enough to get you through most situations. 

Coefficient ranges can also be seen for the other variables and they suggest some interesting spatial patterning. To explore this we can plot the GWR coefficients for different variables. Firstly we can attach the coefficients to our original dataframe - this can be achieved simply as the coefficients for each ward appear in the same order in our spatial points dataframe as they do in the original dataframe.


```{r, message=FALSE, cache=FALSE}
results <- as.data.frame(gwr.model$SDF)
names(results)
#attach coefficients to original SF


LonWardProfiles2 <- LonWardProfiles %>%
  mutate(coefUnauthAbs = results$unauthorised_absence_in_all_schools_percent_2013,
         coefHousePrice = results$log.median_house_price_2014.,
         coefJSA = rate_of_job_seekers_allowance_jsa_claimants_2015,
         coefLev4Qual = percent_with_level_4_qualifications_and_above_2011)


```


```{r, message=FALSE, cache=FALSE}
tm_shape(LonWardProfiles2) +
  tm_polygons(col = "coefUnauthAbs", 
              palette = "RdBu", 
              alpha = 0.5)
```

Now how would you plot the House price coeffeicent, Job seekers allowance and level 4 qualification coefficient?

```{r, message=FALSE, cache=FALSE, include=FALSE}
tm_shape(LonWardProfiles2) +
  tm_polygons(col = "coefHousePrice", 
              palette = "RdBu")
```

```{r, message=FALSE, cache=FALSE, include=FALSE}
tm_shape(LonWardProfiles2) +
  tm_polygons(col = "coefJSA", 
              palette = "PuOr")
```

```{r, message=FALSE, cache=FALSE, include=FALSE}
tm_shape(LonWardProfiles2) +
  tm_polygons(col = "coefLev4Qual", 
              palette = "PRGn")
```

Taking the first plot, which is for the unauthorised absence coefficients, we can see that for the majority of boroughs in London, there is the negative relationship we would expect - i.e. as unauthorised absence goes up, exam scores go down. For three boroughs (Westminster, Kensington & Chelsea and Hammersmith and Fulham, as well as an area near Bexleyheath in South East London - some of the richest in London), however, the relationship is positive - as unauthorised school absence increases, so does average GCSE score. This is a very interesting pattern and counterintuitive pattern, but may partly be explained the multiple homes owned by many living in these boroughs (students living in different parts of the country and indeed the world for significant periods of the year), foreign holidays and the over representation of private schooling of those living in these areas. If this is not the case and unauthorised absence from school is reflecting the unauthorised absence of poorer students attending local, inner city schools, then high GCSE grades may also reflect the achievements of those who are sent away to expensive fee-paying schools elsewhere in the country and who return to their parental homes later in the year. Either way, these factors could explain these results. 
Of course, these results may not be statistically significant across the whole of London. Roughly speaking, if a coefficient estimate is more than 2 standard errors away from zero, then it is "statistically significant".

Remember from earlier the standard error is "the average amount the coefficient varies from the average value of the dependent variable (its standard deviation). So, for a 1% increase in unauthorised absence from school, while the model says we might expect GSCE scores to drop by -41.2 points, this might vary, on average, by about 1.9 points. As a rule of thumb, we are looking for a lower value in the standard error relative to the size of the coefficient."

To calculate standard errors, for each variable you can use a formula similar to this:

```{r, message=FALSE, cache=FALSE}

#run the significance test
sigTest = abs(gwr.model$SDF$"log(median_house_price_2014)")-2 * gwr.model$SDF$"log(median_house_price_2014)_se"


#store significance results
LonWardProfiles2 <- LonWardProfiles2 %>%
  mutate(GWRUnauthSig = sigTest)
```

If this is greater than zero (i.e. the estimate is more than two standard errors away from zero), it is very unlikely that the true value is zero, i.e. it is statistically significant (at nearly the 95% confidence level)

This is a combination of two ideas:

* 95% of data in a normal distribution is within two standard deviations of the mean
* Statistical significance in a regression is normally measured at the 95% level. If the p-value is less than 5% — 0.05 — then there's a 95% probability that a coefficient as large as you are observing didn't occur by chance

Combining these two means if...

* the coefficient is large in relation to its standard error **and**
* the p-value tells you if that largeness statistically acceptable - at the 95% level (less than 5% — 0.05)

You can be confident that in your sample, nearly all of the time, that is a real and reliable coefficient value.

You should now calculate these for each variable in your GWR model and See if you can plot them on a map, for example: 

```{r, message=FALSE, cache=FALSE}
tm_shape(LonWardProfiles2) +
  tm_polygons(col = "GWRUnauthSig", 
              palette = "RdYlBu")
```

From the results of your GWR exercise, what are you able to conclude about the geographical variation in your explanatory variables when predicting your dependent variable? 

## Feedback

Was anything that we explained unclear this week or was something really clear...let us know using the [feedback form](https://forms.gle/w2GUDYc7tSavGy7r6). It's anonymous and we'll use the responses to clear any issues up in the future / adapt the material. 


<!--chapter:end:08-prac8.Rmd-->

# (PART\*) Extra {-}

# Module resources {-}

```{r echo=FALSE}
library(knitr)
```

Listed below are some helpful website, books, datasets and tools you might find useful.

## Markscheme

The markscheme can be found on Moodle with a break down of how much percent is given to each criteron. Read it closely **and often** when preparing for the final exam.

## Old practicals

The module has developed over several years and there is some content that we no longer cover but still exsits in old practical books, specifically:

* [interpolation](https://andrewmaclachlan.github.io/CASA0005repo_20192020/rasters-descriptive-statistics-and-interpolation.html#part-3-interpolation) 
* [cross validation, Rigde, LASSO and elastic net regression](https://andrewmaclachlan.github.io/CASA0005repo_20192020/advanced-r-maup-and-more-regression.html#regression-relationships)
* [Online mapping / Shiny basics](https://andrewmaclachlan.github.io/CASA0005repo_20192020/online-mapping-descriptive-statistics.html#part-b-online-mapping)
* [Bootstrap resampling in regression](https://andrewmaclachlan.github.io/CASA0005repo_20202021/gwr-and-spatially-lagged-regression.html#bootstrap-resampling)
* [Temperature analysis using Landsat data](https://andrewmaclachlan.github.io/CASA0005repo_20212022/advanced-raster-analysis.html)

## Events / meet other spatial data professionals

The [UK ESRI conference](https://www.esriuk.com/en-gb/about/events/ac/overview) is normally free to go to and whilst (in my opinion) it's mostly just ESRI marketing their latest products it is good to go along and see how industry are using spatial software. It might also be useful for dissertation ideas / networking. 

[Missing maps](http://www.missingmaps.org/events/)

[LondonR group](https://www.londonr.org/#content)

[R Ladies](https://www.meetup.com/pro/rladies/)

## Cool stuff to explore

New packages and functions that i've recently come across that are worth exploring..

<div class="col2">
* [RStudio cloud](https://rstudio.cloud/) --- like RStudio but online, great for collaborating, although it now (2020) has caps on how much you can use it.
* [Animating plots](https://rpubs.com/jgleeson/ripple-effect)
* [Bivariate maps](https://timogrossenbacher.ch/2019/04/bivariate-maps-with-ggplot2-and-sf/)
* [Rayshader](https://www.rayshader.com/)
* [R Cartography package](http://riatelab.github.io/cartography/docs/)
* [Data is beautiful reddit](https://www.reddit.com/r/dataisbeautiful/)
* [Network visualisation](https://kateto.net/network-visualization)
</div><br/>

## Books/reading resources

There are a lot of free online books for geospatial analysis, especially using R, check out:

<div class="col2">

* [Data Visualization A practical introduction](https://socviz.co/index.html#preface)
* [R Programming for Data Science](https://bookdown.org/rdpeng/rprogdatascience/)
* [Everything you need for Exploratory Data Analysis & Visualization](https://edav.info/index.html)
* [What They Forgot to Teach You About R](https://whattheyforgot.org/)
* [RMarkdown for Scientists](https://rmd4sci.njtierney.com/ )
* [RStudio recommended books](https://www.rstudio.com/resources/training/books/)
* [R Graphics Cookbook](https://r-graphics.org/)
* [Hadley Wickham's website](http://hadley.nz/)
* [Geocomputation with R ](https://geocompr.robinlovelace.net/)
* [Happy Git and GitHub for the useR](https://happygitwithr.com/)
* [Bookdown information pages](https://bookdown.org/)
* [Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com/index.html)
* [YaRrr! The Pirate’s Guide to R](https://bookdown.org/ndphillips/YaRrr/)
* [Engineering Production-Grade Shiny Apps](https://thinkr-open.github.io/building-shiny-apps-workflow/)
* [Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](http://www.paulamoraga.com/book-geospatial/index.html)
* [Statistical Inference via Data Science](https://moderndive.com/)
* [Fundamentals of Data Visualization](https://serialmentor.com/dataviz/index.html)
* [21 Recipes for Mining Tiwtter Data with rtweet](https://rud.is/books/21-recipes/)
* [Learning statistics with R: A tutorial for psychology students and other beginners](https://learningstatisticswithr.com/book/)
* [Crime mapping in R](Crime Mapping in R)

</div><br/>

If you want to produce more efficent R code then have a look at the [Efficient R programming](https://csgillespie.github.io/efficientR/index.html) book.

...that's a lot of books, should we read all of them? No, be selective, a lot of the same material will be covered in each book. Follow your interests, read widely and think about how you could apply these ideas / concepts to different topics or disciplines!

## New developments

Every year there is a useR conference that provides a load to tutorials on the latest developments and research...check them out here: 
<div class="col2">
* [R Weekly, podcast with weekly highlights and new developments in R](https://rweekly.fireside.fm/)
* [Data to viz, really great website with code](https://www.data-to-viz.com/)
* [Modern data plots](https://moderndata.plot.ly/visualizing-geo-spatial-data-with-sf-and-plotly/)
* [Make graphics like the BBC](https://github.com/bbc/bbplot/blob/master/chart_examples/bbplot_example_plots.png)
* [UseR2019 tutorials](http://www.user2019.fr/tutorials/)
* [UseR2019 materials](https://github.com/sowla/useR2019-materials)
</div><br/>

Other useful tutorials can be found at:

<div class="col2">
* [rweekly](https://rweekly.org/)
* [Chrisbrusdon's RPubs](http://rpubs.com/chrisbrunsdon/)
* [Alexsingleton's RPubs](http://rpubs.com/alexsingleton/)
* [Tutorial for cropping a raster interactively](https://mgimond.github.io/megug2017/#cropping-a-raster-interactively)
* [simplystatistics](https://simplystatistics.org/)
</div><br/>

### Twitter

```{r echo=FALSE, out.width = "300pt", fig.align='center', cache=FALSE, results=FALSE}
knitr::include_graphics('allisonhorst_images/welcome_to_rstats_twitter.png')
```

R package authors regularly tweet with updates and new developments. If twitter is your thing go and follow these people to start with...and anyone else you come across...

<div class="col2">

* [Hadley Wickham](https://twitter.com/hadleywickham)
* [Mara Averick](https://twitter.com/dataandme)
* [Carl Howe](https://twitter.com/cdhowe)
* [Alison Hill](https://twitter.com/apreshill)
* [Robin Lovelace](https://twitter.com/robinlovelace)
* [Yihui Xie](https://twitter.com/xieyihui)
* [Hannah Frick](https://twitter.com/hfcfrick)
* [Jakub Nowosad](https://twitter.com/jakub_nowosad)
* [Nick Tierney](https://twitter.com/nj_tierney)
* [#rstats](https://twitter.com/search?q=%23rstats&src=typed_query)
* [R packages you might have missed](https://twitter.com/icymi_r)
* [R for data science](https://twitter.com/rstats4ds)
* [We are R-Ladies](https://twitter.com/WeAreRLadies)
* [R-Ladies Global](https://twitter.com/RLadiesGlobal)

</div><br/>

I often learn about a lot of new R pacakges / code / isuues from Twitter!

## Data

This is by no means an extensive data list, but summarises data used within some of the practicals alongside a few additions that you might want to explore when sourcing data for your assignments. You are **not limited** to these data sets for you assessment.

<div class="col2">

* [Google dataset search](https://datasetsearch.research.google.com/)
* [Tesco store data (London)](https://www.nature.com/articles/s41597-020-0397-7)
* [NHS data (ready for R)](https://nhs-r-community.github.io/NHSRdatasets/)
* [US City Open Data Census](http://us-cities.survey.okfn.org/)
* [nomis](https://www.nomisweb.co.uk/)
* [ONS geoportal](https://geoportal.statistics.gov.uk/)
* [UK data service](https://census.edina.ac.uk/)
* [ONS](https://www.ons.gov.uk/)
* [Edina (e.g. OS mastermap)](https://digimap.edina.ac.uk/)
* [Open Topography](https://opentopography.org/)
* [USGS Earth Explorer](https://earthexplorer.usgs.gov/)
* [Geofabrik (OSM data)](https://www.geofabrik.de/)
* [Global weather data (points)](https://rp5.ru/Weather_in_the_world)
* [London data store](https://data.london.gov.uk/)
* [Air b n b data](http://insideairbnb.com/get-the-data.html)
* [NASA SocioEconomic Data and Applications Center (SEDAC)](https://sedac.ciesin.columbia.edu/)
* [UN environmental data explorer](http://geodata.grid.unep.ch/)
* [World pop](https://www.worldpop.org/)
* [World pop github](https://github.com/wpgp)
* [DIVA-GIS](https://www.diva-gis.org/)
* [DEFRA](https://environment.data.gov.uk/)
* [US Cesus data](https://www.census.gov/data.html)
* [TFL open data](https://tfl.gov.uk/info-for/open-data-users/our-open-data?intcmp=3671#on-this-page-2)
* [TFL cycling data](https://cycling.data.tfl.gov.uk/)
* [EU tourism data](https://ec.europa.eu/eurostat/statistics-explained/index.php/Tourism_statistics)
* [NASA EARTHDATA](https://earthdata.nasa.gov/)
* [Camden air action](https://camdenairaction.wordpress.com/2017/02/20/schools-monitoring-project-spring-2017/)
* [Kings data on air pollution](https://www.londonair.org.uk/LondonAir/Default.aspx)
* [Uber travel time data](https://movement.uber.com/?lang=en-GB)
* [Eurostat](https://ec.europa.eu/eurostat)
* [London Tube PM2.5 levels](https://www.ft.com/content/6f381ad4-fef7-11e9-be59-e49b2a136b8d)
* [Bike docking data in an R package](https://docs.ropensci.org/bikedata/)
* [UK COVID data](https://coronavirus.data.gov.uk/)
* [R package for COVID data](https://github.com/RamiKrispin/coronavirus)
* [Tidy Tuesday data (although look for spatial data)](https://github.com/rfordatascience/tidytuesday)
* [Correct statistical tests](https://stats.idre.ucla.edu/other/mult-pkg/whatstat/)

</div><br/>

## Data lists

[Awesome public datasets](https://github.com/awesomedata/awesome-public-datasets) have a wide range all data (some geographic, some not): 
[Robin Wilson](https://twitter.com/sciremotesense) has authored one of [the most extensive data lists that i've come across](https://freegisdata.rtwilson.com/)

<!--chapter:end:12-assignment_resources.Rmd-->

# Extra reproducibility {-}

This file contains extra notes that aren't required for the module, but might be if you get stuck in future analysis. 

## Git and GitHub

### Back in time

#### Git

Here, we're going to use code seen [in the section of existing project (way 3)](#If have have an existing project - way 3).

To quick recap here, i have an RProject with some files in, one of which is the test_file.R seen in the [in the section of existing project (way 3)](#If have have an existing project - way 3).

We also added some code to this file [in the section pulling from GitHub](#Pull from GitHub).

Now, we are going to add some more code then go back in time to remove it. I've added `z<-5+5` to my script and you can see the file has come up in the Git tab (also called the Git working directory) on the right hand side.

```{r echo=FALSE, out.width = "800pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/backtime1.png')
```

Now, as we have done before, Commit(in the Git tab) then the review changes window comes up. Add a commit message, click stage and the Commit. ** Don't push to GitHub yet**

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/backtime2.png')
```

But wait, you've just received an urgent email (probably using the high importance flag) that the variable `z` should be deleted, renamed `t` and be equal to 2. Now, of course, we could just rename it here manually and Commit our changes. But what if you have a large project (like this book!) and make mistakes on several scripts or RMarkdown documents and you need to undo them (like the undo button in Microsoft software). Here we are going to show that.

To do this we need to clearly know what we are trying to acheive, for us it's easy, go back one commit.

We have to use the shell again, click the cog icon then shell..

Now, there are two commands we can use here `git reset --hard HEAD~1` or `git reset --soft HEAD~1`. These simply tell Git to reset to Head-1 commit (your current commit is the Head). Changing the number will alter how many commits you go back. Hard will delete all the changes in the previous commit, soft will move the changes we committed to the Git tab, reversing out commit --- always use soft!

Type the command `git reset --soft HEAD~1`, the press enter...

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/backtime3.png')
```

You'll see that the `test_file.R`  has moved back to the Git tab. Now if you have forgotten what changes you actually made in the last commit, click the Diff icon (next to Commit) and it will show the changes made to each file.

#### GitHub

>This section follows on from what we've just been through, however, now will we look at how to go back in time once you have pushed to GitHub

So change `z` to `t` and assign it a value of 2+1. Stage the file, commit to git then now push to GitHub. Think of this as case (a)

But wait...you missed off an extra 1, `t` should be 2+1+1. Add the extra 1 commit to git then now push to GitHub.  Think of this as case (b)

But wait (again!)...more incoming news from management...`t` is wrong, is should be assigned to only 2+1,....but do they not know we've already pushed to GitHub several times!!

If we use `reset` once we've pushed to GitHub it will rewrite the commit history and won't match with GitHub, so if you tried to push to GitHub you will get an error saying the tip of your local branch is behind the remote. This is because you have done back in time locally. It will ask you to pull the changes from the remote. If you have `reset`, made changes, tried to push, got an error, tried to pull --- you will likely get a merge conflict message that you have to correct manually. 

However, we can instead use `revert` to maintain the history and avoid any conflicts --- revert adds a new commit at then end of the 'chain' of commits. In our case (b) is the current head, it will add a new commit that is our original (a) to the end of the chain. On the other hand `reset` will move your local main (or other branch) back in the chain of commits,  but if you moved your local git back whilst your remote (GitHub) remains further along the chain this will cause an error and merge conflicts!

To use git `revert` you have two options either just: `git revert HEAD` or `git revert [input commit ID]` - but just get the commit ID for the latest commit nothing before it! Every commit you make will have an ID (called an SHA). To see the SHA just go to Diff (in the Git tab) > History (top left of the review changes window) --- note down your SHA and use it in the shell command.

Ok, so to use `revert` go to the shell and enter `git revert HEAD`

You will probably be met with the VIM (or viewport) window. The best course of action is to input `:q` to quit and accept the default commit message. You will see already that my `test_file.R` has already been placed back in the Git tab and `t<-2+1` again.

```{r echo=FALSE, out.width = "600pt", fig.align='center', cache=FALSE}
knitr::include_graphics('prac4_images/VIM.png')
```

If you really want to change the commit message then you need to get into insert mode by typing `i` > modify text > exit the insert mode with Ctrl+C then > `:q` to quit. Thanks to the article by [Melanie Frazier](https://ohi-science.org/news/github-going-back-in-time) for this information.

::: {.infobox .warning data-latex="{note}"}
If you are storing your R project in a folder that is synchronises online (e.g. OneDrive) you might have issues with this. When you use `revert` git locks a file which mean it can't synchronise, if you try and do another `revert` git will not know who you are. It looks like the process of reverting still happens, but just be careful!
:::

Also if you want to go back several commits as opposed to just one you must write the code as `git revert HEAD HEAD~1 HEAD~2` and so on. Remember HEAD is the last commit you sent to Github, HEAD~1 the one before etc.

You could also specify this as `git revert HEAD~2..HEAD`, where i think it's possible to replace HEAD~2 with a commit ID. 

[Boris Serebrov](http://serebrov.github.io/html/2014-01-04-git-revert-multiple-recent-comments.html) explains more advance usage of `revert` very well.

#### One final trick

What if you wanted to go back in time and restart from that point. Of course you could use revert. However another possible way is to trick GitHub by combining ` git reset --hard` and  `git reset --soft`. First do a hard reset to using the commit ID you want to go back to...

1.  `git reset --hard commit ID`

Then do a soft reset to trick git to moving the pointer back to the end (or back to head), which is what the remote is expecting 

1.  `git reset --soft HEAD@{1}`

Then commit `git commit -m "going back to x commit` (or with the commit button) and push `git push` (or with the push button).

## renv

Have you ever created an R script, come back to it  later and wonder why it's not working correctly? It's probably because of package updates.  

`renv` (pronounced R - env) can capture the packages used in your project and re-create your current library. You simply:

1. Create a new project - `renv::init()`
1. Create a snapshot - `renv::snapshot()`
1. Call the snapshot to load - `renv::restore()`

The package information and dependencies are stored in a `renv.lock` file.

When R loads a package it gets it from the library path, which is where the packages live. Sometimes there are two libraries a system and a user library - use `.libPaths()`. The system library = the packages with R, the user library = packages you have installed. 

When you load a package it loads the first instance it comes across, user comes before system. To check - `find.package("tidyverse")`

All your projects use these paths! If you load different packages and versions of them + dependencies. E.g.

* Project 1 used `sf` version 0.9-8
* Project 2 used `sf` version 0.9-6

Switching between projects would mean you have the wrong version as they use the same libraries. 

`renv` - each project gets it's own library! Project local libraries. 

When you use `renv::init()` the library path will be changed to a project local one. 

It will create a lock file that holds all the package information. 

To re-create my environment once you have forked and pulled this repository you would use `renv::restore()`. 
Of course some projects use the same package version --- such as `tidyverse`, `renv` has a global cache of all the libraries. So there is a massive database of your libraries then each project library links it from there, meaning you don't have 10 versions of the same `tidyverse`.

## Referencing and more

You can do almost anything with RMarkdown, but most of these go beyond the scope of this practical. If you are interested have a look at the following links and instructions I've previously written:

* [Citing using Zotero](https://andrewmaclachlan.github.io/CASA-MSc-thesis/crossref.html#citing-using-software) 
* [Citing using Mendeley](https://andrewmaclachlan.github.io/CASA0005repo_20202021/git-github-and-rmarkdown.html#adding-references)
* [Using renv with git](https://andrewmaclachlan.github.io/CASA-MSc-thesis/bookdown-basics.html#package-reproducibility)
* [Creating a Binder for your R project](https://andrewmaclachlan.github.io/CASA0005repo_20202021/git-github-and-rmarkdown.html#binder)


<!--chapter:end:13-extra.Rmd-->

